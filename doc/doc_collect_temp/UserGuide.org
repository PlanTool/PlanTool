#+TITLE: PlanTool Documentation
* Introduction
  Plantool wraps different planners into a python utility package. It aims to provide convenience for planning study and applications.
* Installation
* Planners
** Deterministic
   Deterministic planners
*** SGPlan
     - Usage for SGPlan: 
     #+BEGIN_SRC python
     >>> import sgplan
     >>> argv = ['sgplan', '-o', 'domain.pddl', '-f', 'problem.pddl']
     >>> sgplan.oldmain(argv)
     #+END_SRC
    
     - Instructions about arguments:

       | OPTIONS   | DESCRIPTIONS       |
       |-----------+--------------------|
       | -o <str>  | operator file name |
       | -f  <str> | fact file name     |


*** SatPlan2006
     - Usage for SATplan:  
       #+BEGIN_SRC python
       >>> import satplan  
       >>> argv=['bb','-o','domain.pddl','-f','problem.pddl','-l','5','-G','0','-C','2']  
       >>> satplan.run(argv)  
       #+END_SRC
     
     - Instructions about arguments:

       | OPTIONS     | DESCRIPTIONS                                                       |
       |-------------+--------------------------------------------------------------------|
       | -o <str>    | operator file name                                                 |
       | -f  <str>   | fact file name                                                     |
       | -p  <str>   | path for operator and fact file                                    |
       | -l  <num>   | goal layer for CNF                                                 |
       | -G <0 or 1> | (0) create CNF output or (1) build final solution                  |
       | -b  <str>   | CNF output file name                                               |
       | -t <0 or 1> | (1) CNF output includes only unary/binary clauses - others ignored |
       | -S  <str>   | Input Solution File Name (only when -G 1 is used)                  |
       | -F  <str>   | Final Output Solution File Name (only when -G 1 is used)           |
       | -V  <str>   | Variables File Name - list all variables (only when -G 1 is used)  |
       | -C          | CNF formula output (preset: -1); at layer <-l>                     |
       | -C 0        | none                                                               |
       | -C 1        | action-based                                                       |
       | -C 2        | gp-style action-based                                              |
       | -C 3        | gp-based                                                           |
       | -C 4        | thin gp-based                                                      |
      
   
*** HSP
    - Usage for HSP: 
      #+BEGIN_SRC python
      >>> import hsp
      >>> argv = ['hsp', '-o', 'domain.pddl', '-f', 'problem.pddl']
      >>> hsp.run(argv)
      #+END_SRC

    - Instructions about arguments:
 
      | OPTIONS   | DESCRIPTIONS                                                              |
      |-----------+---------------------------------------------------------------------------|
      | -o  <str> | operator file name                                                        |
      | -f  <str> | <str>    fact file name                                                   |
      | -a  <str> | <str>    Algorithm, either 'bfs' or 'gbfs'.                               |
      | -d  <str> | <str>    Search direction, either 'forward' or 'backward'.                |
      | -h  <str> | <str>    Heuristic function, one of 'h1plus', 'h1max', 'h2plus', 'h2max'. |
      | -v  <num> | <num>    Verbose level >= 0 (default is 1).                               |
      | -w  <float> | <float>   Float to weight the heuristic component of the cost             |


*** LAMA
    - Usage for LAMA:
    1. First,run:
      #+BEGIN_SRC python
      >>> import translate
      >>> argv = ['translate','domain.pddl','problem.pddl']
      >>> translate.main(argv)
      #+END_SRC
      - translate
        The translator will will write its result to a file called
        "output.sas", which serves as an input to the next phase, knowledge
        compilation. The translator also writes a file called
        "test.groups", which is some sort of translation key (see
        "sas-format.txt" in the documentation directory mentioned above).
        This second file is not needed by the planner, but might help you
        understand what the translated task looks like. It also writes a
        file called "all.groups" which is needed by the landmark heuristic.

    2. Second, run:
       #+BEGIN_SRC python
       >>> import preprocess
       >>> argv = ['preprocess','< output.sas']
       >>> preprocess.oldmain(argv)
       #+END_SRC

       - preprocess
         This will run the knowledge compilation component, writing its
         output to the file aptly named "output".

    3. Finally, run:
       #+BEGIN_SRC python
       >>> import search
       >>> argv = ['search','f','< output']
       >>> search.oldmain(argv)
       #+END_SRC

       - search
         note 
         This runs the search component of the planner. On success, it will
         write a file called "sas_plan" containing the plan.
         OPTIONS DESCRIPTIONS
         l:  Use the landmark heuristic.
         L:  Use preferred operators of the landmark heuristic.
         f:  Use the FF heuristic.
         F:  Use helpful actions ("preferred operators" of the FF
         heuristic).


*** GP-CSP
    
    - 2017.05.24 更新
     GP-CSP目前未找到可以解的问题以及领域pddl

    - Usage for GP-CSP
      #+BEGIN_SRC python
      >>> import gpcsp
      >>> argv = ['gpcsp', '-o', 'domain.pddl', '-f', 'problem.pddl']
      >>> gpcsp.run(argv)
      #+END_SRC

    - Instructions about arguments:
      | OPTIONS          | DESCRIPTIONS                                                     |
      | -h               | for this list                                                    |
      | -o <op file>     | to specify operator file                                         |
      | -f <fact file>   | to specify fact file                                             |
      | -t <integer>     | to specify a fixed number of time steps                          |
      | -i <info level>  | to specify info level 1 or 2 (default is 0)                      |
      | -O <option list> | to specify options you want                                      |
      | -M <integer>     | to specify alternative max nodes in a time step (default is 256) |
      | -d               | give default values to everything not specified                  |
      | -csp             | to run the CSP solver                                            |
      | -nopddl          | to take graphplan type problem description                       |
      | -ns <integer>    | to specify the maximum size of nogoods to learn                  |
      | -nr <integer>    | to specify the relevance-k value                                 |
      | -cutoff <long>   | to specify the cutoff limit for CSP solver                       |
      | -ldc             | to specify the use *ldc* var-order when solving the CSP          |
      | -dlc             | to specify the use of *dlc* var-order when solving the CSP       |
      | -switch          | switch to the other var-order when over the cutoff-limit         |

     - EXAMPLES
     Example1: gpcsp -o -nopddl fixit_ops -f fixit_facts1 -O IL -d
     Run original graphplan with original input format (not pddl).
     Example2: gpcsp -csp -ldc -cutoff 50000 -o a_ops.pddl -f a_facts.pddl
     Run GP-CSP with *ldc* variable ordering with cutoff-limit of 50000.
     Example3: gpcsp -csp -ns 100 -nr 5 -o fixit_ops.pddl -f fixit_ops.pddl
     Run GP-CSP with default variable ordering (dcl), with the maximum
     nogood size of 100, and will prune all irrelevant nogoods of size>5.
     Example4: gpcsp -csp -switch -cutoff 10000 -o ......
     Run GP-CSP with the cutoff-limit of 10000. Then switch from default
     var-ordering to ldc var-ordering.
     Example5: gpcsp -csp -ldc -cutoff 100 -switch -o ....
     Similar to Example4, but switch from *ldc* var-ordering to default
     var-ordering

** Learning
** Uncertainty
  
