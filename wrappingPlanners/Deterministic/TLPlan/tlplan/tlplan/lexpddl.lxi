/* lexpddl.lxi

Copyright C, 2002, F. Bacchus

Log:

Name		Date	Description

M Ady		020203	First Version

*/

%{

/* lexpddl.c -- pddl language lexical analyzer

Copyright C, 2002, F. Bacchus

This module was created automatically from the file lexpddl.lxi.

Do not edit this file, edit and rebuild lexpddl.lxi instead.

Notes:
	1.  XList structures are not allocated for list punctuation.
*/

#include <ctype.h>
#include <setjmp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WIN32 
#include <windows.h>
#endif /* WIN32 */

#include "tlplan.h"
#include "domain.h"
#include "formula.h"
#include "iface.h"
#include "lexpddl.h"
#include "list.h"
#include "makeform.h"
#include "plan.h"
#include "tlparse.h"
#include "tl_tab.h"
#include "util.h"

/* redefine input routine */

#undef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	result=(*pfYYInput)(buf,max_size)

/* yylval type */

#undef YYSTYPE
#define YYSTYPE XLISTP

/* yylex prototype */

#undef YY_DECL							/* lex yylex type */
#define YY_DECL int pddllex(YYSTYPE *pxValue)

/* handle unrecognized token */

#undef ECHO
#define ECHO \
	return(BADTOK)

/* XLIST structure types */

#define XATOM_IDENT		0				/* identifier */
#define XATOM_LIST		1				/* list */

typedef struct XList					/* XList element (atom) */
{
	struct XList *pxNext;				/* pointer to next */
	int nType;							/* atomic type (identifier or list) */
	int nCode;							/* token code */
	char *psValue;						/* string pointer */
	struct XList *pxValue;				/* list pointer */
}XLIST, *XLISTP;

/* local function prototypes */

static XLISTP NewXList
(
	int nType,							/* atomic type */
	int nCode,							/* token code */
	char *psName						/* literal (string) value */
);
static XLISTP CopyXList
(
	XLISTP px							/* xlist to copy */
);

//void yyerror
//(
//	char *ps							/* message to print */
//);
//int yy_input
//(
//	char *psBuf,
//	int nMaxSize
//);
//int (*pfYYInput)(char *, int);			/* lex input function pointer */

static XLISTP ParsePddl(void);
static BOOL ParseXList
(
	XLISTP pxParent						/* address of parent XList */
);
static BOOL TranslatePddlProblem
(
	XLISTP pxTree						/* parse tree */
);
static LISTP TranslateXList
(
	XLISTP pxList						/* XList pointer */ 
);
static int ListType
(
	int nCode							/* pddl token code */
);

static char *psDomain;					/* domain name */


YY_DECL;								/* yylex declaration */

/* token definitions */

#define	OPEN_BRAC	257
#define	CLOSE_BRAC	258
#define	OPEN_SQ	259
#define	CLOSE_SQ	260
#define	DEFINE	261
#define	DOMAIN	262
#define	REQS	263
#define	EQUALITY	264
#define	STRIPS	265
#define	ADL	266
#define	TYPING	267
#define	DISJUNCTIVE_PRECONDS	268
#define	EXT_PRECS	269
#define	UNIV_PRECS	270
#define	QUANT_PRECS	271
#define	COND_EFFS	272
#define	FLUENTS	273
#define	TIME	274
#define	DURATIVE_ACTIONS	275
#define	DURATION_INEQUALITIES	276
#define	CONTINUOUS_EFFECTS	277
#define	ACTION	278
#define	PROCESS	279
#define	EVENT	280
#define	DURATIVE_ACTION	281
#define	CONSTANTS	282
#define	PREDS	283
#define	FUNCTIONS	284
#define	TYPES	285
#define	ARGS	286
#define	PRE	287
#define	CONDITION	288
#define	START_PRE	289
#define	END_PRE	290
#define	EFFECTS	291
#define	INITIAL_EFFECT	292
#define	FINAL_EFFECT	293
#define	INVARIANT	294
#define	DURATION	295
#define	AT_START	296
#define	AT_END	297
#define	OVER_ALL	298
#define	AND	299
#define	OR	300
#define	EXISTS	301
#define	FORALL	302
#define	IMPLY	303
#define	NOT	304
#define	WHEN	305
#define	EITHER	306
#define	PROBLEM	307
#define	FORDOMAIN	308
#define	INITIALLY	309
#define	OBJECTS	310
#define	GOALS	311
#define	EQ	312
#define	LENGTH	313
#define	SERIAL	314
#define	PARALLEL	315
#define	METRIC	316
#define	MINIMIZE	317
#define	MAXIMIZE	318
#define	HASHT	319
#define	DURATION_VAR	320
#define	TOTAL_TIME	321
#define	INCREASE	322
#define	DECREASE	323
#define	SCALE_UP	324
#define	SCALE_DOWN	325
#define	ASSIGN	326
#define	GREATER	327
#define	GREATEQ	328
#define	LESS	329
#define	LESSEQ	330
#define	Q	331
#define	COLON	332
#define	BOGUS	333
#define	NAME	334
#define	FUNCTION_SYMBOL	335
#define	INTVAL	336
#define	FLOATVAL	337
#define	HYPHEN	338
#define	PLUS	339
#define	MUL	340
#define	DIV	341
#define	UMINUS	342
#define BADTOK 5000

%}

%option prefix="pddl"

char [a-zA-Z_]
digit [0-9]
int -?{digit}*
float -?{digit}+(\.{digit}*)?
string {char}+(-|{char}|{digit})*
whitespace [ \t]+
nl \n
comment ;.*$

%%
"("										{*pxValue=0;return OPEN_BRAC;}
")"										{*pxValue=0;return CLOSE_BRAC;}
"["										{*pxValue=NewXList(XATOM_IDENT,OPEN_SQ,yytext);return OPEN_SQ;}
"]"										{*pxValue=NewXList(XATOM_IDENT,CLOSE_SQ,yytext);return CLOSE_SQ;}
":requirements"							{*pxValue=NewXList(XATOM_IDENT,REQS,yytext);return REQS;}
":equality"								{*pxValue=NewXList(XATOM_IDENT,EQUALITY,yytext);return EQUALITY;}
":strips"								{*pxValue=NewXList(XATOM_IDENT,STRIPS,yytext);return STRIPS;}
":adl"									{*pxValue=NewXList(XATOM_IDENT,ADL,yytext);return ADL;}
":typing"								{*pxValue=NewXList(XATOM_IDENT,TYPING,yytext);return TYPING;}
":disjunctive-preconditions"			{*pxValue=NewXList(XATOM_IDENT,DISJUNCTIVE_PRECONDS,yytext);return DISJUNCTIVE_PRECONDS;}
":existential-preconditions"			{*pxValue=NewXList(XATOM_IDENT,EXT_PRECS,yytext);return EXT_PRECS;}
":universal-preconditions"				{*pxValue=NewXList(XATOM_IDENT,UNIV_PRECS,yytext);return UNIV_PRECS;}
":quantified-preconditions"				{*pxValue=NewXList(XATOM_IDENT,QUANT_PRECS,yytext);return QUANT_PRECS;}
":conditional-effects"					{*pxValue=NewXList(XATOM_IDENT,COND_EFFS,yytext);return COND_EFFS;}
":fluents"								{*pxValue=NewXList(XATOM_IDENT,FLUENTS,yytext);return FLUENTS;}
":time"									{*pxValue=NewXList(XATOM_IDENT,TIME,yytext);return TIME;}
":constants"							{*pxValue=NewXList(XATOM_IDENT,CONSTANTS,yytext);return CONSTANTS;}
":predicates"							{*pxValue=NewXList(XATOM_IDENT,PREDS,yytext);return PREDS;}
":functions"							{*pxValue=NewXList(XATOM_IDENT,FUNCTIONS,yytext);return FUNCTIONS;}
":types"								{*pxValue=NewXList(XATOM_IDENT,TYPES,yytext);return TYPES;}
":durative-actions"						{*pxValue=NewXList(XATOM_IDENT,DURATIVE_ACTIONS,yytext);return DURATIVE_ACTIONS;}
":duration-inequalities"				{*pxValue=NewXList(XATOM_IDENT,DURATION_INEQUALITIES,yytext);return DURATION_INEQUALITIES;}
":continuous-effects"					{*pxValue=NewXList(XATOM_IDENT,CONTINUOUS_EFFECTS,yytext);return CONTINUOUS_EFFECTS;}
"define"								{*pxValue=NewXList(XATOM_IDENT,DEFINE,yytext);return DEFINE;}
"domain"								{*pxValue=NewXList(XATOM_IDENT,DOMAIN,yytext);return DOMAIN;}
":action"								{*pxValue=NewXList(XATOM_IDENT,ACTION,yytext);return ACTION;}
":process"								{*pxValue=NewXList(XATOM_IDENT,PROCESS,yytext);return PROCESS;}
":event"								{*pxValue=NewXList(XATOM_IDENT,EVENT,yytext);return EVENT;}
":durative-action"						{*pxValue=NewXList(XATOM_IDENT,DURATIVE_ACTION,yytext);return DURATIVE_ACTION;}
":parameters"							{*pxValue=NewXList(XATOM_IDENT,ARGS,yytext);return ARGS;}
":precondition"							{*pxValue=NewXList(XATOM_IDENT,PRE,yytext);return PRE;}
":condition"							{*pxValue=NewXList(XATOM_IDENT,CONDITION,yytext);return CONDITION;}
":start-precondition"					{*pxValue=NewXList(XATOM_IDENT,START_PRE,yytext);return START_PRE;}
":end-precondition"						{*pxValue=NewXList(XATOM_IDENT,END_PRE,yytext);return END_PRE;}
"at start"								{*pxValue=NewXList(XATOM_IDENT,AT_START,yytext);return AT_START;}
"at end"								{*pxValue=NewXList(XATOM_IDENT,AT_END,yytext);return AT_END;}
"over all"								{*pxValue=NewXList(XATOM_IDENT,OVER_ALL,yytext);return OVER_ALL;}
":effect"								{*pxValue=NewXList(XATOM_IDENT,EFFECTS,yytext);return EFFECTS;}
":initial-effect"						{*pxValue=NewXList(XATOM_IDENT,INITIAL_EFFECT,yytext);return INITIAL_EFFECT;}
":final-effect"							{*pxValue=NewXList(XATOM_IDENT,FINAL_EFFECT,yytext);return FINAL_EFFECT;}
":invariant"							{*pxValue=NewXList(XATOM_IDENT,INVARIANT,yytext);return INVARIANT;}
":duration"								{*pxValue=NewXList(XATOM_IDENT,DURATION,yytext);return DURATION;}
"and"									{*pxValue=NewXList(XATOM_IDENT,AND,yytext);return AND;}
"or"									{*pxValue=NewXList(XATOM_IDENT,OR,yytext);return OR;}
"exists"								{*pxValue=NewXList(XATOM_IDENT,EXISTS,yytext);return EXISTS;}
"forall"								{*pxValue=NewXList(XATOM_IDENT,FORALL,yytext);return FORALL;}
"impxy"									{*pxValue=NewXList(XATOM_IDENT,IMPLY,yytext);return IMPLY;}
"not"									{*pxValue=NewXList(XATOM_IDENT,NOT,yytext);return NOT;}
"when"									{*pxValue=NewXList(XATOM_IDENT,WHEN,yytext);return WHEN;}
"either"								{*pxValue=NewXList(XATOM_IDENT,EITHER,yytext);return EITHER;}
"problem"								{*pxValue=NewXList(XATOM_IDENT,PROBLEM,yytext);return PROBLEM;}
":domain"								{*pxValue=NewXList(XATOM_IDENT,FORDOMAIN,yytext);return FORDOMAIN;}
":objects"								{*pxValue=NewXList(XATOM_IDENT,OBJECTS,yytext);return OBJECTS;}
":init"									{*pxValue=NewXList(XATOM_IDENT,INITIALLY,yytext);return INITIALLY;}
":goal"									{*pxValue=NewXList(XATOM_IDENT,GOALS,yytext);return GOALS;}
"="										{*pxValue=NewXList(XATOM_IDENT,EQ,yytext);return EQ;}
":length"								{*pxValue=NewXList(XATOM_IDENT,LENGTH,yytext);return LENGTH;}
":serial"								{*pxValue=NewXList(XATOM_IDENT,SERIAL,yytext);return SERIAL;}
":parallel"								{*pxValue=NewXList(XATOM_IDENT,PARALLEL,yytext);return PARALLEL;}
":metric"								{*pxValue=NewXList(XATOM_IDENT,METRIC,yytext);return METRIC;}
"minimize"								{*pxValue=NewXList(XATOM_IDENT,MINIMIZE,yytext);return MINIMIZE;}
"maximize"								{*pxValue=NewXList(XATOM_IDENT,MAXIMIZE,yytext);return MAXIMIZE;}
"#t"									{*pxValue=NewXList(XATOM_IDENT,HASHT,yytext);return HASHT;}
"duration"								{*pxValue=NewXList(XATOM_IDENT,DURATION_VAR,yytext);return DURATION_VAR;}
"total-time"							{*pxValue=NewXList(XATOM_IDENT,TOTAL_TIME,yytext);return TOTAL_TIME;}
"increase"  							{*pxValue=NewXList(XATOM_IDENT,INCREASE,yytext);return INCREASE;}
"decrease"  							{*pxValue=NewXList(XATOM_IDENT,DECREASE,yytext);return DECREASE;}
"scale-up"  							{*pxValue=NewXList(XATOM_IDENT,SCALE_UP,yytext);return SCALE_UP;}
"scale-down"							{*pxValue=NewXList(XATOM_IDENT,SCALE_DOWN,yytext);return SCALE_DOWN;}
"assign"    							{*pxValue=NewXList(XATOM_IDENT,ASSIGN,yytext);return ASSIGN;}
"+"										{*pxValue=NewXList(XATOM_IDENT,PLUS,yytext);return PLUS;}
"-"										{*pxValue=NewXList(XATOM_IDENT,HYPHEN,yytext);return HYPHEN;}
"*"										{*pxValue=NewXList(XATOM_IDENT,MUL,yytext);return MUL;}
"/"										{*pxValue=NewXList(XATOM_IDENT,DIV,yytext);return DIV;}
">"										{*pxValue=NewXList(XATOM_IDENT,GREATER,yytext);return GREATER;}
">="									{*pxValue=NewXList(XATOM_IDENT,GREATEQ,yytext);return GREATEQ;}
"<"										{*pxValue=NewXList(XATOM_IDENT,LESS,yytext);return LESS;}
"<="									{*pxValue=NewXList(XATOM_IDENT,LESSEQ,yytext);return LESSEQ;}
"?"										{*pxValue=NewXList(XATOM_IDENT,Q,yytext);return Q;}
":"										{*pxValue=NewXList(XATOM_IDENT,COLON,yytext);return COLON;}

{string}								{*pxValue=NewXList(XATOM_IDENT,NAME,yytext);return(NAME);}
"?"{string}								{*pxValue=NewXList(XATOM_IDENT,NAME,yytext);return(NAME);}

{whitespace} ;
{comment} ;
{nl}									{nLineNumber++;};

{int}									{*pxValue=NewXList(XATOM_IDENT,INTVAL,yytext);return(INTVAL);}
{float}									{*pxValue=NewXList(XATOM_IDENT,FLOATVAL,yytext);return(FLOATVAL);}

%% 

/* ParsePddl -------------------------------------------------------------------

Description:
	Open the specified pddl problem file.  Parse the input and execute it.
*/

static XLISTP ParsePddl(void)
{
	XLISTP px;							/* parse tree */

	/* allocate parent list */
	
	px=(XLISTP)MemAlloc(sizeof(XLIST));
	px->nType=XATOM_LIST;

	ParseXList(px);

	return px;
}

/* ParseXList

Description:
	Simple recursive descent list parser.
*/

static BOOL ParseXList
(
	XLISTP pxParent						/* address of parent XList */
)
{
	XLISTP pxNested;					/* nested XList */
	XLISTP pxValue;						/* token value */
	XLISTP *ppxNext;					/* address of next pointer */
	int nCode;

	ppxNext=&pxParent->pxValue;
	for(;;)
	{
		nCode=pddllex(&pxValue);
		switch(nCode)
		{
			case 0:						/* ??? */
				return TRUE;
			case EOF:
				fprintf(stderr,"Unexpected end of file\n");
				return FALSE;
			case OPEN_BRAC:				/* nested list */
				pxNested=NewXList(XATOM_LIST,0,0);
				*ppxNext=pxNested;
				ppxNext=&pxNested->pxNext;
				if(!ParseXList(pxNested))
					return FALSE;
				break;
			case CLOSE_BRAC:			/* end of list, return */
				return TRUE;
			default:
				*ppxNext=pxValue;
				ppxNext=&pxValue->pxNext;
		}
	}
	return TRUE;
}

/* LoadPddlProblem

Description:
	Open the specified pddl problem file.  Parse the input and execute it.
*/

DECLSPEC void LoadPddlProblem
(
	char *psFile						/* file name */
)
{
	FILE *pfInputSaved;					/* saved input file stream */
	YY_BUFFER_STATE ybfSaved;			/* saved buffer state */
	int nLineNumberSaved;				/* saved line number */
	char *psCurrentFileSaved;			/* saved file name */
	BOOL bInteractiveModeSaved;			/* saved interactive mode */
	XLISTP pxTree;						/* parse tree */

	dfPddlTime=GetInternalRunTime();	/* start our timer */

	/* push our current file context */

	pfInputSaved=pfInput;
	nLineNumberSaved=nLineNumber;
	bInteractiveModeSaved=bInteractiveMode;
	psCurrentFileSaved=psCurrentFile;

	/* open the file */

	if((int)psFile>0)
	{
		bInteractiveMode=FALSE;
		if(bVerbose)
			Message("Loading PDDL file: %s\n",psFile);
		pfInput=fopen(psFile,"r");
		if(!pfInput)
		{	
			ErrorMessage("Failed to open PDDL file %s\n",psFile);
			perror("File open failure");
			goto cleanup;
		}
	}
	else if(!psFile)
	{
		bInteractiveMode=TRUE;
		if(bVerbose)
			Message("Opening interactive session...\n");
		pfInput=stdin;
	}
	else
	{
		bInteractiveMode=TRUE;
		pfInput=0;
	}

	if(pfInput==stdin)
	{
		psCurrentFile=(char *)malloc(strlen("interactive session")+1);
		strcpy(psCurrentFile,"interactive session");
	}
	else if(!pfInput)
	{
		psCurrentFile=(char *)malloc(strlen("window session")+1);
		strcpy(psCurrentFile,"window session");
	}
	else
	{
		psCurrentFile=(char *)malloc(strlen(psFile)+1);
		strcpy(psCurrentFile,psFile);
	}

	ybfSaved=YY_CURRENT_BUFFER;
	if(ybfSaved)
		yy_switch_to_buffer(yy_create_buffer(pfInput,YY_BUF_SIZE));

	/* read in the file */

	nLineNumber=1;
	if(bInteractiveMode)
		CommandPrintf(stdout,"OK> ");
	pxTree=ParsePddl();
	TranslatePddlProblem(pxTree->pxValue);

	/* clean up */

	if(pfInput&&pfInput!=stdin)
		fclose(pfInput);
	free(psCurrentFile);

	/* pop our saved file context */

	if(ybfSaved)
		yy_switch_to_buffer(ybfSaved);	/* restore saved buffer */
cleanup:
	pfInput=pfInputSaved;
	nLineNumber=nLineNumberSaved;
	bInteractiveMode=bInteractiveModeSaved;
	psCurrentFile=psCurrentFileSaved;
}

/* TranslatePDDLProblem

Description:
	Write out a pddl parse tree in tlplan format.
*/
static BOOL TranslatePddlProblem
(
	XLISTP pxTree						/* parse tree */
)
{
	XLISTP px;							/* parse tree pointer */
	XLISTP px1;							/* parse tree pointer */
	XLISTP px2;							/* parse tree pointer */
	XLISTP px3;							/* parse tree pointer */
	XLISTP pxSave;						/* parse tree pointer */
	CELLP pcCommand;					/* command cell pointer */
	char acBuf[256];					/* format buffer */
	LISTP plStart,plEnd;				/* list head */
	LISTP plStart1,plEnd1;				/* list head */
	LISTP plStart2,plEnd2;				/* list head */
	XLISTP pxStart,pxEnd;				/* xlist head */
	LITVAL lvDomain;					/* domain name */
	SYMBOLP psSymbol;					/* symbol table entry */
			
	char *psProblem;					/* problem name */

	if(pxTree->nType!=XATOM_LIST)
	{
		fprintf(stderr,"load-pddl-problem:  Expected a list.\n");
		return FALSE;
	}
	px=pxTree->pxValue;
	if(!px||px->nCode!=DEFINE)
	{
		fprintf(stderr,"load-pddl-problem:  Expected \"define\"\n");
		return FALSE;
	}

	px=px->pxNext;
	if(!px||px->nType!=XATOM_LIST)
	{
		fprintf(stderr,"load-pddl-problem:  Expected a problem list.\n");
		return FALSE;
	}
	px1=px->pxValue;
	if(px1->nCode!=PROBLEM)
	{
		fprintf(stderr,"load-pddl-problem:  Expected \"problem\"\n");
		return FALSE;
	}

	px1=px1->pxNext;
	if(px1->nCode!=NAME)
	{
		fprintf(stderr,"load-pddl-problem:  Expected problem name\n");
		return FALSE;
	}
	psProblem=px1->psValue;				/* save problem name */
	pxSave=px;							/* save our context */

	for(px=pxSave;px;px=px->pxNext)
	{
		if(px->nType!=XATOM_LIST)
		{
			fprintf(stderr,"load-pddl-problem:  Expected a list.\n");
			return FALSE;
		}
	}

	// the domain
	
	psDomain=NULL;
	for(px=pxSave;px;px=px->pxNext)
	{
		px1=px->pxValue;
		switch(px1->nCode)
		{
			case FORDOMAIN:
				px1=px1->pxNext;
				if(px1->nCode!=NAME)
				{
					fprintf(stderr,"load-pddl-problem:  Expected domain name\n");
					return FALSE;
				}
				psDomain=px1->psValue;
				lvDomain.psString=psDomain;
				pcCommand=CompileArgForm(&aLoadDomainAction,MakeLiteralForm(ATOM_IDENT,lvDomain));
				(*pcCommand->pfForm->paAction->pfEval)(pcCommand,plpCurrentPlan,pbGlobalVariables);
				break;
		}
	}

	// the objects list
	// we ignore types that have not been declared

	for(px=pxSave;px;px=px->pxNext)
	{
		px1=px->pxValue;
		switch(px1->nCode)
		{
			case OBJECTS:
				pxStart=NULL;			/* initialize object xlist */
				pxEnd=(XLISTP)&pxStart;

				px1=px1->pxNext;		/* point to first object name */
				for(px2=px1;px2;px2=px2->pxNext)	/* scan object list for next type */
				{
					if(px2->nCode==HYPHEN)	/* next token is type if we see a hyphen */
					{
						px3=px2;		/* save pointer to terminating token */
						px2=px2->pxNext;	/* point to type */
						if(!px2)
						{
							fprintf(stderr,"load-pddl-problem:  Unexpected end of object list\n");
							return FALSE;
						}
						if(SymbolLookup(strlwr(px2->psValue),&psSymbol))	/* if this is a domain symbol */
						{
							for(;px1!=px3;px1=px1->pxNext)	/* for all objects of this type */
							{
								pxEnd=pxEnd->pxNext=NewXList(XATOM_LIST,0,NULL);	/* create a (type name) list */
								pxEnd->pxValue=NewXList(XATOM_IDENT,NAME,px2->psValue);
								pxEnd->pxValue->pxNext=CopyXList(px1);
							}
						}
						px1=px2->pxNext;	/* point to next object name */
					}
				}
				break;
		}
	}

	// the initial state
	
	for(px=pxSave;px;px=px->pxNext)
	{
		px1=px->pxValue;
		switch(px1->nCode)
		{
			case INITIALLY:
				plStart=NULL;
				plEnd=(LISTP)&plStart;
				plEnd=plEnd->plNext=NewList(ATOM_IDENT,"define");
				sprintf(acBuf,"state-%s",psProblem);
				plEnd=plEnd->plNext=NewList(ATOM_IDENT,acBuf);

				/* translate object list */

				for(px2=pxStart;px2;px2=px2->pxNext)
					plEnd=plEnd->plNext=TranslateXList(px2);

				/* translate initial world */
				
				for(px1=px1->pxNext;px1;px1=px1->pxNext)
					plEnd=plEnd->plNext=TranslateXList(px1);
				
				plStart=NewList(ATOM_LISTP,"",plStart);	/* enclose list */
				ExecuteList(plStart);
				break;
		}
	}

	// the goal
	
	if(stricmp(psDomain,"taxi"))			// kludge alert!!!
	{
		for(px=pxSave;px;px=px->pxNext)
		{
			px1=px->pxValue;
			switch(px1->nCode)
			{
				case GOALS:
	
					// first remove outer conjunction

					px2=px1->pxNext;
					if(!px2||px2->nType!=XATOM_LIST)
					{
						fprintf(stderr,"load-pddl-problem:  Expected a list.\n");
						return FALSE;
					}
					px2=px2->pxValue;
					if(px2->nCode==AND)
						px1=px2;

					plStart=NULL;
					plEnd=(LISTP)&plStart;
					plEnd=plEnd->plNext=NewList(ATOM_IDENT,"define");
					sprintf(acBuf,"goal-%s",psProblem);
					plEnd=plEnd->plNext=NewList(ATOM_IDENT,acBuf);
					for(px1=px1->pxNext;px1;px1=px1->pxNext)
						plEnd=plEnd->plNext=TranslateXList(px1);
					plStart=NewList(ATOM_LISTP,"",plStart);
					ExecuteList(plStart);
					break;
			}
		}

		// set-goal

		plStart=NULL;
		plEnd=(LISTP)&plStart;
		plEnd=plEnd->plNext=NewList(ATOM_IDENT,"set-goal");
		sprintf(acBuf,"goal-%s",psProblem);
		plEnd=plEnd->plNext=NewList(ATOM_LISTP,"",NewList(ATOM_IDENT,acBuf));
		plStart=NewList(ATOM_LISTP,"",plStart);
		ExecuteList(plStart);
	}
	
	// set-initial-world

	plStart=NULL;
	plEnd=(LISTP)&plStart;
	plEnd=plEnd->plNext=NewList(ATOM_IDENT,"set-initial-world");
	sprintf(acBuf,"state-%s",psProblem);
	plEnd=plEnd->plNext=NewList(ATOM_LISTP,"",NewList(ATOM_IDENT,acBuf));
	plStart=NewList(ATOM_LISTP,"",plStart);
	ExecuteList(plStart);

	// set-plan-name
	
	pcCommand=CompileArgForm(&aSetPlanNameAction,MakeStringForm(psCurrentFile));
	(*pcCommand->pfForm->paAction->pfEval)(pcCommand,plpCurrentPlan,pbGlobalVariables);

	// set-heuristic-fn or set-priority-fn
	
	if(nPddlSupport!=PDDL_IGNORE_METRIC)
	{
		for(px=pxSave;px;px=px->pxNext)
		{
			px1=px->pxValue;
			switch(px1->nCode)
			{
				case METRIC:
					plStart=NULL;			// initialize list head
					plEnd=(LISTP)&plStart;

					/* def-defined-function */

					plEnd=plEnd->plNext=NewList(ATOM_IDENT,"def-defined-function");
					plEnd=plEnd->plNext=NewList(ATOM_LISTP,"",NewList(ATOM_IDENT,"metric"));

					px2=px1->pxNext;		// point to minimize/maximize
					px3=px2->pxNext;		// point to expression to evaluate

					/* translate expression */

					plStart1=NULL;			// initialize list head
					plEnd1=(LISTP)&plStart1;
					if((px2->nCode==MAXIMIZE)!=(nPddlSupport==PDDL_PRIORITY_METRIC))	// invert formula for maximize xor priority
					{
						plEnd1=plEnd1->plNext=NewList(ATOM_IDENT,"*");
						plEnd1=plEnd1->plNext=NewList(ATOM_FLOAT,"-1.0");
					}				
					plEnd1=plEnd1->plNext=TranslateXList(px3);
					if(px2->nCode==MAXIMIZE)
						plStart1=NewList(ATOM_LISTP,"",plStart1);	/* enclose list */

					/* assign value */

					plStart2=NULL;			// initialize list head
					plEnd2=(LISTP)&plStart2;
					plEnd2=plEnd2->plNext=NewList(ATOM_IDENT,":=");
					plEnd2=plEnd2->plNext=NewList(ATOM_IDENT,"metric");
					plEnd2->plNext=plStart1;
					plStart2=NewList(ATOM_LISTP,"",plStart2);	/* enclose list */

					plEnd=plEnd->plNext=plStart2;
					plStart=NewList(ATOM_LISTP,"",plStart);	/* enclose list */
					ExecuteList(plStart);

					/* set-heuristic-fn or set-priority-fn */
				
					plStart1=NewList(ATOM_IDENT,"metric");
					plStart1=NewList(ATOM_LISTP,"",plStart1);	/* enclose list */
					if(nPddlSupport=PDDL_HEURISTIC_METRIC)
						plStart=NewList(ATOM_IDENT,"set-heuristic-fn");
					else
						plStart=NewList(ATOM_IDENT,"set-priority-fn");
					plStart->plNext=plStart1;
					plStart=NewList(ATOM_LISTP,"",plStart);	/* enclose list */
					ExecuteList(plStart);
					break;
			}
		}
	}

//	// plan
//
//	pcCommand=CompileArgForm(&aPlanAction,NULL);
//	(*pcCommand->pfForm->paAction->pfEval)(pcCommand,plpCurrentPlan,pbGlobalVariables);

	return TRUE;
}

/* TranslateXList

Description:
	Recursive routine to translate an XList
*/

static LISTP TranslateXList
(
	XLISTP pxList						/* list pointer */ 
)
{
	LISTP plStart,plEnd;				/* list head */
	XLISTP px;							/* XList pointer */
	
	plStart=NULL;
	plEnd=(LISTP)&plStart;

	// translate elements
	
	for(px=pxList->pxValue;px;px=px->pxNext)
	{
		if(px->nType==XATOM_LIST)
			plEnd=plEnd->plNext=TranslateXList(px);
		else
		{
			if(!stricmp(psDomain,"zeno-travel"))	/* kludge alert! */
			{
				if(!stricmp(px->psValue,"next"))
				{
					px->psValue=(char *)MemAlloc(strlen("fuel-next")+1);
					strcpy(px->psValue,"fuel-next");
				}
			}
			plEnd=plEnd->plNext=NewList(ListType(px->nCode),px->psValue);
		}
	}
	return NewList(ATOM_LISTP,"",plStart);
}

/* ListType

Description:
	Convert an XLIST token type to a LIST atom type.
*/

static int ListType
(
	int nCode							/* pddl token code */
)
{
	switch(nCode)
	{
		case INTVAL:
			return ATOM_INTEGER;
		case FLOATVAL:
			return ATOM_FLOAT;
	}
	return ATOM_IDENT;					/* everything else is an ident */
}

/* NewXList

Description:
	Allocate and fill in a single xlist element.
*/

static XLISTP NewXList
(
	int nType,							/* atomic type */
	int nCode,							/* token code */
	char *psName						/* literal (string) value */
)
{
	XLISTP px;							/* XList pointer */

	px=(XLISTP)MemAlloc(sizeof(XLIST));
	px->nType=nType;
	px->nCode=nCode;
	if(psName)
	{
		px->psValue=(char *)MemAlloc(strlen(psName)+1);
		strcpy(px->psValue,psName);
	}
	return px;
}

/* CopyXList

Description:
	Allocate and fill in a single xlist element.
	The pxNext and pxValue pointers are explicitly zeroed.
*/

static XLISTP CopyXList
(
	XLISTP px							/* xlist to copy */
)
{
	XLISTP pxNew;						/* new XList pointer */

	pxNew=(XLISTP)MemAlloc(sizeof(XLIST));
	memcpy(pxNew,px,sizeof(XLIST));
	pxNew->pxNext=NULL;
	pxNew->pxValue=NULL;
	return pxNew;
}


int yywrap()
{
	return 1;
};
