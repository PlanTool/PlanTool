adl.c:Copyright C, 1996 - 2001,  F. Bacchus
adl.c:Each time the parser sees an outermost def-adl-operator list,
adl.c:ADL Operators ------------------------------------------------------------------
adl.c:(def-adl-operator (puton ?x ?y)
adl.c:		(last-moved ?x))
adl.c:		(?z) (last-moved ?z)
adl.c:		(del (last-moved ?z))))
adl.c:(define (def-adl-operator . keyword-args)
adl.c:			(modifier-formulas '())
adl.c:			(update-form '())
adl.c:			(new-world '())
adl.c:			(call-fn '())
adl.c:			(name-op '())
adl.c:			(name-args '())
adl.c:			((null? keyword-args))
adl.c:			(case (first keyword-args)
adl.c:					(set! name (cadr keyword-args)))
adl.c:					(set! pre (cadr keyword-args)))
adl.c:					(set! add (cadr keyword-args)))
adl.c:					(set! del (cadr keyword-args)))
adl.c:					(set! duration (cadr keyword-args)))
adl.c:					(set! cost (cadr keyword-args)))
adl.c:					(set! priority (cadr keyword-args)))
adl.c:					(set! update (cadr keyword-args)))
adl.c:					(error "Illegal keyword: ~A" (first keyword-args))))
adl.c:			(set! keyword-args (cddr keyword-args)))
adl.c:			(make-operator :name name :pre pre :add add :del del
adl.c:		(set! name-op (get-operator name))
adl.c:		(set! name-args (get-args name))
adl.c:		(set! call-fn
adl.c:					(cons (make-world/action
adl.c:							new-world
adl.c:							(cons name-op (eval-terms name-args
adl.c:							(eval-term duration world/action bindings)
adl.c:							(eval-term cost world/action bindings)
adl.c:		(set! modifier-formulas (cons `(CALL ,call-fn) modifier-formulas))
adl.c:		(for-each
adl.c:					(for-each
adl.c:							(let* ((mod-literal (adl-mod-literal condition))
adl.c:									(mod-operator (get-operator mod-literal))
adl.c:									(mod-args (get-args mod-literal))
adl.c:									(update-formula '()))
adl.c:								(set! call-fn
adl.c:											(delete-world-lit
adl.c:												mod-operator
adl.c:												(eval-terms mod-args world/action
adl.c:												new-world))
adl.c:											(add-world-lit
adl.c:												mod-operator
adl.c:												(eval-terms mod-args world/action
adl.c:												new-world))))
adl.c:								(set! update-formula
adl.c:									(adl-compile-lambda
adl.c:										(adl-mod-var-gens condition)
adl.c:										(adl-mod-formula condition)
adl.c:										`(CALL ,call-fn)))
adl.c:								(set! modifier-formulas
adl.c:									(cons update-formula modifier-formulas))))
adl.c:		(for-each
adl.c:				(for-each
adl.c:						(let* ((mod-literal (adl-mod-literal condition))
adl.c:								(mod-operator (get-fn-name mod-literal))
adl.c:								(mod-args (get-fn-args mod-literal))
adl.c:								(mod-value (get-fn-value mod-literal))
adl.c:								(update-formula '()))
adl.c:							(set! call-fn
adl.c:									(update-world-fn
adl.c:										mod-operator
adl.c:										(eval-terms mod-args world/action bindings)
adl.c:										(eval-term mod-value world/action bindings)
adl.c:										new-world)))
adl.c:							(set! update-formula
adl.c:								(adl-compile-lambda
adl.c:									(adl-mod-var-gens condition)
adl.c:									(adl-mod-formula condition)
adl.c:									`(CALL ,call-fn)))
adl.c:							(set! modifier-formulas
adl.c:								(cons update-formula modifier-formulas))))
adl.c:		(set! call-fn
adl.c:				(set! new-world
adl.c:					(copy-world (world/action-world world/action)))))
adl.c:		(set! modifier-formulas
adl.c:			(cons `(CALL ,call-fn) modifier-formulas))
adl.c:		(set! modifier-formulas (cons 'AND modifier-formulas))
adl.c:		(set! update-form
adl.c:			(adl-compile-lambda
adl.c:				(adl-pre-var-gens pre)
adl.c:				(adl-pre-formula pre)
adl.c:				modifier-formulas))
adl.c:				(format #t  "~%~S~%~%" update-form)))
adl.c:		(set-operator-eval-object! op
adl.c:				(eval-formula update-form world/action '())
adl.c:		(add-op op)))
adl.c:	if(pcMod&&pcMod->pcNext)
adl.c:		pcSuccessor=CompileSuccessor(pcPre->pfForm->pcVars,pcPre->pfForm->pcArgs,pcModifyWorld);
adl.c:	/* create the operator and thread it back into modify-world */
adl.c:	pcModifyWorld->pfForm->pcArgs->pfForm->uValue.poOperator=po;
adl.c:			GetName(pcName->pfForm,ac));
adl.c:/* Parse Routines -------------------------------------------------------------- */
adl.c:	pcName=pcFormula->pfForm->pcArgs;
adl.c:		ErrorMessage("def-adl-operator:  No name or argument list specified.\n");
adl.c:	for(pc=pcName->pcNext;pc;pc=pc1)
adl.c:		pc1=pc->pcNext;
adl.c:		pc->pcNext=NULL;
adl.c:		if(StringEqQ(IdentName(pc->pfForm),apsStringTab[STRING_DURATION]))
adl.c:				ErrorMessage("def-adl-operator:  %s has more than one duration clause\n",
adl.c:					GetName(pcName->pfForm,ac));
adl.c:			pcDuration=pc->pfForm->pcArgs;
adl.c:		else if(StringEqQ(IdentName(pc->pfForm),apsStringTab[STRING_COST]))
adl.c:				ErrorMessage("def-adl-operator:  %s has more than one cost clause\n",
adl.c:					GetName(pcName->pfForm,ac));
adl.c:			pcCost=pc->pfForm->pcArgs;
adl.c:		else if(StringEqQ(IdentName(pc->pfForm),apsStringTab[STRING_PRIORITY]))
adl.c:				ErrorMessage("def-adl-operator:  %s has more than one priority clause\n",
adl.c:					GetName(pcName->pfForm,ac));
adl.c:			pcPriority=pc->pfForm->pcArgs;
adl.c:		else if(StringEqQ(IdentName(pc->pfForm),apsStringTab[STRING_PRE]))
adl.c:				ErrorMessage("def-adl-operator:  %s has more than one preconditions clause\n",
adl.c:					GetName(pcName->pfForm,ac));
adl.c:			pc->pcNext=pcMod;			/* prefix to modifier list */
adl.c:/* ModifyWorld Formula Support ------------------------------------------------- */
adl.c:	Make a modify-world formula.
adl.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
adl.c:	pf->nType=ATOM_IDENT;
adl.c:	pf->psName=IdentAlloc("modify-world");
adl.c:	pf->paAction=&aModifyWorldAction;
adl.c:	pf->pcArgs=MakeOperatorForm(poOperator);
adl.c:		pf->pcArgs->pcNext=CopyCell(pcMod);
adl.c:		pf->pcArgs->pcNext=pcMod;
adl.c:			pf->pcArgs->pcNext->pcNext=NULL;
adl.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
adl.c:	pf->nType=ATOM_OPERATORP;
adl.c:	pf->psName=IdentAlloc("operator");
adl.c:	pf->uValue.poOperator=poOperator;
adl.c:	pf->paAction=&aOperatorAction;
adl.c:    po=pcFormula->pfForm->pcArgs->pfForm->uValue.poOperator;
adl.c:    pcLabel=CopyFormula(po->pcName);	/* this is rather inefficient! */
adl.c:    if(po->pcName->pfForm->pcArgs)
adl.c:	pcLabel->pfForm->pcArgs=ComputeTerms(po->pcName->pfForm->pcArgs,plpLinearPlan,pbBindings);
adl.c:	if(!pcLabel->pfForm->pcArgs)
adl.c:	    TermError("eval-modify-world",pcFormula,pbBindings);
adl.c:    FormulaToDouble(po->pcDuration,plpLinearPlan,pbBindings,&dfDuration);
adl.c:    FormulaToDouble(po->pcCost,plpLinearPlan,pbBindings,&dfCost);
adl.c:    FormulaToDouble(po->pcPriority,plpLinearPlan,pbBindings,&dfPriority);
adl.c:	plpSuccessorWorld->dfTime=plpLinearPlan->dfTime;
adl.c:    pcMod=pcFormula->pfForm->pcArgs->pcNext;
adl.c:	(*pcMod->pfForm->paAction->pfEval)(pcMod,plpLinearPlan,pbBindings);
adl.c:	// Special processing for action promises (depth-first search only)
adl.c:		// Process previously generated action-promises
adl.c:		if(!plpLinearPlan->apbtWorld)
adl.c:			pbBindings=(BINDINGP)plpLinearPlan->nSignature;
adl.c:			pcMod=pcFormula->pfForm->pcArgs->pcNext;
adl.c:			apbtNewWorld=CopyWorld(LinearPlanWorld(plpLinearPlan->plpParent));
adl.c:			plpLinearPlan->apbtWorld=apbtNewWorld;
adl.c:				po=pcFormula->pfForm->pcArgs->pfForm->uValue.poOperator;
adl.c:				pcLabel=CopyFormula(po->pcName);	/* this is rather inefficient! */
adl.c:				if(po->pcName->pfForm->pcArgs)
adl.c:					pcLabel->pfForm->pcArgs=ComputeTerms(po->pcName->pfForm->pcArgs,plpLinearPlan,pbBindings);
adl.c:					if(!pcLabel->pfForm->pcArgs)
adl.c:						TermError("eval-modify-world",pcFormula,pbBindings);
adl.c:				plpLinearPlan->pcActionName=pcLabel;
adl.c:			pcMod=pcFormula->pfForm->pcArgs->pcNext;
adl.c:				(*pcMod->pfForm->paAction->pfEval)(pcMod,plpLinearPlan->plpParent,pbBindings);
adl.c:		po=pcFormula->pfForm->pcArgs->pfForm->uValue.poOperator;
adl.c:		FormulaToDouble(po->pcDuration,plpLinearPlan,pbBindings,&dfDuration);
adl.c:		FormulaToDouble(po->pcCost,plpLinearPlan,pbBindings,&dfCost);
adl.c:		FormulaToDouble(po->pcPriority,plpLinearPlan,pbBindings,&dfPriority);
adl.c:			plpSuccessorWorld->dfTime=plpLinearPlan->dfTime;
adl.c:		plpSuccessorWorld->pcPromise=pcFormula;	// save our modify formula
adl.c:		plpSuccessorWorld->nSignature=(unsigned int)CopyBindingsShared((BINDINGP)(
adl.c:			(plpLastSuccessor==(LINEARPLANP)&plpSuccessors)?NULL:plpLastSuccessor->nSignature),pbBindings);
adl.c:		plpLastSuccessor=plpLastSuccessor->plpNext=plpSuccessorWorld;
adl.c:		plpLastSuccessor->plpNext=NULL;
adl.c:			pcLabel=CopyFormula(po->pcName);	/* this is rather inefficient! */
adl.c:			if(po->pcName->pfForm->pcArgs)
adl.c:				pcLabel->pfForm->pcArgs=ComputeTerms(po->pcName->pfForm->pcArgs,plpLinearPlan,pbBindings);
adl.c:				if(!pcLabel->pfForm->pcArgs)
adl.c:					TermError("eval-modify-world",pcFormula,pbBindings);
adl.c:			plpSuccessorWorld->pcActionName=pcLabel;
adl.c:	po=pcFormula->pfForm->pcArgs->pfForm->uValue.poOperator;
adl.c:	pcLabel=CopyFormula(po->pcName);	/* this is rather inefficient! */
adl.c:	if(po->pcName->pfForm->pcArgs)
adl.c:		pcLabel->pfForm->pcArgs=ComputeTerms(po->pcName->pfForm->pcArgs,plpLinearPlan,pbBindings);
adl.c:		if(!pcLabel->pfForm->pcArgs)
adl.c:			TermError("eval-modify-world",pcFormula,pbBindings);
adl.c:	FormulaToDouble(po->pcDuration,plpLinearPlan,pbBindings,&dfDuration);
adl.c:	FormulaToDouble(po->pcCost,plpLinearPlan,pbBindings,&dfCost);
adl.c:	FormulaToDouble(po->pcPriority,plpLinearPlan,pbBindings,&dfPriority);
adl.c:		plpSuccessorWorld->dfTime=plpLinearPlan->dfTime;
adl.c:	pcMod=pcFormula->pfForm->pcArgs->pcNext;
adl.c:		(*pcMod->pfForm->paAction->pfEval)(pcMod,plpLinearPlan,pbBindings);
adl.c:	// special handling for depth-first-no-backtracking search
adl.c:		plpSuccessorWorld->plpParent=plpLinearPlan;	// need this for cycle checking
adl.c:			pcProgressedTLForm=(*pcTLForm->pfForm->paAction->pfProgress)
adl.c:		plpSuccessorWorld->pcTLForm=pcProgressedTLForm;
adl.c:		plpLastSuccessor=plpLastSuccessor->plpNext=plpSuccessorWorld;
adl.c:		plpLastSuccessor->plpNext=NULL;
adl.c:	plpLastSuccessor=plpLastSuccessor->plpNext=plpSuccessorWorld;
adl.c:	plpLastSuccessor->plpNext=NULL;
adl.c:	Evaluate a modify-world for side effects during formula progression.
adl.c:	Evaluate a modify-world for side effects during formula Currention.
adl.c:(define (generate-successors world/action)
adl.c:		(append! (apply-operator op world/action) successors))))
adl.c:		for(po=poOperators;po;po=po->poNext)
adl.c://dfSuccessorTime-=GetInternalRunTime();
adl.c:			(*po->pcSuccessor->pfForm->paAction->pfEval)(po->pcSuccessor,plpStart,pbBindings);
adl.c:		for(po=poOperators;po;po=po->poNext)
adl.c:			(*po->pcSuccessor->pfForm->paAction->pfEval)(po->pcSuccessor,plpStart,pbBindings);
adl.c://			plpLast->plpNext=plpSuccessors;
adl.c://			while(plpLast->plpNext)		// advance pointer to end of list
adl.c://				plpLast=plpLast->plpNext;
adl.c:				plpLast->plpNext=plpSuccessors;
adl.c://	(*po->pcSuccessor->pfForm->paAction->pfEval)(po->pcSuccessor,plpLinearPlan,pbBindings);
adl.c:/* Formula compile routines ---------------------------------------------------- */
adl.c:	variable/generator pairs (var-gens) into a nested forall formula,
adl.c:	where each forall has exactly one var-gen.
adl.c:(define (adl-compile-lambda var-gens formula final-form)
adl.c:		((and formula (or (and-formp formula) (atomic-formp formula)))
adl.c:			(adl-compile-and-lambda var-gens formula final-form))
adl.c:			(adl-compile-others-lambda var-gens formula final-form))))
adl.c:(define (adl-compile-others-lambda var-gens formula final-form)
adl.c:   ((and (null? var-gens) (null? formula))
adl.c:	final-form)
adl.c:   ((null? var-gens)
adl.c:	(list 'IMPLIES formula final-form))
adl.c:	`(FORALL ,(adl-get-vars (first var-gens))
adl.c:			 ,(adl-get-gen (first var-gens))
adl.c:			 ,(adl-compile-others-lambda
adl.c:			   (rest var-gens) formula final-form)))))
adl.c:	return MakeForAllForm(FALSE,pcVarGens->pfForm->pcVars,pcVarGens->pfForm->pcGenLit,
adl.c:		CompileOtherFormula(pcVarGens->pcNext,pcAntecedent,pcConsequent));
adl.c:(define (adl-compile-and-lambda var-gens formula final-form)
adl.c:			(recursive-form '())
adl.c:			(var-gen-forms '()))
adl.c:			(if (and-formp formula)
adl.c:				(get-args formula)
adl.c:		(set! var-gen-forms
adl.c:					(lambda (var-gen) (list var-gen '()))
adl.c:					var-gens)))
adl.c:		(for-each
adl.c:				(let ((vars (find-free-vars conj))
adl.c:							(call-with-current-continuation
adl.c:									(for-each
adl.c:										(lambda (var-gen-form)
adl.c:															(adl-get-vars (first var-gen-form)))))
adl.c:													(set-car! (rest var-gen-form)
adl.c:														(cons conj (cadr var-gen-form)))
adl.c:										var-gen-forms)))
adl.c:		(set! var-gen-forms (reverse var-gen-forms))
adl.c:		(for-each (lambda (var-gen-form)
adl.c:				(set-car! (rest var-gen-form)
adl.c:					(reverse (second var-gen-form))))
adl.c:			var-gen-forms)
adl.c:		(set! recursive-form (adl-compile-and-recurse var-gen-forms final-form))
adl.c:			((and sentences recursive-form (length=1 sentences))
adl.c:				`(IMPLIES ,@sentences ,recursive-form))
adl.c:			((and sentences recursive-form)
adl.c:				`(IMPLIES (AND ,@sentences) ,recursive-form))
adl.c:				recursive-form))))
adl.c:		pcConjuncts=pcAntecedent->pfForm->pcArgs;
adl.c:	for(pc1=pcVarGens;pc1;pc1=pc1->pcNext)
adl.c:		pc=MakeForAllForm(FALSE,pc1->pfForm->pcVars,pc1->pfForm->pcGenLit,NULL);
adl.c:		pc->pcNext=pcForAllForms;
adl.c:		pcConj2=pcConj1->pcNext;
adl.c:		pcConj1->pcNext=NULL;
adl.c:			pcConj1->pcNext=pcSentences;
adl.c:			for(pc=pcForAllForms;pc;pc=pc->pcNext)
adl.c:				if(FormulaIntersects(pcVars,pc->pfForm->pcVars))
adl.c:					pcConj1->pcNext=pc->pfForm->pcArgs;
adl.c:					pc->pfForm->pcArgs=pcConj1;
adl.c:				pcConj1->pcNext=pcSentences;
adl.c:	for(pc=pcForAllForms;pc;pc=pc->pcNext)
adl.c:		pc->pfForm->pcArgs=ReverseFormulaList(pc->pfForm->pcArgs);
adl.c:		if(pc->pcNext)
adl.c:(define (adl-compile-and-recurse var-gen-forms final-form)
adl.c:  (let ((var-gen-form (first var-gen-forms)))
adl.c:	 ((null? var-gen-form)
adl.c:	  final-form)
adl.c:	 ((null? (second var-gen-form))     ;No formula, just generator.
adl.c:	  `(FORALL ,(adl-get-vars (first var-gen-form))
adl.c:			   ,(adl-get-gen (first var-gen-form))
adl.c:			   ,(adl-compile-and-recurse (rest var-gen-forms) final-form)))
adl.c:	  `(FORALL ,(adl-get-vars (first var-gen-form))
adl.c:			   ,(adl-get-gen (first var-gen-form))
adl.c:				,(if (length=1 (second var-gen-form))
adl.c:					 (first (second var-gen-form))
adl.c:				   (cons 'AND (second var-gen-form)))
adl.c:				,(adl-compile-and-recurse
adl.c:				  (rest var-gen-forms) final-form)))))))
adl.c:		pc=CompileAndRecurse(pcForAllForms->pcNext,pcConsequent);
adl.c:		if(!pcForAllForms->pfForm->pcArgs)		/* no formula, just generator */
adl.c:			pcForAllForms->pfForm->pcArgs=pc;
adl.c:			if(pcForAllForms->pfForm->pcArgs->pcNext)	/* if list of formulas, enclose with and */
adl.c:				pcForAllForms->pfForm->pcArgs=MakeAndForm(FALSE,pcForAllForms->pfForm->pcArgs);
adl.c:				pcForAllForms->pfForm->pcArgs=MakeImpliesForm(FALSE,pcForAllForms->pfForm->pcArgs,pc);
adl.c:		pcForAllForms->pcNext=NULL;
adl.c:(define (find-free-vars form . optional-args)
adl.c:	(let ((bound-vars '())
adl.c:			(free-vars '()))
adl.c:		(if (not (null? optional-args))
adl.c:			(begin (set! bound-vars (first optional-args))
adl.c:				(set! optional-args (rest optional-args))))
adl.c:		(if (not (null? optional-args))
adl.c:			(begin (set! free-vars (first optional-args))
adl.c:				(set! optional-args (rest optional-args))))
adl.c:			((or (call-formp form) (null? form))
adl.c:				free-vars)
adl.c:			((or (forall-formp form) (exists-formp form))
adl.c:						(if (not (memq var bound-vars))
adl.c:							(set! bound-vars (cons var bound-vars))))
adl.c:					(get-qf-variables (get-args form)))
adl.c:						(if (not (memq var free-vars))
adl.c:							(set! free-vars (cons var free-vars))))
adl.c:					(set-difference (variables-in (get-qf-generator (get-args form)))
adl.c:						bound-vars))
adl.c:				(find-free-vars (get-qf-formula (get-args form))
adl.c:					bound-vars free-vars))
adl.c:			((binding-formp form)
adl.c:						(if (not (memq var bound-vars))
adl.c:							(set! bound-vars (cons var bound-vars))))
adl.c:					(get-binding-vars form))
adl.c:				(find-free-vars (get-binding-formula form)
adl.c:					bound-vars free-vars))
adl.c:			((atomic-formp form)
adl.c:						(if (not (memq var free-vars))
adl.c:							(set! free-vars (cons var free-vars))))
adl.c:					(set-difference (variables-in form) bound-vars))
adl.c:				free-vars)
adl.c:				(do ((args (get-args form))
adl.c:						(current-free-vars free-vars)
adl.c:						((null? args) free-vars)
adl.c:						(for-each (lambda (var)
adl.c:								(if (not (memq var free-vars))
adl.c:									(set! free-vars (cons var free-vars))))
adl.c:							(find-free-vars arg bound-vars current-free-vars)))))))
adl.c:		for(pcVar1=pcFormula->pfForm->pcVars;pcVar1;pcVar1=pcVar1->pcNext)
adl.c:				pcVar2->pcNext=pcBoundVars;
adl.c:		for(pcVar1=FormulaDifference(VariablesIn(pcFormula->pfForm->pcGenLit),pcBoundVars);
adl.c:/*		for(pcVar1=FindFreeVars(pcFormula->pcGenLit,pcBoundVars,pcFreeVars);
adl.c:			pcVar2=pcVar1->pcNext;
adl.c:			pcVar1->pcNext=NULL;
adl.c:				pcVar1->pcNext=pcFreeVars;
adl.c:		pc=FindFreeVars(pcFormula->pfForm->pcArgs,pcBoundVars,pcFreeVars);
adl.c:		for(pcVar1=GetBindingVars(pcFormula);pcVar1;pcVar1=pcVar1->pcNext)
adl.c:				pcVar2->pcNext=pcBoundVars;
adl.c:			pcVar2=pcVar1->pcNext;
adl.c:			pcVar1->pcNext=NULL;
adl.c:				pcVar1->pcNext=pcFreeVars;
adl.c:		for(pcArg=pcFormula->pfForm->pcArgs;pcArg;pcArg=pcArg->pcNext)
adl.c:				pcVar2=pcVar1->pcNext;
adl.c:					pcVar1->pcNext=pcFreeVars;
adl.c:	for(po=poOperators;po;po=po->poNext)
adl.c:	    (*po->pcSuccessor->pfForm->paAction->pfEval)(po->pcSuccessor,temporalPlan,pbBindings);
adl.c://			plpLast->plpNext=plpSuccessors;
adl.c://			while(plpLast->plpNext)		// advance pointer to end of list
adl.c://				plpLast=plpLast->plpNext;
adl.c://del				plpLast->plpNext=plpSuccessors;
bfs.c:	pnNext=pnQueue-1;
bfs.c:			if(nVertex==nVertices-1)	// if new vertex
bfs.c:	memmove(pnVertexIndices+left+1,pnVertexIndices+left,(*pnCount-left)*sizeof(int));
btree.c:Copyright C, 1996 - 2002, F. Bacchus
btree.c:(define (make-b-tree key value left right owner)
btree.c:  (vector 'b-tree key value left right owner))
btree.c:	pbt->pcKey=CopyFormulaList(pcKey);
btree.c:	pbt->pcValue=pcValue;
btree.c:	pbt->pbtLeft=pbtLeft;
btree.c:	pbt->pbtRight=pbtRight;
btree.c:	pbt->apbtOwner=apbtOwner;
btree.c:(define copy-b-tree vector-copy)
btree.c:(define (args< arg-list1 arg-list2)
btree.c:  (let ((x1 (convert-to-string (first arg-list1)))
btree.c:	(x2 (convert-to-string (first arg-list2))))
btree.c:	 ((string=? x1 x2) (args< (rest arg-list1) (rest arg-list2)))
btree.c:		pc1=pc1->pcNext,pc2=pc2->pcNext
btree.c:		ps1=IdentName(pc1->pfForm);
btree.c:		ps2=IdentName(pc2->pfForm);
btree.c:	Return -1 if argList1 should sort prior to argList2.
btree.c:		pc1=pc1->pcNext,pc2=pc2->pcNext
btree.c:		ps1=IdentName(pc1->pfForm);
btree.c:		ps2=IdentName(pc2->pfForm);
btree.c:				return -1;
btree.c:	Return -1 if argList1 should sort prior to argList2 ignoring
btree.c:		pc1=pc1->pcNext,pc2=pc2->pcNext
btree.c:		ps1=IdentName(pc1->pfForm);
btree.c:		ps2=IdentName(pc2->pfForm);
btree.c:				return -1;
btree.c:(define (set-tree-default< fn)
btree.c:(define (set-tree-default= fn)
btree.c:/* c) BTree utilities ------------------------------------------------------- */
btree.c:(define (tree-search item tree)
btree.c:  (let ((key (if (b-tree? item) (b-tree-key item) item)))
btree.c:	(letrec ((b-search
btree.c:			(*key=* key (b-tree-key tree)))
btree.c:			(if (*key<* key (b-tree-key tree))
btree.c:			(b-search (b-tree-left tree))
btree.c:			(b-search (b-tree-right tree)))))))
btree.c:	  (b-search tree))))
btree.c:		switch(ArgsCmpQ(pcKey,pbt->pcKey))
btree.c:			case -1:
btree.c:				pbt=pbt->pbtLeft;
btree.c:				pbt=pbt->pbtRight;
btree.c://		if((*pfKeyLtQ)(pcKey,pbt->pcKey))
btree.c://			pbt=pbt->pbtLeft;
btree.c://		else if((*pfKeyEqQ)(pcKey,pbt->pcKey))
btree.c://			pbt=pbt->pbtRight;
btree.c:(define (get-reversed-path key tree)
btree.c:	(letrec ((get-path
btree.c:			   (if (*key=* key (b-tree-key tree))
btree.c:			   (if (*key<* key (b-tree-key tree))
btree.c:				   (get-path (b-tree-left tree))
btree.c:				   (get-path (b-tree-right tree)))))))))
btree.c:	  (get-path tree))))
btree.c:		pl->plNext=plAccumulator;
btree.c:		if((*pfKeyEqQ)(pcKey,pbt->pcKey))
btree.c:		if((*pfKeyLtQ)(pcKey,pbt->pcKey))
btree.c:			pbt=pbt->pbtLeft;
btree.c:			pbt=pbt->pbtRight;
btree.c:		pbt->pbtNext=pbtPrev;
btree.c:		if((*pfKeyEqQ)(pcKey,pbt->pcKey))
btree.c:		if((*pfKeyLtQ)(pcKey,pbt->pcKey))
btree.c:			pbt=pbt->pbtLeft;
btree.c:			pbt=pbt->pbtRight;
btree.c:(define (tree-min tree)
btree.c:  (if (null? (b-tree-left tree))
btree.c:	  (tree-min (b-tree-left tree))))
btree.c:	for(pbt=pbtTree;pbt->pbtLeft;pbt=pbt->pbtLeft);
btree.c:(define (tree-max tree)
btree.c:  (if (null? (b-tree-right tree))
btree.c:	  (tree-max (b-tree-right tree))))
btree.c://	for(pbt=pbtTree;pbt->pbtRight;pbt=pbt->pbtRight);
btree.c:	for(pbt=pbtTree;pbt;pbt=pbt->pbtLeft)
btree.c:		if(pbt->pbtRight)
btree.c:			nCount+=BTreeCount(pbt->pbtRight,0);	/* count the right subtree */
btree.c:	for(pbt=pbtTree;pbt;pbt=pbt->pbtLeft)
btree.c:		if(pbt->pbtRight)
btree.c:			ppbt=BTreeEnumerate(pbt->pbtRight,ppbt);	/* store pointers to right subtree */
btree.c:(define (tree-successor item tree)
btree.c:  (let* ((key (if (b-tree? item) (b-tree-key item) item))
btree.c:		 (rev-path-to-item (get-reversed-path key tree))
btree.c:		 (item-node (first rev-path-to-item))) ;This should be the item.
btree.c:	 ((not (*key=* key (b-tree-key item-node))) ;Item not in tree!
btree.c:	 ((not (null? (b-tree-right item-node)))
btree.c:	  (tree-min (b-tree-right item-node)))
btree.c:	 (else (do ((parents (rest rev-path-to-item))
btree.c:		 (if (and parent (eq? item-node (b-tree-right parent)))
btree.c:		 (set! item-node parent)
btree.c:	if(!(*pfKeyEqQ)(pcKey,((BTREEP)plRevPathToItem->uValue.pbtTree)->pcKey))
btree.c:	pbt=pl->uValue.pbtTree;
btree.c:	if(pbt->pbtRight)					/* if right tree exists */
btree.c:		pbt=BTreeMin(pbt->pbtRight);
btree.c:	pl=pl->plNext;						/* point to parent node */
btree.c:	pbtParent=pl->uValue.pbtTree;
btree.c:	while(pbt==pbtParent->pbtRight)
btree.c:		pl=pl->plNext;					/* point to parent node */
btree.c:		pbtParent=pl->uValue.pbtTree;
btree.c://	if(!(*pfKeyEqQ)(pcKey,pbtRevPathToItem->pcKey))	// is this test needed?
btree.c://	if(pbt->pbtRight)					/* if right tree exists */
btree.c://		pbt=BTreeMin(pbt->pbtRight);
btree.c://	pbtParent=pbt->pbtNext;				/* point to parent node */
btree.c://	while(pbt==pbtParent->pbtRight)
btree.c://		pbtParent=pbt->pbtNext;			/* point to parent node */
btree.c:/*	BTreeInsert and BTreeDelete ------------------------------------------------
btree.c:(define (tree-insert owner node tree)
btree.c:  (let* ((new-key (b-tree-key node)))
btree.c:	(set-b-tree-right! node '())  ;Ensure only single node is
btree.c:	(set-b-tree-left! node '())  ;inserted.
btree.c:		 ((*key<* new-key (b-tree-key tree))
btree.c:		  (let ((new-tree
btree.c:			 (if (eq? (b-tree-owner tree) owner)
btree.c:			     (copy-b-tree tree))))
btree.c:			(set-b-tree-left! new-tree
btree.c:					  (insert (b-tree-left tree)))
btree.c:			(set-b-tree-owner! new-tree owner)
btree.c:		    new-tree))
btree.c:		  (let ((new-tree
btree.c:			 (if (eq? (b-tree-owner tree) owner) 
btree.c:			     (copy-b-tree tree))))
btree.c:		    (set-b-tree-right! new-tree
btree.c:				       (insert (b-tree-right tree)))
btree.c:		    (set-b-tree-owner! new-tree owner)
btree.c:		    new-tree))))))
btree.c:	pbtNode->pbtRight=NULL;				/* Ensure only single node is inserted */
btree.c:	pbtNode->pbtLeft=NULL;
btree.c:	pcNewKey=pbtNode->pcKey;
btree.c:	if((*pfKeyLtQ)(pcNewKey,pbtTree->pcKey))	/* put into correct side. */
btree.c:		pbtNewTree=(pbtTree->apbtOwner==apbtOwner)?pbtTree:CopyBTree(pbtTree);
btree.c:		pbtNewTree->pbtLeft=Insert(apbtOwner,pbtNode,pbtTree->pbtLeft);
btree.c:		pbtNewTree->apbtOwner=apbtOwner;
btree.c:		pbtNewTree=(pbtTree->apbtOwner==apbtOwner)?pbtTree:CopyBTree(pbtTree);
btree.c:		pbtNewTree->pbtRight=Insert(apbtOwner,pbtNode,pbtTree->pbtRight);
btree.c:		pbtNewTree->apbtOwner=apbtOwner;
btree.c:(define (tree-delete owner key tree)
btree.c:  (letrec ((b-delete
btree.c:		   ((*key=* key (b-tree-key tree))
btree.c:		 ((and (b-tree-right tree) (b-tree-left tree))
btree.c:		  (let* ((successor-node (tree-successor key tree))
btree.c:			 (new-tree
btree.c:			  (if (eq? (b-tree-owner successor-node) owner)
btree.c:				  successor-node
btree.c:				  (copy-b-tree successor-node))))
btree.c:			(set-b-tree-right! new-tree
btree.c:					   (b-delete (b-tree-key successor-node)
btree.c:						 (b-tree-right tree)))
btree.c:			(set-b-tree-owner! new-tree owner)
btree.c:			(set-b-tree-left! new-tree (b-tree-left tree))
btree.c:			new-tree))
btree.c:		 ((not (null? (b-tree-right tree))) (b-tree-right tree))		 ;has only right child, return it.
btree.c:		 ((not (null? (b-tree-left tree))) (b-tree-left tree))		 ;has only left child return it.
btree.c:		   ((*key<* key (b-tree-key tree))
btree.c:		(let ((new-tree
btree.c:			   (if (eq? (b-tree-owner tree) owner)
btree.c:			   (copy-b-tree tree))))
btree.c:		  (set-b-tree-left! new-tree
btree.c:					(b-delete key (b-tree-left tree)))
btree.c:		  (set-b-tree-owner! new-tree owner)
btree.c:		  (set-b-tree-right! new-tree (b-tree-right tree))
btree.c:		  new-tree))
btree.c:		(let ((new-tree
btree.c:			   (if (eq? (b-tree-owner tree) owner)
btree.c:			   (copy-b-tree tree))))
btree.c:		  (set-b-tree-right! new-tree
btree.c:					 (b-delete key (b-tree-right tree)))
btree.c:		  (set-b-tree-owner! new-tree owner)
btree.c:		  (set-b-tree-left! new-tree (b-tree-left tree))
btree.c:		  new-tree))))))
btree.c:	(b-delete key tree)))
btree.c:	if((*pfKeyEqQ)(pcKey,pbtTree->pcKey))	/* Need to delete root. */
btree.c:		if(pbtTree->pbtRight&&pbtTree->pbtLeft)	/* Has two children */
btree.c:			pbtNewTree=(pbtSuccessorNode->apbtOwner==apbtOwner)?
btree.c:			pbtNewTree->pbtRight=BTreeDelete(apbtOwner,pbtSuccessorNode->pcKey,
btree.c:				pbtTree->pbtRight);
btree.c:			pbtNewTree->apbtOwner=apbtOwner;
btree.c:			pbtNewTree->pbtLeft=pbtTree->pbtLeft;
btree.c:		else if(pbtTree->pbtRight)		/* has only right child, return it. */
btree.c:			pbt=pbtTree->pbtRight;
btree.c:		else if(pbtTree->pbtLeft)		/* has only left child return it. */
btree.c:			pbt=pbtTree->pbtLeft;
btree.c:	else if((*pfKeyLtQ)(pcKey,pbtTree->pcKey))
btree.c:		pbtNewTree=(pbtTree->apbtOwner==apbtOwner)?
btree.c:		pbtNewTree->pbtLeft=BTreeDelete(apbtOwner,pcKey,pbtTree->pbtLeft);
btree.c:		pbtNewTree->apbtOwner=apbtOwner;
btree.c:		pbtNewTree->pbtRight=pbtTree->pbtRight;
btree.c:		pbtNewTree=(pbtTree->apbtOwner==apbtOwner)?
btree.c:		pbtNewTree->pbtRight=BTreeDelete(apbtOwner,pcKey,pbtTree->pbtRight);
btree.c:		pbtNewTree->apbtOwner=apbtOwner;
btree.c:		pbtNewTree->pbtLeft=pbtTree->pbtLeft;
btree.c:	  ((tree-check
btree.c:	   ((and (*key=* (b-tree-key t1) (b-tree-key t2))
btree.c:		 (eqv? (b-tree-value t1) (b-tree-value t2))
btree.c:		 (tree-check (tree-successor t1 tree1)
btree.c:				 (tree-successor t2 tree2))))
btree.c:	 (else (tree-check (tree-min tree1) (tree-min tree2))))))
btree.c:	else if((*pfKeyEqQ)(pbt1->pcKey,pbt2->pcKey)&&
btree.c:		FormulaListEqQ(pbt1->pcValue,pbt2->pcValue)&&
btree.c:		BTreeCheck(BTreeSuccessor(pbt1->pcKey,pbtTree1),
btree.c:			BTreeSuccessor(pbt2->pcKey,pbtTree2),pbtTree1,pbtTree2))
btree.c:/* Other useful functions ------------------------------------------------------
btree.c::key	--- apply to node prior for testing.
btree.c::test	--- only add to list if passes test (after applying key!)
btree.c:/* BTreeToList -----------------------------------------------------------------
btree.c:(define (tree-to-list tree . keyword-args)
btree.c:			((null? keyword-args))
btree.c:			(case (first keyword-args)
btree.c:					(set! test (cadr keyword-args)))
btree.c:					(set! key (cadr keyword-args)))
btree.c:					(set! transform (cadr keyword-args)))
btree.c:					(error "Illegal keyword: ~A" (first keyword-args))))
btree.c:			(set! keyword-args (cddr keyword-args)))
btree.c:			((tree-walk
btree.c:								(tree-walk (b-tree-right tree))
btree.c:								(tree-walk (b-tree-left tree)))))))
btree.c:			(tree-walk tree)
btree.c:	plAccumulator=BTreeWalk(plAccumulator,pbtTree->pbtRight,
btree.c:	pl=BTreeWalk(plAccumulator,pbtTree->pbtLeft,
btree.c:/* BTreeToFormulaList ----------------------------------------------------------
btree.c:	pcAccumulator=NewBTreeWalk(pcAccumulator,pbtTree->pbtRight,
btree.c:		pc->pcNext=pcAccumulator;
btree.c:	pc=NewBTreeWalk(pcAccumulator,pbtTree->pbtLeft,
btree.c:/* BTreeGenerator --------------------------------------------------------------
btree.c:(define (make-tree-generator tree transform)
btree.c:  (let ((current-node '())
btree.c:	(next-node (tree-min tree)))
btree.c:	   (next-node
btree.c:	(set! current-node next-node)
btree.c:	(set! next-node (tree-successor current-node tree))
btree.c:		(transform current-node)
btree.c:		(b-tree-key current-node)))
btree.c:	The tree is traversed "in-order".
btree.c:		for(pbt=pbtTree;pbt;pbt=pbt->pbtLeft)
btree.c:	for(pbt=pbtCurrent->pbtRight;pbt;pbt=pbt->pbtLeft)
btree.c:	return pbtCurrent->pcKey;
btree.c:	The tree is traversed "in-order".
btree.c:	This version uses the old tree-min and tree-successor algorithm.
btree.c://		pbBindings->pvContext=(void *)pbtcContext;
btree.c://		pbtcContext->pbtRoot=pbtTree;
btree.c://		pbtcContext->pbtNext=BTreeMin(pbtTree);
btree.c://	pbtCurrent=pbtcContext->pbtNext;
btree.c://	pbtcContext->pbtNext=BTreeSuccessorX(pbtCurrent->pcKey,pbtcContext->pbtRoot);
btree.c://	return pbtCurrent->pcKey;
btree.c:	The tree is traversed "in-order".
btree.c:	It is non-reentrant, but fast.
btree.c://		for(pbt=pbtTree;pbt;pbt=pbt->pbtLeft)
btree.c://			pbt->pbtNext=pbtContext;
btree.c://	pbtContext=pbtContext->pbtNext;		/* assume no right child */
btree.c://	if(pbtCurrent->pbtRight)
btree.c://		pbt=pbtCurrent->pbtRight;
btree.c://		pbt->pbtNext=pbtContext;
btree.c://		for(pbt=pbt->pbtLeft;pbt;pbt=pbt->pbtLeft)
btree.c://			pbt->pbtNext=pbtContext;
btree.c://	return pbtCurrent->pcKey;
btree.c:	The tree is traversed "in-order".
btree.c://		pbBindings->pvContext=(void *)pbtcContext;
btree.c://		pbtcNode->pbtcNext=NULL;
btree.c://		pbtcContext->pbtcNext=pbtcNode;
btree.c://		pbtcNode->pbtTree=pbtTree;
btree.c://		for(pbt=pbtTree;pbt->pbtLeft;pbt=pbt->pbtLeft)
btree.c://			pbtcNode->pbtcNext=pbtcContext->pbtcNext;
btree.c://			pbtcContext->pbtcNext=pbtcNode;
btree.c://			pbtcNode->pbtTree=pbt->pbtLeft;
btree.c://	pbtc=pbtcContext->pbtcNext;
btree.c://	pbtCurrent=pbtc->pbtTree;			/* pop */
btree.c://	pbtcContext->pbtcNext=pbtc->pbtcNext;
btree.c://	if(pbtCurrent->pbtRight)
btree.c://		pbtcNode->pbtcNext=pbtcContext->pbtcNext;
btree.c://		pbtcContext->pbtcNext=pbtcNode;
btree.c://		pbtcNode->pbtTree=pbtCurrent->pbtRight;
btree.c://		for(pbt=pbtCurrent->pbtRight;pbt->pbtLeft;pbt=pbt->pbtLeft)
btree.c://			pbtcNode->pbtcNext=pbtcContext->pbtcNext;
btree.c://			pbtcContext->pbtcNext=pbtcNode;
btree.c://			pbtcNode->pbtTree=pbt->pbtLeft;
btree.c://	return pbtCurrent->pcKey;
btree.c:			switch(ArgsCmpQWithVars(pcArgs,pbt->pcKey))
btree.c:				case -1: 
btree.c:					pbt=pbt->pbtLeft;
btree.c:					pbt=pbt->pbtRight;
btree.c:		all nodes with non-zero argscomqwithvars don't exist.
btree.c:			switch(ArgsCmpQWithVars(pcArgs,pbt->pcKey)) 
btree.c:					pbt=pbt->pbtLeft;
btree.c:				case -1:				// node is greater than any possible match. Move left
btree.c:					pbt=pbt->pbtRight;
btree.c:		to the node (i.e., a path with the non-matching nodes delted
btree.c:	---we need never explore the right subtrees of non-matching nodes
btree.c:	as all non-matching nodes must be greater than (and thus all nodes
btree.c:	pbt=pbtCurrent->pbtRight;
btree.c:		if(ArgsCmpQWithVars(pcArgs,pbt->pcKey)==0) 
btree.c:			for(pbt=pbt->pbtLeft;pbt;pbt=pbt->pbtLeft)
btree.c:			for(pbt=pbt->pbtLeft;pbt;pbt=pbt->pbtLeft) 
btree.c:				if(ArgsCmpQWithVars(pcArgs,pbt->pcKey)==0)
btree.c:	return pbtCurrent->pcKey;
btree.c://	  switch(ArgsCmpQWithVars(pcArgs,pbt->pcKey))
btree.c://	    case -1: 
btree.c://	      pbt=pbt->pbtLeft;
btree.c://	      pbt=pbt->pbtRight;
btree.c://	 all nodes with non-zero argscomqwithvars don't exist.
btree.c://	switch(ArgsCmpQWithVars(pcArgs,pbt->pcKey)) 
btree.c://	    pbt=pbt->pbtLeft;
btree.c://	  case -1: //node is greater than any possible match. Move left
btree.c://	    pbt=pbt->pbtRight;
btree.c://	to the node (i.e., a path with the non-matching nodes delted
btree.c://      *ppvContext=(void *)walkstack[--topws];
btree.c://     ---we need never explore the right subtrees of non-matching nodes
btree.c://     as all non-matching nodes must be greater than (and thus all nodes
btree.c://  if(pbt=pbtCurrent->pbtRight)
btree.c://      if(ArgsCmpQWithVars(pcArgs,pbt->pcKey)==0) {
btree.c://	for(pbt=pbt->pbtLeft;pbt;pbt=pbt->pbtLeft) {
btree.c://	for(pbt=pbt->pbtLeft;pbt;pbt=pbt->pbtLeft) 
btree.c://	  if(ArgsCmpQWithVars(pcArgs,pbt->pcKey)==0) {
btree.c://  *ppvContext=(void *)walkstack[--topws];
btree.c://  return pbtCurrent->pcKey;
btree.c:	for(pbt=pbtTree;pbt;pbt=pbt->pbtRight)
btree.c:		MarkFormulaList(pbt->pcKey);
btree.c:		if(pbt->pcValue)
btree.c:			MarkFormula(pbt->pcValue);
btree.c:		MarkBTree(pbt->pbtLeft);
btree.c:	for(pbt=pbtTree;pbt;pbt=pbt->pbtRight)
btree.c:		FormulaListSizeOf(pbt->pcKey,pnSize);
btree.c:		MarkFormulaList(pbt->pcKey);
btree.c:		if(pbt->pcValue)
btree.c:			FormulaSizeOf(pbt->pcValue,pnSize);
btree.c:			MarkFormula(pbt->pcValue);
btree.c:		BTreeSizeOf(pbt->pbtLeft,pnSize);
btree.c://	for(pbt=pbtTree;pbt;pbt=pbt->pbtRight)
btree.c://		BTreeBalancedQ(pbt->pbtLeft,pnCount,pnDepth);
btree.c:	return BTreeBuild(ppbtNodes,0,n-1);
btree.c:	This is an in-order walk.
btree.c:		FillNodeArray(pppbt,pbt->pbtLeft);
btree.c:		FillNodeArray(pppbt,pbt->pbtRight);
btree.c:	pbtRoot->pbtLeft=BTreeBuild(ppbtNodes,i,nMid-1);
btree.c:	pbtRoot->pbtRight=BTreeBuild(ppbtNodes,nMid+1,j);
btree.c:	nLeft=BTreeDepth(pbtTree->pbtLeft);
btree.c:	nRight=BTreeDepth(pbtTree->pbtRight);
btree.c://	for(pbt=pbtTree;pbt;pbt=pbt->pbtRight)
btree.c://		ZoneCopyFormulaList(pbt->pcKey);
btree.c://		if(pbt->pcValue)
btree.c://			ZoneCopyFormula(pbt->pcValue);
btree.c://		ZoneCopyBTree(pbt->pbtLeft);
btree.c://	for(pbt=pbtTree;pbt;pbt=pbt->pbtRight)
btree.c://		ZoneReloc(&pbt->pcKey);
btree.c://		ZoneRelocFormulaList(pbt->pcKey);
btree.c://		if(pbt->pcValue)
btree.c://			ZoneReloc(&pbt->pcValue);
btree.c://			ZoneRelocFormula(pbt->pcValue);
btree.c://		ZoneReloc(&pbt->pbtLeft);
btree.c://		ZoneRelocBTree(pbt->pbtLeft);
btree.c://		ZoneReloc(&pbt->pbtRight);
btree.c:// BTree Stack Support ---------------------------------------------------------
btree.c:	nBTreeMaxSP=MIN_BTREE_STACK-1;
btree.c:	nBTreeMaxSP=2*nBTreeMaxSP-1;
btree.c://	for(i=nBTreeSP-1;i>=1;i--)
btree.c://			fprintf(stderr,"%s, ",ppbtStack[i]->pcKey->pfForm->psName);
btree.c:	nBaseSP=(int)(pbcContext->pvContext);
btree.c:		fprintf(stderr,"\nStack Pointer non-positive... is %d should be %d\n",
btree.c:		fprintf(stderr,"\nBase Pointer points to non-zero value... pointer is %d value is %d\n",
btree.c:	nBTreeSP=(int)(pbcContext->pvContext);
cc.c:// cc.c -- Current Condition Algorithm
cc.c:// Booleans ---------------------------------------------------------------------
cc.c://	(define (cc-not form)
cc.c://				(cc-subforms (map cc (get-args form)))
cc.c://				(tsubforms (remove-nulls (map get-tform cc-subforms)))
cc.c://				(fsubforms (remove-nulls (map get-fform cc-subforms)))
cc.c://				((equal-list? tsubforms (get-args form))
cc.c://							(ccarg (first cc-subforms)))
cc.c://						(if (not (null? (get-fform ccarg)))
cc.c://							(set! tform (make-not-form (get-fform ccarg))))
cc.c://						(if (not (null? (get-tform ccarg)))
cc.c://							(set! fform (make-not-form (get-tform ccarg)))))))
cc.c://			(make-cc-return tform fform)))
cc.c:	pcArg=pcForm->pfForm->pcArgs;
cc.c:	pcSubForm=(*pcArg->pfForm->paAction->pfMakeCCForm)(!bType,pcArg,&bImmutable);
cc.c:			return pcSubForm->pfForm->pcArgs;
cc.c:		return MakeNotForm(pcSubForm->pcNext&&bImmutable,pcSubForm);
cc.c://	(define (cc-and form)
cc.c://			((cc-subforms (map cc (get-args form)))
cc.c://				(tsubforms (remove-nulls (map get-tform cc-subforms)))
cc.c://				(fsubforms (remove-nulls (map get-fform cc-subforms)))
cc.c://				((equal-list? tsubforms (get-args form))
cc.c://					(if (every (lambda (cc) (not (null? (get-tform cc)))) cc-subforms)
cc.c://						(set! tform (make-and-form tsubforms)))
cc.c://								(set! fform (make-and-form fsubforms)))
cc.c://			(make-cc-return tform fform)))
cc.c:	pcArgs=pcForm->pfForm->pcArgs;
cc.c:		for(pc=pcArgs;pc;pc=pc->pcNext)
cc.c:			pcSubForm=(*pc->pfForm->paAction->pfMakeCCForm)(TRUE,pc,&bImmutable);
cc.c:			pcEnd=pcEnd->pcNext=bImmutable?CopyCell(pcSubForm):pcSubForm;
cc.c:		pcEnd->pcNext=NULL;
cc.c:		for(pc=pcArgs;pc;pc=pc->pcNext)
cc.c:			pcSubForm=(*pc->pfForm->paAction->pfMakeCCForm)(FALSE,pc,&bImmutable);
cc.c:				pcEnd=pcEnd->pcNext=bImmutable?CopyCell(pcSubForm):pcSubForm;
cc.c:		pcEnd->pcNext=NULL;
cc.c:		if(pcSubForms->pcNext)
cc.c://	(define (cc-or form)
cc.c://			((cc-subforms (map cc (get-args form)))
cc.c://				(tsubforms (remove-nulls (map get-tform cc-subforms)))
cc.c://				(fsubforms (remove-nulls (map get-fform cc-subforms)))
cc.c://				((equal-list? tsubforms (get-args form))
cc.c://					(if (every (lambda (cc) (not (null? (get-fform cc)))) cc-subforms)
cc.c://						(set! fform (make-or-form fsubforms)))
cc.c://								(set! tform (make-or-form tsubforms)))
cc.c://			(make-cc-return tform fform)))
cc.c:	pcArgs=pcForm->pfForm->pcArgs;
cc.c:		for(pc=pcArgs;pc;pc=pc->pcNext)
cc.c:			pcSubForm=(*pc->pfForm->paAction->pfMakeCCForm)(TRUE,pc,&bImmutable);
cc.c:				pcEnd=pcEnd->pcNext=bImmutable?CopyCell(pcSubForm):pcSubForm;
cc.c:		pcEnd->pcNext=NULL;
cc.c:		for(pc=pcArgs;pc;pc=pc->pcNext)
cc.c:			pcSubForm=(*pc->pfForm->paAction->pfMakeCCForm)(FALSE,pc,&bImmutable);
cc.c:			pcEnd=pcEnd->pcNext=bImmutable?CopyCell(pcSubForm):pcSubForm;
cc.c:		pcEnd->pcNext=NULL;
cc.c:		if(pcSubForms->pcNext)
cc.c://	(define (cc-xor form)
cc.c://			((cc-subforms (map cc (get-args form)))
cc.c://				(tsubforms (remove-nulls (map get-tform cc-subforms)))
cc.c://				(fsubforms (remove-nulls (map get-fform cc-subforms)))
cc.c://				((equal-list? tsubforms (get-args form))
cc.c://					;;(and (xor tforms) (xor fforms))---one and only one *must* be
cc.c://					;;are one-sided, i.e., if one of the tforms==False it does not
cc.c://								(every (lambda (cc) (not (null? (get-tform cc)))) cc-subforms)
cc.c://								(every (lambda (cc) (not (null? (get-fform cc)))) cc-subforms))
cc.c://								(make-and-form
cc.c://									(list (make-xor-form tsubforms)
cc.c://										(make-xor-form fsubforms))))))
cc.c://							(more-than-one-has-tform (> 1 (count get-tform cc-subforms)))
cc.c://							(all-have-fforms 
cc.c://								(every (lambda (cc) (not (null? (get-fform cc)))) cc-subforms)))
cc.c://								(and more-than-one-has-tform all-have-fforms)
cc.c://									(make-and-form
cc.c://											(make-or-form
cc.c://												(make-xor-form tsubforms)
cc.c://												(make-not-form (make-or-form tsubforms)))
cc.c://											(make-or-form fsubforms)))))
cc.c://								more-than-one-has-tform
cc.c://									(make-or-form
cc.c://										(make-xor-form tsubforms)
cc.c://										(make-not-form (make-or-form tsubforms)))))
cc.c://								all-have-fforms
cc.c://								(set! fform (make-or-form fsubforms)))))))
cc.c://			(make-cc-return tform fform)))
cc.c:	pcArgs=pcForm->pfForm->pcArgs;
cc.c:		// (and (xor tforms) (xor fforms))---one and only one *must* be
cc.c:		// are one-sided, i.e., if one of the tforms==False it does not
cc.c:		for(pc=pcArgs;pc;pc=pc->pcNext)
cc.c:			pcTrueForm=(*pc->pfForm->paAction->pfMakeCCForm)(TRUE,pc,&bImmutable);
cc.c:			pcTrueEnd=pcTrueEnd->pcNext=bImmutable?CopyCell(pcTrueForm):pcTrueForm;
cc.c:			pcFalseForm=(*pc->pfForm->paAction->pfMakeCCForm)(FALSE,pc,&bImmutable);
cc.c:			pcFalseEnd=pcFalseEnd->pcNext=bImmutable?CopyCell(pcFalseForm):pcFalseForm;
cc.c:		pcTrueEnd->pcNext=NULL;
cc.c:		pcFalseEnd->pcNext=NULL;
cc.c:		if(pcTrueForms->pcNext)
cc.c:		if(pcFalseForms->pcNext)
cc.c:		pcTrueForms->pcNext=pcFalseForms;
cc.c:		for(pc=pcArgs;pc;pc=pc->pcNext)
cc.c:			pcTrueForm=(*pc->pfForm->paAction->pfMakeCCForm)(TRUE,pc,&bImmutable);
cc.c:				pcTrueEnd=pcTrueEnd->pcNext=bImmutable?CopyCell(pcTrueForm):pcTrueForm;
cc.c:			pcFalseForm=(*pc->pfForm->paAction->pfMakeCCForm)(FALSE,pc,&bImmutable);
cc.c:				pcFalseEnd=pcFalseEnd->pcNext=bImmutable?CopyCell(pcFalseForm):pcFalseForm;
cc.c:		pcTrueEnd->pcNext=NULL;
cc.c:		pcFalseEnd->pcNext=NULL;
cc.c:			if(pcTrueForms->pcNext)		// if more than one true form
cc.c:					pcTrueForms->pcNext=pcTrueForm;
cc.c:					pcTrueForms->pcNext=pcFalseForms;
cc.c:				pcTrueForms->pcNext=pcTrueForm;
cc.c://	(define (cc-implies form)
cc.c://			((cc-subforms (map cc (get-args form)))
cc.c://				(tsubforms (remove-nulls (map get-tform cc-subforms)))
cc.c://				(fsubforms (remove-nulls (map get-fform cc-subforms)))
cc.c://				((equal-list? tsubforms (get-args form))
cc.c://							(A-cc (first cc-subforms))
cc.c://							(C-cc (second cc-subforms)))
cc.c://									(not (null? (get-tform C-cc))) 
cc.c://									(not (null? (get-fform A-cc))))
cc.c://									(make-or-form 
cc.c://											(make-not-form (get-fform A-cc))
cc.c://											(get-tform C-cc)))))
cc.c://							((not (null? (get-tform C-cc)))
cc.c://								(set! tform (get-tform C-cc)))
cc.c://							((not (null? (get-fform A-cc)))
cc.c://								(set! tform (make-not-form (get-fform A-cc)))))
cc.c://							(and (not (null? (get-fform C-cc))) (not (null? (get-tform A-cc))))
cc.c://								(make-or-form 
cc.c://										(make-not-form (get-tform A-cc))
cc.c://										(get-fform C-cc))))))))
cc.c://			(make-cc-return tform fform)))
cc.c:	pcArg1=pcForm->pfForm->pcArgs;
cc.c:	pcArg2=pcArg1->pcNext;
cc.c:		pcAntecedent=(*pcArg1->pfForm->paAction->pfMakeCCForm)(FALSE,pcArg1,&bAntecedentImmutable);
cc.c:		pcConsequent=(*pcArg2->pfForm->paAction->pfMakeCCForm)(TRUE,pcArg2,&bConsequentImmutable);
cc.c:				(bConsequentImmutable&&pcConsequent->pcNext)?CopyCell(pcConsequent):pcConsequent);
cc.c:				(bAntecedentImmutable&&pcAntecedent->pcNext)?CopyCell(pcAntecedent):pcAntecedent);
cc.c:		pcAntecedent=(*pcArg1->pfForm->paAction->pfMakeCCForm)(TRUE,pcArg1,&bAntecedentImmutable);
cc.c:		pcConsequent=(*pcArg2->pfForm->paAction->pfMakeCCForm)(FALSE,pcArg2,&bConsequentImmutable);
cc.c:				(bConsequentImmutable&&pcConsequent->pcNext)?CopyCell(pcConsequent):pcConsequent);
cc.c://	Return current condition formulas for an if-then-else formula
cc.c://	(define (cc-if-then-else form)
cc.c://			((cc-subforms (map cc (get-args form)))
cc.c://				(tsubforms (remove-nulls (map get-tform cc-subforms)))
cc.c://				(fsubforms (remove-nulls (map get-fform cc-subforms)))
cc.c://				((equal-list? tsubforms (get-args form))
cc.c://							(ccarg1 (first cc-subforms))
cc.c://							(ccarg2 (second cc-subforms))
cc.c://							(ccarg3 (third cc-subforms)))
cc.c://									(not (null? (get-tform ccarg1))) 
cc.c://									(not (null? (get-fform ccarg1))) 
cc.c://									(not (null? (get-tform ccarg2)))
cc.c://									(not (null? (get-tform ccarg3))))
cc.c://									(make-or-form
cc.c://											(make-and-form 
cc.c://													(get-tform ccarg1)
cc.c://													(get-tform ccarg2)))
cc.c://											(make-and-form 
cc.c://													(make-not-form (get-fform ccarg1))
cc.c://													(get-tform ccarg2)))))))
cc.c://									(not (null? (get-tform ccarg1)))
cc.c://									(not (null? (get-tform ccarg2))))
cc.c://									(make-and-form 
cc.c://											(get-tform ccarg1)
cc.c://											(get-tform ccarg2)))))
cc.c://									(not (null? (get-fform ccarg1)))
cc.c://									(not (null? (get-tform ccarg3))))
cc.c://									(make-and-form 
cc.c://											(make-not-form (get-fform ccarg1))
cc.c://											(get-tform ccarg3)))))
cc.c://									(not (null? (get-tform ccarg2)))
cc.c://									(not (null? (get-tform ccarg3))))
cc.c://									(make-and-form 
cc.c://											(get-tform ccarg2)
cc.c://											(get-tform ccarg3))))))
cc.c://									(not (null? (get-tform ccarg1)))
cc.c://									(not (null? (get-fform ccarg1)))
cc.c://									(not (null? (get-fform ccarg2)))
cc.c://									(not (null? (get-fform ccarg3))))
cc.c://									(make-and-form
cc.c://											(make-or-form 
cc.c://													(make-not-form (get-tform ccarg1))
cc.c://													(get-fform ccarg2)))
cc.c://											(make-or-form 
cc.c://													(get-fform ccarg1)
cc.c://													(get-fform ccarg2)))))))
cc.c://									(not (null? (get-tform ccarg1)))
cc.c://									(not (null? (get-fform ccarg2))))
cc.c://									(make-or-form 
cc.c://											(make-not-form (get-tform ccarg1))
cc.c://											(get-fform ccarg2)))))
cc.c://							((and (not (null? (get-fform ccarg1)))
cc.c://									(not (null? (get-fform ccarg3))))
cc.c://									(make-or-form 
cc.c://											(get-fform ccarg1)
cc.c://											(get-fform ccarg3)))))
cc.c://							((and (not (null? (get-fform ccarg2)))
cc.c://									(not (null? (get-fform ccarg3))))
cc.c://									(make-or-form 
cc.c://											(get-fform ccarg2)
cc.c://											(get-fform ccarg3)))))))))
cc.c://			(make-cc-return tform fform)))
cc.c:	pcArg1=pcForm->pfForm->pcArgs;
cc.c:	pcArg2=pcArg1->pcNext;
cc.c:	pcArg3=pcArg2->pcNext;
cc.c:		pcTAntecedent=(*pcArg1->pfForm->paAction->pfMakeCCForm)(TRUE,pcArg1,&bTAntecedentImmutable);
cc.c:		pcFAntecedent=(*pcArg1->pfForm->paAction->pfMakeCCForm)(FALSE,pcArg1,&bFAntecedentImmutable);
cc.c:		pcConsequent=(*pcArg2->pfForm->paAction->pfMakeCCForm)(TRUE,pcArg2,&bConsequentImmutable);
cc.c:		pcAlternate=(*pcArg3->pfForm->paAction->pfMakeCCForm)(TRUE,pcArg3,&bAlternateImmutable);
cc.c:			if(bFAntecedentImmutable&&pcFAntecedent->pcNext)
cc.c:			if(bConsequentImmutable&&pcConsequent->pcNext)
cc.c:			if(bAlternateImmutable&&pcAlternate->pcNext)
cc.c:			pcTAntecedent->pcNext=pcConsequent;
cc.c:			pcFAntecedent->pcNext=pcAlternate;
cc.c:			pcTAntecedent->pcNext=pcFAntecedent;
cc.c:			if(bConsequentImmutable&&pcConsequent->pcNext)
cc.c:			pcTAntecedent->pcNext=pcConsequent;
cc.c:			if(bFAntecedentImmutable&&pcFAntecedent->pcNext)
cc.c:			if(bAlternateImmutable&&pcAlternate->pcNext)
cc.c:			pcFAntecedent->pcNext=pcAlternate;
cc.c:			if(bAlternateImmutable&&pcAlternate->pcNext)
cc.c:			pcConsequent->pcNext=pcAlternate;
cc.c:		pcTAntecedent=(*pcArg1->pfForm->paAction->pfMakeCCForm)(TRUE,pcArg1,&bTAntecedentImmutable);
cc.c:		pcFAntecedent=(*pcArg1->pfForm->paAction->pfMakeCCForm)(FALSE,pcArg1,&bFAntecedentImmutable);
cc.c:		pcConsequent=(*pcArg2->pfForm->paAction->pfMakeCCForm)(FALSE,pcArg2,&bConsequentImmutable);
cc.c:		pcAlternate=(*pcArg3->pfForm->paAction->pfMakeCCForm)(FALSE,pcArg3,&bAlternateImmutable);
cc.c:			if(bTAntecedentImmutable&&pcTAntecedent->pcNext)
cc.c:			if(bConsequentImmutable&&pcConsequent->pcNext)
cc.c:			if(bAlternateImmutable&&pcAlternate->pcNext)
cc.c:			pcTAntecedent->pcNext=pcConsequent;
cc.c:			pcFAntecedent->pcNext=pcAlternate;
cc.c:			pcTAntecedent->pcNext=pcFAntecedent;
cc.c:			if(bTAntecedentImmutable&&pcTAntecedent->pcNext)
cc.c:			if(bConsequentImmutable&&pcConsequent->pcNext)
cc.c:			pcTAntecedent->pcNext=pcConsequent;
cc.c:			if(bAlternateImmutable&&pcAlternate->pcNext)
cc.c:			pcFAntecedent->pcNext=pcAlternate;
cc.c:			if(bAlternateImmutable&&pcAlternate->pcNext)
cc.c:			pcConsequent->pcNext=pcAlternate;
cc.c:// Quantifiers -----------------------------------------------------------------
cc.c://	(define (cc-forall form)
cc.c://				(args (get-args form))
cc.c://				(qf-vars (get-qf-variables args))
cc.c://				(gen-lit (get-qf-generator args))
cc.c://				(qf-form (list (get-qf-formula args)))
cc.c://				(cc-subforms (map cc qf-form))
cc.c://				(tsubforms (remove-nulls (map get-tform cc-subforms)))
cc.c://				(fsubforms (remove-nulls (map get-fform cc-subforms)))
cc.c://				((equal-list? tsubforms (first qf-form))
cc.c://						(set! tform (list 'FORALL qf-vars gen-lit (first tsubforms))))
cc.c://						(set! fform (list 'FORALL qf-vars gen-lit (first fsubforms))))))
cc.c://			(make-cc-return tform fform)))
cc.c:	pcArg=pcForm->pfForm->pcArgs;
cc.c:	pcSubForm=(*pcArg->pfForm->paAction->pfMakeCCForm)(bType,pcArg,&bImmutable);
cc.c:		pcVars=pcForm->pfForm->pcVars;
cc.c:		pcGenLit=pcForm->pfForm->pcGenLit;
cc.c:			(bImmutable&&pcSubForm->pcNext)?CopyCell(pcSubForm):pcSubForm);
cc.c://	(define (cc-exists form)
cc.c://				(args (get-args form))
cc.c://				(qf-vars (get-qf-variables args))
cc.c://				(gen-lit (get-qf-generator args))
cc.c://				(qf-form (list (get-qf-formula args)))
cc.c://				(cc-subforms (map cc qf-form))
cc.c://				(tsubforms (remove-nulls (map get-tform cc-subforms)))
cc.c://				(fsubforms (remove-nulls (map get-fform cc-subforms)))
cc.c://				((equal-list? tsubforms (first qf-form))
cc.c://						(set! tform (list 'EXISTS qf-vars gen-lit (first tsubforms))))
cc.c://						(set! fform (list 'EXISTS qf-vars gen-lit (first fsubforms))))))
cc.c://			(make-cc-return tform fform)))
cc.c:	pcArg=pcForm->pfForm->pcArgs;
cc.c:	pcSubForm=(*pcArg->pfForm->paAction->pfMakeCCForm)(bType,pcArg,&bImmutable);
cc.c:		pcVars=pcForm->pfForm->pcVars;
cc.c:		pcGenLit=pcForm->pfForm->pcGenLit;
cc.c:			(bImmutable&&pcSubForm->pcNext)?CopyCell(pcSubForm):pcSubForm);
cc.c://	(define (cc-exists! form)
cc.c://				(args (get-args form))
cc.c://				(qf-vars (get-qf-variables args))
cc.c://				(gen-lit (get-qf-generator args))
cc.c://				(qf-form (list (get-qf-formula args)))
cc.c://				(cc-subforms (map cc qf-form))
cc.c://				(tsubforms (remove-nulls (map get-tform cc-subforms)))
cc.c://				(fsubforms (remove-nulls (map get-fform cc-subforms)))
cc.c://				((equal-list? tsubforms (first qf-form))
cc.c://							(make-and-form
cc.c://									(list 'EXISTS! qf-vars gen-lit (first tsubforms))
cc.c://									(list 'EXISTS! qf-vars gen-lit (first fsubforms))))))
cc.c://								(make-and-form
cc.c://										(make-or-form
cc.c://												(list 'EXISTS! qf-vars gen-lit (first tsubforms))
cc.c://												(list 'FORALL qf-vars gen-lit (make-not-form (first tsubforms)))))
cc.c://										(list 'EXISTS qf-vars gen-lit fsubforms)))))
cc.c://								(make-or-form
cc.c://										(list 'EXISTS! qf-vars gen-lit (first tsubforms))
cc.c://										(list 'FORALL qf-vars gen-lit (make-not-form (first tsubforms)))))))
cc.c://							(set! fform (list 'EXISTS qf-vars gen-lit fsubforms))))))
cc.c://			(make-cc-return tform fform)))
cc.c:	pcArg=pcForm->pfForm->pcArgs;
cc.c:	pcTForm=(*pcArg->pfForm->paAction->pfMakeCCForm)(TRUE,pcArg,&bTImmutable);
cc.c:	pcFForm=(*pcArg->pfForm->paAction->pfMakeCCForm)(FALSE,pcArg,&bFImmutable);
cc.c:			pcVars=pcForm->pfForm->pcVars;
cc.c:			pcGenLit=pcForm->pfForm->pcGenLit;
cc.c:				(bTImmutable&&pcTForm->pcNext)?CopyCell(pcTForm):pcTForm);
cc.c:				(bFImmutable&&pcFForm->pcNext)?CopyCell(pcFForm):pcFForm);
cc.c:			pcTForm->pcNext=pcFForm;
cc.c:			pcVars=pcForm->pfForm->pcVars;
cc.c:			pcGenLit=pcForm->pfForm->pcGenLit;
cc.c:				(bTImmutable&&pcTForm->pcNext)?CopyCell(pcTForm):pcTForm);
cc.c:				(bTImmutable&&pcTForm->pcNext)?CopyCell(pcTForm):pcTForm);
cc.c:			pcTForm->pcNext=pcTemp;
cc.c:				(bFImmutable&&pcFForm->pcNext)?CopyCell(pcFForm):pcFForm);
cc.c:			pcTForm->pcNext=pcFForm;
cc.c:			pcVars=pcForm->pfForm->pcVars;
cc.c:			pcGenLit=pcForm->pfForm->pcGenLit;
cc.c:				(bTImmutable&&pcTForm->pcNext)?CopyCell(pcTForm):pcTForm);
cc.c:				(bTImmutable&&pcTForm->pcNext)?CopyCell(pcTForm):pcTForm);
cc.c:			pcTForm->pcNext=pcTemp;
cc.c:			pcVars=pcForm->pfForm->pcVars;
cc.c:			pcGenLit=pcForm->pfForm->pcGenLit;
cc.c:				(bFImmutable&&pcFForm->pcNext)?CopyCell(pcFForm):pcFForm);
cc.c://	(define (cc-binding form)
cc.c://				(b-forms (list (get-binding-formula form)))
cc.c://				(b-vars (get-binding-vars form))
cc.c://				(b-vals (get-binding-vals form))
cc.c://				(cc-subforms (map cc b-forms))
cc.c://				(tsubforms (remove-nulls (map get-tform cc-subforms)))
cc.c://				(fsubforms (remove-nulls (map get-fform cc-subforms)))
cc.c://				((equal-list? tsubforms (get-args form))
cc.c://					(let ((ccarg (first cc-subforms)))
cc.c://						(if (not (null? (get-tform ccarg)))
cc.c://							(set! tform (make-binding-form b-vars b-vals (get-tform ccarg))))
cc.c://						(if (not (null? (get-fform ccarg)))
cc.c://							(set! fform (make-binding-form b-vars b-vals (get-fform ccarg)))))))
cc.c://			(make-cc-return tform fform)))
cc.c:	pcBForm=(*pcArg->pfForm->paAction->pfMakeCCForm)(bType,pcArg,&bImmutable);
cc.c:			(bImmutable&&pcBForm->pcNext)?CopyCell(pcBForm):pcBForm);
cc.c:// Temporal modalities ---------------------------------------------------------
cc.c://	(define (cc-next form)
cc.c://		(make-cc-return '() '()))
cc.c://	(define (cc-eventually form)
cc.c://		(let ((cc-subform (cc (first (get-args form)))))
cc.c://			(make-cc-return (get-tform cc-subform) '())))
cc.c:	pcArg=pcForm->pfForm->pcArgs;
cc.c:		return (*pcArg->pfForm->paAction->pfMakeCCForm)(TRUE,pcArg,pbImmutable);
cc.c://	(define (cc-always form)
cc.c://		(let ((cc-subform (cc (first (get-args form)))))
cc.c://			(make-cc-return
cc.c://				(get-tform cc-subform)
cc.c://				(get-fform cc-subform))))
cc.c:	pcArg=pcForm->pfForm->pcArgs;
cc.c:	return (*pcArg->pfForm->paAction->pfMakeCCForm)(bType,pcArg,pbImmutable);
cc.c://	(define (cc-until form)
cc.c://				(cc-subforms (map cc (get-args form)))
cc.c://				(cc-subform1 (first cc-subforms))
cc.c://				(cc-subform2 (second cc-subforms))
cc.c://			(set! tform (get-tform cc-subform2))
cc.c://					(not (null? (get-fform cc-subform1)))
cc.c://					(not (null? (get-fform cc-subform2))))
cc.c://					(make-or-form
cc.c://							(get-fform cc-subform1)
cc.c://							(get-fform cc-subform2)))))
cc.c://			(make-cc-return tform fform)))
cc.c:	pcArg1=pcForm->pfForm->pcArgs;
cc.c:	pcArg2=pcArg1->pcNext;
cc.c:		return (*pcArg2->pfForm->paAction->pfMakeCCForm)(TRUE,pcArg2,pbImmutable);
cc.c:		pcArg1=(*pcArg1->pfForm->paAction->pfMakeCCForm)(TRUE,pcArg1,&bImmutable1);
cc.c:		pcArg2=(*pcArg2->pfForm->paAction->pfMakeCCForm)(TRUE,pcArg2,&bImmutable2);
cc.c:		if(bImmutable2&&pcArg2->pcNext)
cc.c:		pcArg1->pcNext=pcArg2;
cc.c:// MTL timed modalities --------------------------------------------------------
color.c:/* color.c -- ColorFormula support routines
color.c:Copyright C, 1997 - 2001, Fahiem Bacchus
color.c:	Print a list of formulas in lisp format, marking sub-formulas that progress to false.
color.c:	if(pcFormula->pcNext)
color.c:		for(pc=pcFormula;pc;pc=pc->pcNext)
color.c:			if(pc->pcNext)
color.c:	Print a formula in lisp format, marking sub-formulas that progress to false
color.c:		if(pcFormula->pfForm->pcVars)
color.c:			for(pc=pcFormula->pfForm->pcVars;pc;pc=pc->pcNext)
color.c:				if(pc->pcNext)
color.c:			for(pc=pcFormula->pfForm->pcGenLit;pc;pc=pc->pcNext)
color.c:				if(pc->pfForm->pcArgs||pc->pfForm->pcVars||pc->pfForm->pcGenLit)
color.c:			for(pc=pcFormula->pfForm->pcArgs;pc;pc=pc->pcNext)
color.c:				if(pc->pfForm->pcArgs||pc->pfForm->pcVars||pc->pfForm->pcGenLit)
color.c:			for(pc=pcFormula->pfForm->pcGenLit;pc;pc=pc->pcNext)
color.c:				if(pc->pfForm->pcArgs||pc->pfForm->pcVars||pc->pfForm->pcGenLit)
color.c:			for(pc=pcFormula->pfForm->pcArgs;pc;pc=pc->pcNext)
color.c:				if(pc->pfForm->pcArgs||pc->pfForm->pcVars||pc->pfForm->pcGenLit)
color.c:	if(pcFormula->pfForm->paAction->pfProgress!=NoProgressor)
color.c:		pc=(*pcFormula->pfForm->paAction->pfProgress)(pcFormula,plpLinearPlan,pbBindings,&immutable);
color.c:	switch(pcFormula->pfForm->nType)
color.c:			ps=GetName(pcFormula->pfForm,ac);
color.c:			ps=GetName(pcFormula->pfForm,ac);
color.c:				po=pcFormula->pfForm->uValue.poOperator;
color.c:				PrintFormula(pfStream,po->pcName,nLevel);
color.c:			PrintList(pfStream,pcFormula->pfForm->uValue.plList,nLevel+1);
color.c:				pcFormula->pfForm->nType);
color.c:// --------------------
color.c:	Print a list of formulas in lisp format, marking false sub-formulas.
color.c:	if(pcFormula->pcNext)
color.c:		for(pc=pcFormula;pc;pc=pc->pcNext)
color.c:			if(pc->pcNext)
color.c:	Print a formula in lisp format, marking false sub-formulas.
color.c:		if(pcFormula->pfForm->pcVars)
color.c:			for(pc=pcFormula->pfForm->pcVars;pc;pc=pc->pcNext)
color.c:				if(pc->pcNext)
color.c:			for(pc=pcFormula->pfForm->pcGenLit;pc;pc=pc->pcNext)
color.c:				if(pc->pfForm->pcArgs||pc->pfForm->pcVars||pc->pfForm->pcGenLit)
color.c:			for(pc=pcFormula->pfForm->pcArgs;pc;pc=pc->pcNext)
color.c:				if(pc->pfForm->pcArgs||pc->pfForm->pcVars||pc->pfForm->pcGenLit)
color.c:			for(pc=pcFormula->pfForm->pcGenLit;pc;pc=pc->pcNext)
color.c:				if(pc->pfForm->pcArgs||pc->pfForm->pcVars||pc->pfForm->pcGenLit)
color.c:			for(pc=pcFormula->pfForm->pcArgs;pc;pc=pc->pcNext)
color.c:				if(pc->pfForm->pcArgs||pc->pfForm->pcVars||pc->pfForm->pcGenLit)
color.c:	if(pcFormula->pfForm->paAction->pfEval!=NoEvaluator)
color.c:		if(!(*pcFormula->pfForm->paAction->pfEval)(pcFormula,plpLinearPlan,pbBindings))
color.c:	switch(pcFormula->pfForm->nType)
color.c:			ps=GetName(pcFormula->pfForm,ac);
color.c:			ps=GetName(pcFormula->pfForm,ac);
color.c:				po=pcFormula->pfForm->uValue.poOperator;
color.c:				PrintFormula(pfStream,po->pcName,nLevel);
color.c:			PrintList(pfStream,pcFormula->pfForm->uValue.plList,nLevel+1);
color.c:				pcFormula->pfForm->nType);
compute.c:To retire:  ComputeTerm,  -- this is a real efficiency dog.
compute.c:/* compute.c -- Support for defined functions
compute.c:Copyright C, 1997 - 99  F. Bacchus
compute.c:/* ----------------------------------------------------------------------------- */
compute.c:(define (eval-terms terms world/action bindings)
compute.c:  (map (lambda (term) (eval-term term world/action bindings))
compute.c:(define (eval-term term world/action bindings)
compute.c:   ((var? term) (lookup-var term bindings))
compute.c:   ((function-term? term)
compute.c:	(eval-function (get-operator term)
compute.c:		   (eval-terms (get-args term) world/action bindings)
compute.c:	for(pc1=pcTerms;pc1;pc1=pc1->pcNext)
compute.c:			pcEnd=pcEnd->pcNext=CopyCell(pc);
compute.c:			ErrorMessage("Undefined or mis-defined term:\n");
compute.c:	for(pc1=pcTerms;pc1;pc1=pc1->pcNext)
compute.c:			pcNewVals->pfForm=pc->pfForm;
compute.c:			pcNewVals=pcNewVals->pcNext=pcNewVals+1;
compute.c:			ErrorMessage("Undefined or mis-defined term:\n");
compute.c:	--pcNewVals;
compute.c:	pcNewVals->pcNext=NULL;
compute.c:	else if(pcTerm->pfForm->paAction->pfCompute!=NoComputor)	/* if term can be computed */
compute.c:		pc=(*pcTerm->pfForm->paAction->pfCompute)(pcTerm,plpLinearPlan,pbBindings);
compute.c:		Message("compute-term: No computor for variable\n");
compute.c:	else if(!pcTerm->pfForm->pcArgs) 	/* if literal formula */
compute.c:		Message("compute-term: No computor for literal\n");
compute.c:		ErrorMessage("Invalid term \"%s\" in formula\n",GetName(pcTerm->pfForm,ac));
compute.c:		pai=pc->pfForm->uValue.paiArrayInfo;
compute.c:		pc->pfForm=pai->ppcArray[nIndex]->pfForm;
compute.c:	if(pcBinding->pfForm->nType!=ATOM_ARRAYINFOP)
compute.c:	pai=pcBinding->pfForm->uValue.paiArrayInfo;
compute.c:		ErrorMessage("Array reference to non-array %s\n",GetName(pcArray->pfForm,ac));
compute.c:	n=pai->nDimension;
compute.c:	for(pc=pcArray->pfForm->pcArgs;pc;pc=pc->pcNext)
compute.c:			ErrorMessage("Too many indices for array %s\n",GetName(pc->pfForm,ac));
compute.c:			ErrorMessage("Invalid index %d for array %s\n",i,GetName(pc->pfForm,ac));
compute.c:		if(nIndex<0||nIndex>=pai->pnLimits[i])
compute.c:			ErrorMessage("Index %d out of range for array %s\n",i,GetName(pc->pfForm,ac));
compute.c:		nOff+=pai->pnMultipliers[i]*nIndex;
compute.c:		ErrorMessage("Too few indices for array %s\n",GetName(pcArray->pfForm,ac));
compute.c:	psiSymbolInfo=pcFormula->pfForm->uValue.psiSymbolInfo;
compute.c:	pc=CopyCellList(psiSymbolInfo->pcFormula);
compute.c:	psiSymbolInfo=pcFormula->pfForm->uValue.psiSymbolInfo;
compute.c:	pcFunction->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
compute.c:	pf->nType=ATOM_IDENT;
compute.c://	pf->psName=IdentAlloc(psiSymbolInfo->psName);
compute.c:	pf->psName=psiSymbolInfo->psName;
compute.c:	if(pcFormula->pfForm->pcArgs)
compute.c:		pcTerms=ComputeTerms(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings);
compute.c:			TermError("compute-def-function",pcFormula,pbBindings);	
compute.c:	b=(*pc->pfForm->paAction->pfEval)(pc,plpLinearPlan,pb);
compute.c:		ErrorMessage("Function %s terminated abnormally\n",psiSymbolInfo->psName);
compute.c:		ErrorMessage("No return value for function %s\n",psiSymbolInfo->psName);
compute.c:	psiSymbolInfo=pcFormula->pfForm->uValue.psiSymbolInfo;
compute.c:	pcMacro->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
compute.c:	pf->nType=ATOM_IDENT;
compute.c://	pf->psName=IdentAlloc(psiSymbolInfo->psName);
compute.c:	pf->psName=psiSymbolInfo->psName;
compute.c:	if(pcFormula->pfForm->pcArgs)
compute.c:		pcTerms=ComputeTerms(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings);
compute.c:			TermError("compute-def-macro",pcFormula,pbBindings);	
compute.c:	b=(*pc->pfForm->paAction->pfEval)(pc,plpLinearPlan,pb);
compute.c:		ErrorMessage("Macro %s terminated abnormally\n",psiSymbolInfo->psName);
compute.c:		ErrorMessage("No return value for macro %s\n",psiSymbolInfo->psName);
compute.c:	for(pc=pcVars;pc;pc=pc->pcNext)
compute.c:		if(pc->pfForm->pcArgs)			/* if array */
compute.c:	for(pc=pcVars;pc;pc=pc->pcNext)
compute.c:		if(pc->pfForm->pcArgs)			/* if array */
compute.c:			pcEnd=pcEnd->pcNext=MakeArray(pc,pcZero,plpLinearPlan,pbBindings);
compute.c:			pcEnd=pcEnd->pcNext=CopyCell(pc);
compute.c:	pai->psName=IdentAlloc(pcFormula->pfForm->psName);
compute.c:	for(pc=pcFormula->pfForm->pcArgs;pc;pc=pc->pcNext)
compute.c:	pai->nDimension=n;
compute.c:	pai->pnLimits=(int *)MemAlloc(n*sizeof(int));
compute.c:	pai->pnMultipliers=(int *)MemAlloc(n*sizeof(int));
compute.c:	for(pc=pcFormula->pfForm->pcArgs;pc;pc=pc->pcNext)
compute.c:		FormulaToInteger(pc,plpLinearPlan,pbBindings,pai->pnLimits+i++);
compute.c:	for(i=n-1;i>=0;i--)
compute.c:		pai->pnMultipliers[i]=nMultiplier;
compute.c:		nMultiplier*=pai->pnLimits[i];
compute.c:	pai->nCount=nMultiplier;
compute.c:	ppc=pai->ppcArray=(CELLP *)MemAlloc(nMultiplier*sizeof(CELLP));
compute.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
compute.c:	pf->nType=ATOM_ARRAYINFOP;
compute.c:	pf->psName=IdentName(pcFormula->pfForm);
compute.c:	pf->uValue.paiArrayInfo=pai;
compute.c:	pc=pcFormula->pfForm->pcArgs;
compute.c:	pc=(*pc->pfForm->paAction->pfCompute)(pc,GetGoalWorld(TRUE),pbBindings);
compute.c:	pc=pcFormula->pfForm->pcArgs;
compute.c:	pc=(*pc->pfForm->paAction->pfCompute)(pc,plpCurrentPlan,pbBindings);
compute.c:		plp=plp->plpParent;
compute.c:		pc=pcFormula->pfForm->pcArgs;
compute.c:		pc=(*pc->pfForm->paAction->pfCompute)(pc,plp,pbBindings);
compute.c:	pc=pcFormula->pfForm->pcArgs;
compute.c:		pc=MakeFloatForm(plpLinearPlan->dfCost);
compute.c:		ErrorMessage("compute-a*:  Formula must evaluate to a number.\n");
compute.c:		pc=MakeFloatForm(plpLinearPlan->dfCost);
compute.c:	pc=MakeFloatForm(dfValue+plpLinearPlan->dfCost);
compute.c:	Compute an optimal-cost heuristic cost function.
compute.c:	pc=MakeFloatForm(plpLinearPlan->dfCost);
compute.c:	Compute a best-action priority function.
compute.c:	Compute the plan-length function.
compute.c:	Plan-length is the current depth of search.
compute.c:	pc=MakeIntegerForm(plpLinearPlan->nLength);
compute.c:	Compute the plan-cost function.
compute.c:	Plan-cost is the sum of costs encountered while achieving the current state.
compute.c:	pc=MakeFloatForm(plpLinearPlan->dfCost);
compute.c:	Compute the plan-duration function.
compute.c:	Plan-duration is the sum of operation times required to achieve the current state.
compute.c:	pc=MakeFloatForm(plpLinearPlan->dfTime);
compute.c:	Compute the action-name function.
compute.c:	pc=CopyCell(plpLinearPlan->pcActionName);
compute.c:	Compute the action-cost function.
compute.c:	pc=MakeFloatForm(plpLinearPlan->dfActionCost);
compute.c:	Compute the action-duration function.
compute.c:	pc=MakeFloatForm(plpLinearPlan->dfActionDuration);
compute.c:	Compute the action-priority function.
compute.c:	pc=MakeFloatForm(plpLinearPlan->dfActionPriority);
compute.c:	Compute the world-number function.
compute.c:	World-number is the generation index of the current world.
compute.c:	pc=MakeIntegerForm(plpLinearPlan->nWorldNumber);
compute.c://	Compute the world-number function.
compute.c://	World-number is the generation index of the current world.
compute.c://		pc=MakeFloatForm(plpLinearPlan->dfHeuristic);
compute.c://		pc=MakeIntegerForm(plpLinearPlan->nWorldNumber);
compute.c:	Return the plan-status string.
compute.c:	pc=pcFormula->pfForm->pcArgs;
compute.c:		TermError("open-file",pcFormula,pbBindings);
compute.c:	pc=pc->pcNext;
compute.c:		TermError("open-file",pcFormula,pbBindings);
compute.c:	psStatus=IdentName(pcStatus->pfForm);
compute.c:		ErrorMessage("open-file:  Unsupported access status: %s\n",psStatus);
compute.c:			aftFileTable[nFile].pfFile=fopen(GetName(pcName->pfForm,ac),psStatus);
compute.c:				ErrorMessage("open-file:  Failed to open file %s for %s access\n",
compute.c:					GetName(pcName->pfForm,ac),GetName(pcStatus->pfForm,ac));
compute.c:	ErrorMessage("open-file:  No more file handles available.\n");
compute.c:	if(!pcFormula->pfForm->pcArgs)
compute.c:		ErrorMessage("compute-make-literal:  No arguments specified\n");
compute.c:	FormulaToString(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings,&psFormat);
compute.c:		ErrorMessage("compute-make-literal:  No format specified\n");
compute.c:		pcFormula->pfForm->pcArgs->pcNext,plpLinearPlan,pbBindings);
crchash.c:	nHashMask=nHashSize-1;
crchash.c:	nHash=plpWorld->nSignature&nHashMask;
crchash.c:	phHash->plpWorld=plpWorld;
crchash.c:	phHash->phNext=pphHashTable[nHash];		
crchash.c:	nHash=plpWorld->nSignature&nHashMask;
crchash.c:	for(phHash=pphHashTable[nHash];phHash;phHash=phHash->phNext)
crchash.c:		if(plpWorld->nSignature==phHash->plpWorld->nSignature)
crchash.c:			if((*pfPlanEqQ)(plpWorld,phHash->plpWorld))
crchash.c:					CommandPrintf(pfTraceStream,"\nWorld %d is equivalent to world %d\n",plpWorld->nWorldNumber,phHash->plpWorld->nWorldNumber);
crchash.c:				return phHash->plpWorld;
crchash.c:	nHash=plpWorld->nSignature&nHashMask;
crchash.c:	for(phHash=pphHashTable[nHash];phHash;phHash=phHash->phNext)
crchash.c:		if(plpWorld==phHash->plpWorld)
crchash.c:			nHashCount--;
crchash.c:			phPrev->phNext=phHash->phNext;	// unlink world from hash table
crchash.c:		for(ph=pphHashTable[i];ph;ph=ph->phNext)	// for all entries in bucket
crchash.c:			ph2=ph1->phNext;			// pass the wand
crchash.c:			nHash=ph1->plpWorld->nSignature&nHashMask;	// new hash value
crchash.c:			ph1->phNext=pph[nHash];		// relink the entry
crchash.c:			for(ph=pphHashTable[i];ph;ph=ph->phNext)
current.c:/* current.c -- Temporal Evaluator
current.c:Don't assume that !FALSE == TRUE, or vice-versa!
current.c:/* Boolean Formulas ------------------------------------------------------------ */
current.c:	pcArg1=pcFormula->pfForm->pcArgs;
current.c:	nArg1=(*pcArg1->pfForm->paAction->pfCurrent)(pcArg1,plpLinearPlan,pbBindings);
current.c:	for(pcSubForm=pcFormula->pfForm->pcArgs;pcSubForm;pcSubForm=pcSubForm->pcNext)
current.c:		nSubForm=(*pcSubForm->pfForm->paAction->pfCurrent)(pcSubForm,plpLinearPlan,pbBindings);
current.c:	for(pcSubForm=pcFormula->pfForm->pcArgs;pcSubForm;pcSubForm=pcSubForm->pcNext)
current.c:		nSubForm=(*pcSubForm->pfForm->paAction->pfCurrent)(pcSubForm,plpLinearPlan,pbBindings);
current.c:	for(pcSubForm=pcFormula->pfForm->pcArgs;pcSubForm;pcSubForm=pcSubForm->pcNext)
current.c:		nSubForm=(*pcSubForm->pfForm->paAction->pfCurrent)(pcSubForm,plpLinearPlan,pbBindings);
current.c:	pcArg1=pcFormula->pfForm->pcArgs;
current.c:	nArg1=(*pcArg1->pfForm->paAction->pfCurrent)(pcArg1,plpLinearPlan,pbBindings);
current.c:		pcArg2=pcArg1->pcNext;
current.c:		nArg2=(*pcArg2->pfForm->paAction->pfCurrent)(pcArg2,plpLinearPlan,pbBindings);
current.c:	Current an (if-then-else... ) formula checking for true/false.
current.c:	c(if-then-else a t f) => (if-then-else c(a) c(t) c(f))
current.c:	pcArg1=pcFormula->pfForm->pcArgs;
current.c:	pcArg2=pcArg1->pcNext;
current.c:	pcArg3=pcArg2->pcNext;
current.c:	nArg1=(*pcArg1->pfForm->paAction->pfCurrent)(pcArg1,plpLinearPlan,pbBindings);
current.c:		nArg2=(*pcArg2->pfForm->paAction->pfCurrent)(pcArg2,plpLinearPlan,pbBindings);
current.c:		nArg3=(*pcArg3->pfForm->paAction->pfCurrent)(pcArg3,plpLinearPlan,pbBindings);
current.c:	nArg2=(*pcArg2->pfForm->paAction->pfCurrent)(pcArg2,plpLinearPlan,pbBindings);
current.c:	nArg3=(*pcArg3->pfForm->paAction->pfCurrent)(pcArg3,plpLinearPlan,pbBindings);
current.c:/* Quantified Formulas --------------------------------------------------------- */
current.c:	pcVars=pcFormula->pfForm->pcVars;
current.c:	pcGenLit=pcFormula->pfForm->pcGenLit;
current.c:	pcArgs=pcFormula->pfForm->pcArgs;
current.c:	while((*pcGenLit->pfForm->paAction->pfGenerator)
current.c://		(pcGenLit,&(pbBindings->pvContext),pcVars,plpLinearPlan,pbBindings))
current.c:		nForm=(*pcArgs->pfForm->paAction->pfCurrent)(pcArgs,plpLinearPlan,pbBindings);
current.c:	pcVars=pcFormula->pfForm->pcVars;
current.c:	pcGenLit=pcFormula->pfForm->pcGenLit;
current.c:	pcArgs=pcFormula->pfForm->pcArgs;
current.c:	while((*pcGenLit->pfForm->paAction->pfGenerator)
current.c://		(pcGenLit,&(pbBindings->pvContext),pcVars,plpLinearPlan,pbBindings))
current.c:			nForm=(*pcArgs->pfForm->paAction->pfCurrent)(pcArgs,plpLinearPlan,pbBindings);
current.c:	pcVars=pcFormula->pfForm->pcVars;
current.c:	pcGenLit=pcFormula->pfForm->pcGenLit;
current.c:	pcArgs=pcFormula->pfForm->pcArgs;
current.c:	while((*pcGenLit->pfForm->paAction->pfGenerator)
current.c://		(pcGenLit,&(pbBindings->pvContext),pcVars,plpLinearPlan,pbBindings))
current.c:			nForm=(*pcArgs->pfForm->paAction->pfCurrent)(pcArgs,plpLinearPlan,pbBindings);
current.c:/* Temporal Formulas ----------------------------------------------------------- */
current.c:	pcArg1=pcFormula->pfForm->pcArgs;
current.c:	nArg1=(*pcArg1->pfForm->paAction->pfCurrent)(pcArg1,plpLinearPlan,pbBindings);
current.c:	pcArg1=pcFormula->pfForm->pcArgs;
current.c:	nArg1=(*pcArg1->pfForm->paAction->pfCurrent)(pcArg1,plpLinearPlan,pbBindings);
current.c:	pcCondition=pcFormula->pfForm->pcArgs;
current.c:	pcAchievement=pcCondition->pcNext;
current.c:	nAchievement=(*pcAchievement->pfForm->paAction->pfCurrent)(pcAchievement,plpLinearPlan,pbBindings);
current.c:	nCondition=(*pcCondition->pfForm->paAction->pfCurrent)(pcCondition,plpLinearPlan,pbBindings);
current.c:/* MTL Timed Temporal Formulas ------------------------------------------------- */
current.c:	pisISpec=GetBFISpec(pcFormula)->pfForm->uValue.piISpec;
current.c:		nForm=(*pcForm->pfForm->paAction->pfCurrent)(pcForm,plpLinearPlan,pbBindings);
current.c:	pcShiftedForm=CopyCell(pcFormula->pfForm->pcArgs);
current.c:	pcShiftedForm->pfForm=CopyAlloc(pcShiftedForm->pfForm,sizeof(FORMULA));
current.c:	pcISpec=pcShiftedForm->pfForm->pcArgs;
current.c:	pcTail=pcISpec->pcNext;
current.c:	pcISpec->pcNext=pcTail;
current.c:	pcShiftedForm->pfForm->pcArgs=pcISpec;
current.c:	nForm=(*pcShiftedForm->pfForm->paAction->pfCurrent)(pcShiftedForm,plpLinearPlan,pbBindings);
current.c:	pisISpec=GetBFISpec(pcFormula)->pfForm->uValue.piISpec;
current.c:			nForm=(*pcForm->pfForm->paAction->pfCurrent)(pcForm,plpLinearPlan,pbBindings);
current.c:	piISpec=GetBFISpec(pcFormula)->pfForm->uValue.piISpec;
current.c:		nAchievement=(*pcForm->pcNext->pfForm->paAction->pfCurrent)(pcForm->pcNext,plpLinearPlan,pbBindings);
current.c:		nCondition=(*pcForm->pfForm->paAction->pfCurrent)(pcForm,plpLinearPlan,pbBindings);
current.c:	nCondition=(*pcForm->pfForm->paAction->pfCurrent)(pcForm,plpLinearPlan,pbBindings);
current.c:/* Auxiliary Formulas ---------------------------------------------------------- */
current.c:	nForm=(*pcForm->pfForm->paAction->pfCurrent)(pcForm,plpLinearPlan,
current.c:/* Modalities ----------------------------------------------------------------- */
current.c:	pcArgs=pcFormula->pfForm->pcArgs;
current.c:	n=(*pcArgs->pfForm->paAction->pfEval)(pcArgs,GetGoalWorld(TRUE),pbBindings);
current.c:	pcArgs=pcFormula->pfForm->pcArgs;
current.c:	n=(*pcArgs->pfForm->paAction->pfEval)(pcArgs,plpCurrentPlan,pbBindings);
current.c:		plp=plp->plpParent;
current.c:	pcArgs=pcFormula->pfForm->pcArgs;
current.c:		n=(*pcArgs->pfForm->paAction->pfEval)(pcArgs,plp,pbBindings);
current.c:	n=(*pcFormula->pfForm->paAction->pfEval)(pcFormula,plpLinearPlan,pbBindings);
domain.c:Copyright C, 1996 - 2001,  F. Bacchus
domain.c:	provides a definition by way of a first-order formula. This
domain.c:	provides a definition by way of a first-order formula. This
domain.c:CELLP pcSearchGlobalInit;				/* search-global initialization list */
domain.c:	if(psi->pcFormula)
domain.c:		MarkFormulaList(psi->pcFormula);
domain.c:	if(psi->paAction)
domain.c:		ZoneMark(psi->paAction);
domain.c:(define (get-symbol-name index)
domain.c:  (symbol-info-name (vector-ref *world-symbols* index)))
domain.c:	else if(psSymbol->nType!=ATOM_SYMBOLINFOP)
domain.c:		psi=psSymbol->uValue.psiSymbolInfo;
domain.c:/* Functions for setting up the domain symbol information ------------------- */
domain.c:(define (insert-symbol-info symbol type arity eval-type . optional-args)
domain.c:  (let ((eval-object (if (null? optional-args)
domain.c:			 (first optional-args))))
domain.c:	(put-symbol-index symbol *number-of-world-symbols*)
domain.c:	(set! *world-symbols*
domain.c:		 (append! (vector->list *world-symbols*)
domain.c:			  (list (make-symbol-info :name symbol
domain.c:						  :eval-type eval-type
domain.c:						  :eval-object eval-object)))))
domain.c:	(set! *number-of-world-symbols* (+ 1 *number-of-world-symbols*))
domain.c:	(list (get-symbol-index symbol)
domain.c:	  (vector-ref *world-symbols* (get-symbol-index symbol)))))
domain.c:	psiSymbolInfo->psName=IdentAlloc(psName);
domain.c:	psiSymbolInfo->nSymbolType=nSymbolType;
domain.c:	psiSymbolInfo->nArity=nArity;
domain.c:	psiSymbolInfo->nEvalType=nEvalType;
domain.c:	psiSymbolInfo->pfFunction=pfFunction;
domain.c:	psiSymbolInfo->pcFormula=pcFormula;
domain.c:	psiSymbolInfo->bRewritable=bRewritable;
domain.c:	pa=psiSymbolInfo->paAction=(ACTIONP)MemAlloc(sizeof(ACTION));
domain.c:					pa->pfEval=EvalDescPredicate;
domain.c:					pa->pfIdle=EvalDescPredicate;
domain.c:					pa->pfProgress=ProgressAtomic;
domain.c:					pa->pfCurrent=CurrentAtomic;
domain.c:					pa->pfGenerator=GenerateDescPredicate;
domain.c:					pa->pfCompute=NoComputor;
domain.c:					pa->pfMakeCCForm=MakeCCAtomicForm;
domain.c:					pa->pfEval=NoEvaluator;
domain.c:					pa->pfIdle=NoIdler;
domain.c:					pa->pfProgress=NoProgressor;
domain.c:					pa->pfCurrent=NoCurrentor;
domain.c://					pa->pfGenerator=NoGenerator;
domain.c:					pa->pfGenerator=GenerateDescPredicate;
domain.c:					pa->pfCompute=ComputeDescFunction;
domain.c:					pa->pfMakeCCForm=NoCCForm;
domain.c:					pa->pfEval=NoEvaluator;
domain.c:					pa->pfIdle=NoIdler;
domain.c:					pa->pfProgress=NoProgressor;
domain.c:					pa->pfCurrent=NoCurrentor;
domain.c:					pa->pfGenerator=NoGenerator;
domain.c:					pa->pfCompute=ComputeDescMacro;
domain.c:					pa->pfMakeCCForm=NoCCForm;
domain.c:					pa->pfEval=EvalDefPredicate;
domain.c:					pa->pfIdle=EvalDefPredicate;
domain.c:					pa->pfProgress=ProgressAtomic;
domain.c:					pa->pfCurrent=CurrentAtomic;
domain.c:					pa->pfGenerator=NoGenerator;
domain.c:					pa->pfCompute=NoComputor;
domain.c:					pa->pfMakeCCForm=MakeCCAtomicForm;
domain.c:					pa->pfEval=NoEvaluator;
domain.c:					pa->pfIdle=NoIdler;
domain.c:					pa->pfProgress=NoProgressor;
domain.c:					pa->pfCurrent=NoCurrentor;
domain.c:					pa->pfGenerator=NoGenerator;
domain.c:					pa->pfCompute=ComputeDefFunction;
domain.c:					pa->pfMakeCCForm=NoCCForm;
domain.c:					pa->pfEval=NoEvaluator;
domain.c:					pa->pfIdle=NoIdler;
domain.c:					pa->pfProgress=NoProgressor;
domain.c:					pa->pfCurrent=NoCurrentor;
domain.c:					pa->pfGenerator=GenerateDefGenerator;
domain.c:					pa->pfCompute=NoComputor;
domain.c:					pa->pfMakeCCForm=NoCCForm;
domain.c:					pa->pfEval=NoEvaluator;
domain.c:					pa->pfIdle=NoIdler;
domain.c:					pa->pfProgress=NoProgressor;
domain.c:					pa->pfCurrent=NoCurrentor;
domain.c:					pa->pfGenerator=NoGenerator;
domain.c://					pa->pfCompute=ComputeDefMacro;
domain.c:					pa->pfCompute=ComputeDefFunction;
domain.c:					pa->pfMakeCCForm=NoCCForm;
domain.c:					pa->pfEval=(EVALP)SymbolInfoFunction(psiSymbolInfo);
domain.c:					pa->pfIdle=(EVALP)SymbolInfoFunction(psiSymbolInfo);
domain.c:					pa->pfProgress=ProgressAtomic;
domain.c:					pa->pfCurrent=CurrentAtomic;
domain.c:					pa->pfGenerator=NoGenerator;
domain.c:					pa->pfCompute=NoComputor;
domain.c:					pa->pfMakeCCForm=MakeCCAtomicForm;
domain.c:					pa->pfEval=NoEvaluator;
domain.c:					pa->pfIdle=NoIdler;
domain.c:					pa->pfProgress=NoProgressor;
domain.c:					pa->pfCurrent=NoCurrentor;
domain.c:					pa->pfGenerator=NoGenerator;
domain.c:					pa->pfCompute=(COMPUTEP)SymbolInfoFunction(psiSymbolInfo);
domain.c:					pa->pfMakeCCForm=NoCCForm;
domain.c:					pa->pfEval=NoEvaluator;
domain.c:					pa->pfIdle=NoIdler;
domain.c:					pa->pfProgress=NoProgressor;
domain.c:					pa->pfCurrent=NoCurrentor;
domain.c:					pa->pfGenerator=(GENERATORP)SymbolInfoFunction(psiSymbolInfo);
domain.c:					pa->pfCompute=NoComputor;
domain.c:					pa->pfMakeCCForm=NoCCForm;
domain.c:					pa->pfEval=NoEvaluator;
domain.c:					pa->pfIdle=NoIdler;
domain.c:					pa->pfProgress=NoProgressor;
domain.c:					pa->pfCurrent=NoCurrentor;
domain.c:					pa->pfGenerator=NoGenerator;
domain.c:					pa->pfCompute=(COMPUTEP)SymbolInfoFunction(psiSymbolInfo);
domain.c:					pa->pfMakeCCForm=NoCCForm;
domain.c:/* Symbol type predicates ------------------------------------------------------ */
domain.c:/* Symbol class predicates ----------------------------------------------------- */
domain.c:/* Miscellaneous --------------------------------------------------------------- */
domain.c:	return psiSymbolInfo->pcFormula->pfForm->pcVars;
domain.c:	return psiSymbolInfo->pcFormula->pfForm->pcGenLit;
domain.c:	return psiSymbolInfo->pcFormula->pfForm->pcArgs;
eval1.c:Copyright C, 1996 - 2002  F. Bacchus
eval1.c:/* global data ----------------------------------------------------------------- */
eval1.c:CELLP pcSSForm;							/* search-strategy formula */
eval1.c:CELLP pcPredefinedPlan;					/* predefined plan for follow-predefined-plan */
eval1.c:/* local data ------------------------------------------------------------------ */
eval1.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
eval1.c:	pf->nType=pcName->pfForm->nType;
eval1.c:	pf->uValue=pcName->pfForm->uValue;
eval1.c:	pf->psName=pcName->pfForm->psName;
eval1.c:		if(psiSymbolInfo->nArity>=0)
eval1.c:			for(pc1=pcArgs;pc1;pc1=pc1->pcNext)
eval1.c:			if(psiSymbolInfo->nArity!=nLength)
eval1.c:					pf->psName,nLength,nLength==1?"":"s",psiSymbolInfo->nArity);
eval1.c:		pf->paAction=psiSymbolInfo->paAction;
eval1.c:	pf->pcArgs=bCopy?CopyCellList(pcArgs):pcArgs;
eval1.c:/* Search Interface ------------------------------------------------------------ */
eval1.c:	bStatus=FormulaToInteger(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings,&n);
eval1.c:/* Strategy Interface ---------------------------------------------------------- */
eval1.c:(define search-strategy depth-first-priority)
eval1.c:(define (set-search-strategy strategy)
eval1.c:  (cond ((eqv? strategy 'depth-first-priority)
eval1.c:	 (set! search-strategy depth-first-priority))
eval1.c:	((eqv? strategy 'depth-first)
eval1.c:	 (set! search-strategy depth-first))
eval1.c:	((eqv? strategy 'breadth-first-priority)
eval1.c:	 (set! search-strategy breadth-first-priority))
eval1.c:	((eqv? strategy 'breadth-first)
eval1.c:	 (set! search-strategy breadth-first))
eval1.c:	((eqv? strategy 'best-first)
eval1.c:	 (set! search-strategy best-first))
eval1.c:	((eqv? strategy 'id-search)
eval1.c:	 (set! search-strategy id-search))
eval1.c:					~%depth-first-priority~
eval1.c:					~%breadth-first-priority~
eval1.c:					~%depth-first~
eval1.c:					~%breadth-first~
eval1.c:					~%best-first~
eval1.c:					~%id-search"))))
eval1.c:	pc=pcFormula->pfForm->pcArgs;
eval1.c:	psStrategy=IdentName(pcFormula->pfForm->pcArgs->pfForm);
eval1.c:			pcSSForm=CopyCell(pc->pcNext);
eval1.c:	ErrorMessage("set-search-strategy:  Unknown strategy \"%s\".\n"
eval1.c:		"depth-first, depth-first-priority, depth-best-first, \n"
eval1.c:		"breadth-first, breadth-first-priority, or best-first.\n",psStrategy);
eval1.c:(define (get-search-strategy )
eval1.c:  search-strategy)
eval1.c:	ErrorMessage("get-search-strategy:  Search strategy is not known.\n");
eval1.c:(define (reset-search-strategy )
eval1.c:  (reset-priority-fn)
eval1.c:  (set! search-strategy depth-first-priority))
eval1.c:/* Random number generator selection ---------------------------------------- */
eval1.c:	pc=pcFormula->pfForm->pcArgs;
eval1.c:	psRNG=IdentName(pc->pfForm);
eval1.c:	pc=MakeStringForm(*prCurrentRNG->ppsName);
eval1.c:/* EvalSetControl (Interface Command) ------------------------------------------
eval1.c:	if(!FormulaToString(pcFormula->pfForm->pcArgs,plpLinearPlan,
eval1.c:			ErrorMessage("set-control:  Unknown control type.  Only temporal "
eval1.c:/* EvalEnable (Interface Command) ----------------------------------------------
eval1.c:	pc=pcFormula->pfForm->pcArgs;
eval1.c:	if(StringEqQ(pc->pfForm->psName,apsStringTab[STRING_CONCURRENT_PLANNING]))
eval1.c:	else if(StringEqQ(pc->pfForm->psName,apsStringTab[STRING_CYCLE_CHECKING]))
eval1.c:	else if(StringEqQ(pc->pfForm->psName,apsStringTab[STRING_TIMING_STATISTICS]))
eval1.c:	else if(StringEqQ(pc->pfForm->psName,apsStringTab[STRING_BACKTRACKING]))
eval1.c:	else if(StringEqQ(pc->pfForm->psName,apsStringTab[STRING_PRUNING_ALL_SUCCESSORS]))
eval1.c:	else if(StringEqQ(pc->pfForm->psName,apsStringTab[STRING_PDDL_SUPPORT]))
eval1.c:		pc=pc->pcNext;
eval1.c:		if(pc&&StringEqQ(pc->pfForm->psName,apsStringTab[STRING_PRIORITY]))
eval1.c:		else if(pc&&StringEqQ(pc->pfForm->psName,apsStringTab[STRING_COST]))
eval1.c:/* EvalDisable (Interface Command) ---------------------------------------------
eval1.c:	if(!pcFormula->pfForm->pcArgs)
eval1.c:	if(StringEqQ(pcFormula->pfForm->pcArgs->pfForm->psName,
eval1.c:	else if(StringEqQ(pcFormula->pfForm->pcArgs->pfForm->psName,
eval1.c:	else if(StringEqQ(pcFormula->pfForm->pcArgs->pfForm->psName,
eval1.c:	else if(StringEqQ(pcFormula->pfForm->pcArgs->pfForm->psName,
eval1.c:	else if(StringEqQ(pcFormula->pfForm->pcArgs->pfForm->psName,
eval1.c:	else if(StringEqQ(pcFormula->pfForm->pcArgs->pfForm->psName,
eval1.c:/* Trace Interface ------------------------------------------------------------- */
eval1.c:(define (set-trace-level i)
eval1.c:	bStatus=FormulaToInteger(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings,&n);
eval1.c:(define (function-tracer key data)
eval1.c:		((eq? key 'plan-successors)
eval1.c:			(format *trace-stream*
eval1.c:				(plan-length (first data)))
eval1.c:			(print-world (plan-world/action (first data)) *trace-stream*)
eval1.c:			(format *trace-stream*
eval1.c:				(plan-action-name (first data)))
eval1.c:				(format *trace-stream*
eval1.c:				(format *trace-stream*
eval1.c:				(format *trace-stream*
eval1.c:					(format *trace-stream*
eval1.c:					(for-each (lambda (plan)
eval1.c:							(format *trace-stream*
eval1.c:								(plan-action-name plan))
eval1.c:							(print-world (plan-world/action plan) *trace-stream*)
eval1.c:							(format *trace-stream*  "~%"))
eval1.c:	CommandPrintf(pfTraceStream,"-----------------------------------------"
eval1.c:		"---------------------------------------\n");
eval1.c:				plpParent->nWorldNumber,LinearPlanLength(plpParent),plpParent->dfHeuristic,
eval1.c:				(plpParent->plpParent)?plpParent->dfHeuristic-plpParent->plpParent->dfHeuristic:plpParent->dfHeuristic,plpParent->dfTime);
eval1.c:			CommandPrintf(pfTraceStream,"Expanding world %d at depth %d, heuristic %f delta %f (action-cost %f total-cost %f) action: ",
eval1.c:				plpParent->nWorldNumber,LinearPlanLength(plpParent),plpParent->dfHeuristic,
eval1.c:				(plpParent->plpParent)?plpParent->dfHeuristic-plpParent->plpParent->dfHeuristic:plpParent->dfHeuristic,
eval1.c:				plpParent->dfActionCost,plpParent->dfCost);
eval1.c:				plpParent->nWorldNumber,LinearPlanLength(plpParent),plpParent->dfPriority,plpParent->dfTime);
eval1.c:				plpParent->nWorldNumber,LinearPlanLength(plpParent),plpParent->dfPriority);
eval1.c:				plpParent->nWorldNumber,LinearPlanLength(plpParent),plpParent->dfTime);
eval1.c:				plpParent->nWorldNumber,LinearPlanLength(plpParent));
eval1.c:	PrintFlatFormula(pfTraceStream,plpParent->pcActionName);
eval1.c:			for(plpPlan=plpSuccessors;plpPlan;plpPlan=plpPlan->plpNext)
eval1.c:			for(plpPlan=plpSuccessors;plpPlan;plpPlan=plpPlan->plpNext)
eval1.c:						plpPlan->nWorldNumber,plpPlan->dfHeuristic);
eval1.c:						plpPlan->nWorldNumber,plpPlan->dfPriority);
eval1.c:						plpPlan->nWorldNumber);
eval1.c:				PrintFormula(pfTraceStream,plpPlan->pcActionName,0);
eval1.c://------------
eval1.c:	bStatus=FormulaToString(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings,&ps);
eval1.c:/* EvalSetGoalAddendum (Interface Command) -------------------------------------
eval1.c:	pc=pcFormula->pfForm->pcArgs;
eval1.c:	if(pc->pfForm->paAction->pfEval!=EvalDefPredicate)
eval1.c:		ErrorMessage("set-goal-addendum:  Goal addendum must be a "
eval1.c:/* Heuristic Interface ------------------------------------------------------- */
eval1.c:(define (set-cost-fn fn)
eval1.c:	 (set! cost-fn fn))
eval1.c:	((eqv? fn 'optimal-cost)
eval1.c:	 (set! cost-fn optimal-cost))
eval1.c:						~%or the symbol 'optimal-cost"))))
eval1.c:	pc=pcFormula->pfForm->pcArgs;
eval1.c:	if(pc->pfForm->paAction->pfCompute==NoComputor)
eval1.c:		ErrorMessage("set-heuristic-fn:  Heuristic function must be a "
eval1.c:			"function or (optimal-cost).\n");
eval1.c:(define (get-Heuristic-fn)
eval1.c:  Heuristic-fn)
eval1.c:		pc=(*pcHeuristicFn->pfForm->paAction->pfCompute)(pcHeuristicFn,plpLinearPlan,pbBindings);
eval1.c:(define (reset-Heuristic-fn )
eval1.c:  (set! Heuristic-fn optimal-Heuristic))
eval1.c:(define (reset-Heuristic-fn )
eval1.c:  (set! Heuristic-fn optimal-Heuristic))
eval1.c:/* Priority Interface ---------------------------------------------------------- */
eval1.c:(define (set-priority-fn fn)
eval1.c:			(set! priority-fn fn))
eval1.c:		((eqv? fn 'best-action)
eval1.c:			(set! priority-fn best-action))
eval1.c:				or the symbol 'best-action"))))
eval1.c:	pc=pcFormula->pfForm->pcArgs;
eval1.c:	if(pc->pfForm->paAction->pfCompute!=ComputeDefFunction&&
eval1.c:		pc->pfForm->paAction->pfCompute!=ComputeBestAction)
eval1.c:		ErrorMessage("set-priority-fn:  Priority function must be a "
eval1.c:			"defined function or (best-action)\n");
eval1.c:(define (get-priority-fn )
eval1.c:  priority-fn)
eval1.c:(define (reset-priority-fn )
eval1.c:  (set! priority-fn best-action))
eval1.c:(define (reset-priority-fn )
eval1.c:  (set! priority-fn best-action))
eval1.c:/* Domain Interface ------------------------------------------------------------ */
eval1.c:(define (reset-domains )
eval1.c:(define (def-domain domain-name file-list description)
eval1.c:  (set! *domains* (cons (list domain-name file-list description) *domains*)))
eval1.c:	pcDomainEnd=pcDomainEnd->pcNext=pcFormula;
eval1.c:(define (list-domains)
eval1.c:  (for-each (lambda (domain)
eval1.c:(define (list-domains)
eval1.c:  (for-each (lambda (domain)
eval1.c:		CommandPrintf(stdout,"list-domains: There are no domains defined.\n");
eval1.c:	for(pc=pcDomainStart;pc;pc=pc->pcNext)
eval1.c:			GetName(pc->pfForm->pcArgs->pfForm,ac),
eval1.c:			GetName(pc->pfForm->pcArgs->pcNext->pfForm,ac));
eval1.c:(define (load-domain . optional-args)
eval1.c:  (let ((domain-name
eval1.c:	 (if (null? optional-args)
eval1.c:		 (first optional-args))))
eval1.c:	   (find domain-name *domains*
eval1.c:	  (for-each (lambda(file) (load file)) (second domain))
eval1.c:		(format #t "~%Unknown domain ~S." domain-name)
eval1.c:		(list-domains))))))
eval1.c:	psName=IdentName(pcFormula->pfForm->pcArgs->pfForm);
eval1.c:	for(pc=pcDomainStart;pc;pc=pc->pcNext)	// find the domain in the domain list
eval1.c:		if(StringEqQ(psName,IdentName(pc->pfForm->pcArgs->pfForm)))
eval1.c:		for(pc=pc->pfForm->pcArgs->pcNext->pcNext;pc;pc=pc->pcNext)
eval1.c:			LoadFile(GetName(pc->pfForm,ac));
eval1.c:/* -------------------------------------------------------------------------- */
eval1.c:	LoadFile(GetName(pcFormula->pfForm->pcArgs->pfForm,ac));
eval1.c:/* -------------------------------------------------------------------------- */
eval1.c:	LoadPddlProblem(GetName(pcFormula->pfForm->pcArgs->pfForm,ac));
eval1.c:/* Print World Interface ------------------------------------------------------- */
eval1.c:(define (set-print-world-fn fn)
eval1.c:  (set! print-world fn))
eval1.c:	pc=pcFormula->pfForm->pcArgs;
eval1.c:	psiPrint=GetSymbolInfoPtr(GetName(pc->pfForm,ac));
eval1.c:		ErrorMessage("set-print-world-fn:  Unknown print routine %s\n",
eval1.c:			GetName(pc->pfForm,ac));
eval1.c:	pcStream->pfForm=(FORMULAP)MemAlloc(sizeof(FORMULA));
eval1.c:	pcStream->pfForm->nType=ATOM_IDENT;
eval1.c:	pcStream->pfForm->psName=IdentAlloc("?stream");
eval1.c:	pcStream->pfForm->paAction=&aIdentAction;
eval1.c:(define (reset-print-world-fn )
eval1.c:  (set! print-world default-print-world))
eval1.c:(define (reset-print-world-fn )
eval1.c:  (set! print-world default-print-world))
eval1.c:	The first call to print-delta-time returns the time since the program was started.
eval1.c:	(print-delta-time <description>)
eval1.c:	if(pcFormula->pfForm->pcArgs)
eval1.c:		ps=IdentName(pcFormula->pfForm->pcArgs->pfForm);
eval1.c:		CommandPrintf(stderr,"%s%.3f\n",ps,dfCurrentTime-dfPreviousTime);
eval1.c:/* -------------------------------------------------------------------------- */
eval1.c:(define (declare-described-symbols symbol-info-list)
eval1.c:  (if (not (eqv? *number-of-world-symbols* 0))
eval1.c:			~%(clear-world-symbols) and try again."))
eval1.c:  (do ((symbol-info-item '()))
eval1.c:	  ((null? symbol-info-list))
eval1.c:	(set! symbol-info-item (first symbol-info-list))
eval1.c:	(set! symbol-info-list (rest symbol-info-list))
eval1.c:	(if (or (eqv? (second symbol-info-item) 'predicate)
eval1.c:		(eqv? (second symbol-info-item) 'function))
eval1.c:	(insert-symbol-info
eval1.c:	 (first symbol-info-item) (second symbol-info-item)
eval1.c:	 (third symbol-info-item) 'DESCRIBED)
eval1.c:	(error "In declare-described-symbols second item of symbol-info-item~
eval1.c:  (set! *number-of-described-symbols* (vector-length *world-symbols*)))
eval1.c:			"Call clear-world-symbols and try again.\n");
eval1.c:	for(pcType=pcFormula->pfForm->pcArgs;pcType;pcType=pcType->pcNext)
eval1.c:		if(StringEqQ(IdentName(pcType->pfForm),apsStringTab[STRING_PREDICATE])||
eval1.c:			StringEqQ(IdentName(pcType->pfForm),apsStringTab[STRING_FUNCTION]))
eval1.c:			nType=StringToSymbolType(GetName(pcType->pfForm,ac));
eval1.c:			pcName=pcType->pfForm->pcArgs;
eval1.c:				ErrorMessage("declare-described-symbols: %s missing name and arity\n",
eval1.c:					GetName(pcType->pfForm,ac));
eval1.c:			if(Reserved(GetName(pcName->pfForm,ac)))
eval1.c:				ErrorMessage("declare-described-symbols: %s is a reserved symbol, "
eval1.c:					GetName(pcName->pfForm,ac));
eval1.c:			pcArity=pcName->pcNext;
eval1.c:				ErrorMessage("declare-described-symbols: %s missing arity.\n",
eval1.c:					GetName(pcName->pfForm,ac));
eval1.c:				ErrorMessage("declare-described-symbols: Arity must be a valid integer.\n",
eval1.c:					GetName(pcName->pfForm,ac));
eval1.c:			for(pcExtra=pcArity->pcNext;pcExtra;pcExtra=pcExtra->pcNext)
eval1.c:				if(StringEqQ(IdentName(pcExtra->pfForm),apsStringTab[STRING_NO_CYCLE_CHECK]))
eval1.c:				else if(StringEqQ(IdentName(pcExtra->pfForm),apsStringTab[STRING_REWRITABLE]))
eval1.c:						ErrorMessage("declare-described-symbols: Only described predicate can be rewritable: %s\n",
eval1.c:							GetName(pcName->pfForm,ac));
eval1.c:					ErrorMessage("declare-described-symbols: Unknown trailing keyword \"%s\" in declaration of %s\n",
eval1.c:						GetName(pcExtra->pfForm,ac),GetName(pcName->pfForm,ac));
eval1.c:				InsertSymbolInfo(GetName(pcName->pfForm,ac),nType,nArity,EVAL_DESCRIBED,
eval1.c:				InsertSymbolInfo(GetName(pcName->pfForm,ac),nType,nArity,EVAL_DESCRIBED,
eval1.c:			ErrorMessage("declare-described-symbols:  Each declaration must begin "
eval1.c:		for(pcType=pcFormula->pfForm->pcArgs;pcType;pcType=pcType->pcNext)
eval1.c:			pcName=pcType->pfForm->pcArgs;
eval1.c:			pcArity=pcName->pcNext;
eval1.c:			for(pcExtra=pcArity->pcNext;pcExtra;pcExtra=pcExtra->pcNext)
eval1.c:				if(StringEqQ(IdentName(pcExtra->pfForm),apsStringTab[STRING_NO_CYCLE_CHECK]))
eval1.c:				else if(StringEqQ(IdentName(pcExtra->pfForm),apsStringTab[STRING_REWRITABLE]))
eval1.c:				nType=StringToSymbolType(GetName(pcType->pfForm,ac));
eval1.c:					InsertSymbolInfo(GetName(pcName->pfForm,ac),nType,nArity,EVAL_DESCRIBED,
eval1.c:					InsertSymbolInfo(GetName(pcName->pfForm,ac),nType,nArity,EVAL_DESCRIBED,
eval1.c:		plpCurrentPlan->apbtWorld=MakeWorld();
eval1.c:	for(pcType=pcFormula->pfForm->pcArgs;pcType;pcType=pcType->pcNext)
eval1.c:		if(StringEqQ(IdentName(pcType->pfForm),apsStringTab[STRING_PREDICATE])||
eval1.c:			StringEqQ(IdentName(pcType->pfForm),apsStringTab[STRING_FUNCTION])||
eval1.c:			StringEqQ(IdentName(pcType->pfForm),apsStringTab[STRING_GENERATOR]))
eval1.c:			pcName=pcType->pfForm->pcArgs;
eval1.c:				ErrorMessage("declare-defined-symbols: %s missing name and arity\n",
eval1.c:					GetName(pcType->pfForm,ac));
eval1.c:			if(Reserved(GetName(pcName->pfForm,ac)))
eval1.c:				ErrorMessage("declare-defined-symbols: %s is a reserved symbol, "
eval1.c:					GetName(pcName->pfForm,ac));
eval1.c:			pcArity=pcName->pcNext;
eval1.c:				ErrorMessage("declare-defined-symbols: %s missing arity.\n",
eval1.c:					GetName(pcName->pfForm,ac));
eval1.c:				ErrorMessage("declare-defined-symbols: Arity must be a valid integer.\n",
eval1.c:					GetName(pcName->pfForm,ac));
eval1.c:			nType=StringToSymbolType(GetName(pcType->pfForm,ac));
eval1.c:				InsertSymbolInfo(GetName(pcName->pfForm,ac),nType,nArity,EVAL_DEFINED,
eval1.c:				InsertSymbolInfo(GetName(pcName->pfForm,ac),nType,nArity,EVAL_DEFINED,
eval1.c:				InsertSymbolInfo(GetName(pcName->pfForm,ac),nType,nArity,EVAL_DEFINED,
eval1.c:			ErrorMessage("declare-defined-symbols:  Each declaration must begin "
eval1.c:	"domain-global" -- variables are initialized once only (now), 
eval1.c:	"search-global" -- variables are initialized by the planner.
eval1.c:	"world-global" -- variables belong to each world and are initialized each time
eval1.c:	for(pcEnd=(CELLP)&pcSearchGlobalInit;pcEnd->pcNext;pcEnd=pcEnd->pcNext);
eval1.c:	for(pcType=pcFormula->pfForm->pcArgs;pcType;pcType=pcType->pcNext)
eval1.c:		if(StringEqQ(IdentName(pcType->pfForm),apsStringTab[STRING_DOMAIN_GLOBAL])||
eval1.c:			StringEqQ(IdentName(pcType->pfForm),apsStringTab[STRING_SEARCH_GLOBAL])||
eval1.c:			StringEqQ(IdentName(pcType->pfForm),apsStringTab[STRING_WORLD_GLOBAL]))
eval1.c:			pc=pcType->pfForm->pcArgs;
eval1.c:				ErrorMessage("declare-global-variables: %s missing name and value.\n",
eval1.c:					GetName(pcType->pfForm,ac));
eval1.c:			if(*GetName(pc->pfForm,ac)!='?')
eval1.c:				ErrorMessage("declare-global-variables: %s does not have a leading '?'.\n",
eval1.c:					GetName(pc->pfForm,ac));
eval1.c:			pc=pc->pcNext;
eval1.c:				ErrorMessage("declare-global-variables: %s missing value.\n",
eval1.c:					GetName(pcVar->pfForm,ac));
eval1.c:			if(StringEqQ(IdentName(pcType->pfForm),apsStringTab[STRING_DOMAIN_GLOBAL]))
eval1.c:					TermError("declare-global-variable",pc,pbBindings);
eval1.c:				if(pcVar->pfForm->pcArgs)	/* if array */
eval1.c:			else if(StringEqQ(IdentName(pcType->pfForm),apsStringTab[STRING_SEARCH_GLOBAL]))
eval1.c:				if(pcVar->pfForm->pcArgs)	/* if array */
eval1.c:				pcEnd=pcEnd->pcNext=MakeSearchGlobalInitializationForm(FALSE,pcVar,pcVal);
eval1.c:			else if(StringEqQ(IdentName(pcType->pfForm),apsStringTab[STRING_WORLD_GLOBAL]))
eval1.c:				ErrorMessage("declare-global-variables:  World-global variables not supported (yet).\n");
eval1.c:				ErrorMessage("declare-global-variables:  Unexpected variable type %s.\n",
eval1.c:					GetName(pcType->pfForm,ac));
eval1.c:			ErrorMessage("declare-global-variables:  Each declaration must begin "
eval1.c:	(declare-external-symbols "file"
eval1.c:	name is the external (lisp-like) name of the routine
eval1.c:	libref is the internal (c-like) name of the routine
eval1.c:	pcPath=pcFormula->pfForm->pcArgs;
eval1.c:	if(!NewLibrary(GetName(pcPath->pfForm,ac),&nHandle))
eval1.c:	for(pcType=pcPath->pcNext;pcType;pcType=pcType->pcNext)
eval1.c:		if(StringEqQ(IdentName(pcType->pfForm),apsStringTab[STRING_PREDICATE])||
eval1.c:			StringEqQ(IdentName(pcType->pfForm),apsStringTab[STRING_FUNCTION])||
eval1.c:			StringEqQ(IdentName(pcType->pfForm),apsStringTab[STRING_GENERATOR])||
eval1.c:			StringEqQ(IdentName(pcType->pfForm),apsStringTab[STRING_MACRO]))
eval1.c:			pcName=pcType->pfForm->pcArgs;
eval1.c:				ErrorMessage("declare-external-symbols: %s missing name, libref and arity\n",
eval1.c:					GetName(pcType->pfForm,ac));
eval1.c:			if(Reserved(GetName(pcName->pfForm,ac)))
eval1.c:				ErrorMessage("declare-external-symbols: %s is a reserved symbol, "
eval1.c:					GetName(pcName->pfForm,ac));
eval1.c:			pcLibRef=pcName->pcNext;
eval1.c:				ErrorMessage("declare-external-symbols: %s missing libref and arity\n",
eval1.c:					GetName(pcName->pfForm,ac));
eval1.c:				ErrorMessage("declare-external-symbols: %s must be specified as a quoted string\n",
eval1.c:					GetName(pcLibRef->pfForm,ac));
eval1.c:			pcArity=pcLibRef->pcNext;
eval1.c:				ErrorMessage("declare-external-symbols: %s missing arity.\n",
eval1.c:					GetName(pcName->pfForm,ac));
eval1.c:				ErrorMessage("declare-external-symbols: %s arity must be a valid integer.\n",
eval1.c:					GetName(pcName->pfForm,ac));
eval1.c:			nType=StringToSymbolType(GetName(pcType->pfForm,ac));
eval1.c:					if(GetLibSymbol(nHandle,GetName(pcLibRef->pfForm,ac),(void **)&pfFunction))
eval1.c:						InsertSymbolInfo(GetName(pcName->pfForm,ac),nType,nArity,
eval1.c:						GetName(pcType->pfForm,ac));
eval1.c:			ErrorMessage("declare-external-symbols:  Each declaration must begin "
eval1.c:	for(pcName=pcFormula->pfForm->pcArgs;pcName;pcName=pcName->pcNext)
eval1.c:		if(Reserved(GetName(pcName->pfForm,ac)))
eval1.c:			ErrorMessage("declare-macro-operators: %s is a reserved symbol, "
eval1.c:				GetName(pcName->pfForm,ac));
eval1.c:		pcDomain=pcName->pfForm->pcArgs;
eval1.c:			ErrorMessage("declare-macro-operators: %s missing domain file path\n",
eval1.c:				GetName(pcName->pfForm,ac));
eval1.c:		pcGoal=pcDomain->pcNext;
eval1.c:			ErrorMessage("declare-macro-operators: %s missing goal formula\n",
eval1.c:				GetName(pcName->pfForm,ac));
eval1.c:		AddMacroOperator(GetName(pcName->pfForm,ac),GetName(pcDomain->pfForm,ac),pcGoal);
eval1.c:	for(pcName=pcFormula->pfForm->pcArgs;pcName;pcName=pcName->pcNext)
eval1.c:		if(Reserved(GetName(pcName->pfForm,ac)))
eval1.c:			ErrorMessage("declare-elided-operators: %s is a reserved symbol, "
eval1.c:				GetName(pcName->pfForm,ac));
eval1.c:		AddElidedOperator(GetName(pcName->pfForm,ac));
eval1.c:/* Symbol Definitions ---------------------------------------------------------- */
eval1.c:	pcName=pcFormula->pfForm->pcArgs;
eval1.c:	if(Reserved(GetName(pcName->pfForm,ac)))
eval1.c:			GetName(pcName->pfForm,ac));
eval1.c:	pcValue=pcName->pcNext;
eval1.c:	if(SymbolLookup(GetName(pcName->pfForm,ac),&psSymbol))
eval1.c:		Message("define:  Redefining macro symbol %s\n",GetName(pcName->pfForm,ac));
eval1.c:		psSymbol->nType=ATOM_FORMULAP;
eval1.c:		psSymbol->uValue.pcFormula=pcValue;
eval1.c:	InsertSymbolInfo(GetName(pcName->pfForm,ac),SYMBOL_MACRO,0,EVAL_DESCRIBED,
eval1.c:(define-macro (def-defined-predicate name parameters formula)
eval1.c:  `(insert-symbol-info
eval1.c:	pcName=pcFormula->pfForm->pcArgs;
eval1.c:	if(Reserved(GetName(pcName->pfForm,ac)))
eval1.c:		ErrorMessage("def-defined-predicate: %s is a reserved symbol, "
eval1.c:			GetName(pcName->pfForm,ac));
eval1.c:	pcArguments=pcName->pfForm->pcArgs;
eval1.c:	pcLocals=pcName->pcNext;
eval1.c:	if(StringEqQ(IdentName(pcLocals->pfForm),apsStringTab[STRING_LOCAL_VARS]))
eval1.c:		pcForm=pcLocals->pcNext;
eval1.c:		pcLocals=pcLocals->pfForm->pcArgs;
eval1.c:	for(pc=pcArguments;pc;pc=pc->pcNext)
eval1.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
eval1.c:	pf->psName=IdentName(pcName->pfForm);
eval1.c:	pf->paAction=&aDefPredicateAction;
eval1.c:	pf->pcVars=pcArguments;
eval1.c:	pf->pcGenLit=pcLocals;
eval1.c:	pf->pcArgs=pcForm;
eval1.c:	/* install predicate in symbol-info table (if it isn't there already) */
eval1.c:	if(SymbolLookup(GetName(pcName->pfForm,ac),&psSymbol))	/* if symbol already declared */
eval1.c:		if(psSymbol->nType==ATOM_SYMBOLINFOP)
eval1.c:			psiSymbolInfo=psSymbol->uValue.psiSymbolInfo;
eval1.c:			if(psiSymbolInfo->pcFormula)
eval1.c:				ErrorMessage("def-defined-predicate:  Predicate %s already defined\n",
eval1.c:					GetName(pcName->pfForm,ac));
eval1.c:				if(psiSymbolInfo->nArity!=nLength)
eval1.c:						"def-defined-predicate:  %s arity declared as %d, defined as %d\n",
eval1.c:						psiSymbolInfo->psName,psiSymbolInfo->nArity,nLength);
eval1.c:				if(psiSymbolInfo->nSymbolType!=SYMBOL_PREDICATE)
eval1.c:						"def-defined-predicate:  %s defined as predicate, declared as non-predicate\n",
eval1.c:						psiSymbolInfo->psName);
eval1.c:				psiSymbolInfo->pcFormula=pc;
eval1.c:			ErrorMessage("def-defined-predicate:  Symbol %s already defined\n",
eval1.c:				GetName(pcName->pfForm,ac));
eval1.c:		InsertSymbolInfo(GetName(pcName->pfForm,ac),SYMBOL_PREDICATE,nLength,EVAL_DEFINED,
eval1.c:	pcName=pcFormula->pfForm->pcArgs;
eval1.c:	if(Reserved(GetName(pcName->pfForm,ac)))
eval1.c:		ErrorMessage("def-defined-generator: %s is a reserved symbol, "
eval1.c:			GetName(pcName->pfForm,ac));
eval1.c:	pcArguments=pcName->pfForm->pcArgs;
eval1.c:	pcLocals=pcName->pcNext;
eval1.c:	if(StringEqQ(IdentName(pcLocals->pfForm),apsStringTab[STRING_LOCAL_VARS]))
eval1.c:		pcForm=pcLocals->pcNext;
eval1.c:		pcLocals=pcLocals->pfForm->pcArgs;
eval1.c:	for(pc=pcArguments;pc;pc=pc->pcNext)
eval1.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
eval1.c:	pf->psName=IdentName(pcName->pfForm);
eval1.c:	pf->paAction=&aDefGeneratorAction;
eval1.c:	pf->pcVars=pcArguments;
eval1.c:	pf->pcGenLit=pcLocals;
eval1.c:	pf->pcArgs=pcForm;
eval1.c:	/* install generator in symbol-info table (if it isn't there already) */
eval1.c:	if(SymbolLookup(GetName(pcName->pfForm,ac),&psSymbol))	/* if symbol already declared */
eval1.c:		if(psSymbol->nType==ATOM_SYMBOLINFOP)
eval1.c:			psiSymbolInfo=psSymbol->uValue.psiSymbolInfo;
eval1.c:			if(psiSymbolInfo->pcFormula)
eval1.c:				ErrorMessage("def-defined-generator:  Generator %s already defined\n",
eval1.c:					GetName(pcName->pfForm,ac));
eval1.c:				if(psiSymbolInfo->nArity!=nLength)
eval1.c:						"def-defined-generator:  %s arity declared as %d, defined as %d\n",
eval1.c:						psiSymbolInfo->psName,psiSymbolInfo->nArity,nLength);
eval1.c:				if(psiSymbolInfo->nSymbolType!=SYMBOL_GENERATOR)
eval1.c:						"def-defined-generator:  %s defined as generator, declared as non-generator\n",
eval1.c:						psiSymbolInfo->psName);
eval1.c:				psiSymbolInfo->pcFormula=pc;
eval1.c:			ErrorMessage("def-defined-generator:  Symbol %s already defined\n",
eval1.c:				GetName(pcName->pfForm,ac));
eval1.c:		InsertSymbolInfo(GetName(pcName->pfForm,ac),SYMBOL_GENERATOR,nLength,EVAL_DEFINED,
eval1.c:	pcName=pcFormula->pfForm->pcArgs;
eval1.c:	if(Reserved(GetName(pcName->pfForm,ac)))
eval1.c:		ErrorMessage("def-defined-function: %s is a reserved symbol, "
eval1.c:			GetName(pcName->pfForm,ac));
eval1.c:	pcArguments=pcName->pfForm->pcArgs;
eval1.c:	pcLocals=pcName->pcNext;
eval1.c:	if(StringEqQ(IdentName(pcLocals->pfForm),apsStringTab[STRING_LOCAL_VARS]))
eval1.c:		pcForm=pcLocals->pcNext;
eval1.c:		pcLocals=pcLocals->pfForm->pcArgs;
eval1.c:	for(pc=pcArguments;pc;pc=pc->pcNext)
eval1.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
eval1.c:	pf->psName=IdentName(pcName->pfForm);
eval1.c:	pf->paAction=&aDefFunctionAction;
eval1.c:	pf->pcVars=pcArguments;
eval1.c:	pf->pcGenLit=pcLocals;
eval1.c:	pf->pcArgs=pcForm;
eval1.c:	/* install function in symbol-info table (if it isn't there already) */
eval1.c:	if(SymbolLookup(GetName(pcName->pfForm,ac),&psSymbol))
eval1.c:		if(psSymbol->nType==ATOM_SYMBOLINFOP)
eval1.c:			psiSymbolInfo=psSymbol->uValue.psiSymbolInfo;
eval1.c:			if(psiSymbolInfo->pcFormula)
eval1.c:				ErrorMessage("def-defined-function:  Function %s already defined\n",
eval1.c:					GetName(pcName->pfForm,ac));
eval1.c:				if(psiSymbolInfo->nArity!=nLength)
eval1.c:						"def-defined-function:  %s arity declared as %d, defined as %d\n",
eval1.c:						psiSymbolInfo->psName,psiSymbolInfo->nArity,nLength);
eval1.c:				if(psiSymbolInfo->nSymbolType!=SYMBOL_FUNCTION)
eval1.c:						"def-defined-function:  %s defined as function, declared as non-function\n",
eval1.c:						psiSymbolInfo->psName);
eval1.c:				psiSymbolInfo->pcFormula=pc;
eval1.c:			ErrorMessage("def-defined-function:  Symbol %s already defined\n",
eval1.c:				GetName(pcName->pfForm,ac));
eval1.c:		InsertSymbolInfo(GetName(pcName->pfForm,ac),SYMBOL_FUNCTION,nLength,EVAL_DEFINED,
eval1.c:	pcName=pcFormula->pfForm->pcArgs;
eval1.c:	if(Reserved(GetName(pcName->pfForm,ac)))
eval1.c:		ErrorMessage("def-defined-macro: %s is a reserved symbol, "
eval1.c:			GetName(pcName->pfForm,ac));
eval1.c:	pcArguments=pcName->pfForm->pcArgs;
eval1.c:	pcLocals=pcName->pcNext;
eval1.c:	if(StringEqQ(IdentName(pcLocals->pfForm),apsStringTab[STRING_LOCAL_VARS]))
eval1.c:		pcForm=pcLocals->pcNext;
eval1.c:		pcLocals=pcLocals->pfForm->pcArgs;
eval1.c:	for(pc=pcArguments;pc;pc=pc->pcNext)
eval1.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
eval1.c:	pf->psName=IdentName(pcName->pfForm);
eval1.c:	pf->paAction=&aDefMacroAction;
eval1.c:	pf->pcVars=pcArguments;
eval1.c:	pf->pcGenLit=pcLocals;
eval1.c:	pf->pcArgs=pcForm;
eval1.c:	/* install macro in symbol-info table (if it isn't there already) */
eval1.c:	if(SymbolLookup(GetName(pcName->pfForm,ac),&psSymbol))
eval1.c:		if(psSymbol->nType==ATOM_SYMBOLINFOP)
eval1.c:			psiSymbolInfo=psSymbol->uValue.psiSymbolInfo;
eval1.c:			if(psiSymbolInfo->pcFormula)
eval1.c:				ErrorMessage("def-defined-macro:  Macro %s already defined\n",
eval1.c:					GetName(pcName->pfForm,ac));
eval1.c:				if(psiSymbolInfo->nArity!=nLength)
eval1.c:						"def-defined-macro:  %s arity declared as %d, defined as %d\n",
eval1.c:						psiSymbolInfo->psName,psiSymbolInfo->nArity,nLength);
eval1.c:				if(psiSymbolInfo->nSymbolType!=SYMBOL_MACRO)
eval1.c:						"def-defined-macro:  %s defined as macro, declared as non-macro\n",
eval1.c:						psiSymbolInfo->psName);
eval1.c:				psiSymbolInfo->pcFormula=pc;
eval1.c:			ErrorMessage("def-defined-macro:  Symbol %s already defined\n",
eval1.c:				GetName(pcName->pfForm,ac));
eval1.c:		InsertSymbolInfo(GetName(pcName->pfForm,ac),SYMBOL_MACRO,nLength,EVAL_DEFINED,
eval1.c:/* -------------------------------------------------------------------------- */
eval1.c:(define (clear-world-symbols)
eval1.c:      ((>= i *number-of-described-symbols*))
eval1.c:	(put-symbol-index (get-symbol-name i) '()))
eval1.c:  (set! *world-symbols* (make-vector 0))
eval1.c:  (set! *number-of-world-symbols* 0)
eval1.c:  (set! *number-of-described-symbols* 0)
eval1.c:  (reset-tl-control)
eval1.c:  (reset-print-world-fn))
eval1.c:	plpCurrentPlan->apbtWorld=NULL;
eval1.c:	if(!FormulaToInteger(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings,&nFile))
eval1.c:		ErrorMessage("print-plan-list:  Invalid file handle, %d\n",nFile);
eval1.c:		for(plp=plpLinearPlan;plp->pcActionName;plp=plp->plpParent)
eval1.c:			pc=CopyCell(plp->pcActionName);
eval1.c:			pc->pcNext=pcPrev;
eval1.c:		for(;pc;pc=pc->pcNext)
eval1.c:/* Initial World Interface -------------------------------------------------- */
eval1.c:(define (set-initial-world  world-list)
eval1.c:  (set! initial-world/action
eval1.c:	(make-world/action (create-world world-list) '() 0 0 0))
eval1.c:  world-list)
eval1.c:		ErrorMessage("set-initial-world: No described symbols declared.  "
eval1.c:			"Call declare-described-symbols first.\n");
eval1.c:	pcStart=pcFormula->pfForm->pcArgs;
eval1.c:	non-described function instead of a list of described
eval1.c:	if(pcStart&&pcStart->pfForm->nType==ATOM_SYMBOLINFOP&&
eval1.c:		!DescribedQ(pcStart->pfForm->uValue.psiSymbolInfo)&&
eval1.c:		FunctionQ(pcStart->pfForm->uValue.psiSymbolInfo))
eval1.c:		pcStart=(*pcStart->pfForm->paAction->pfCompute)(pcStart,plpLinearPlan,pbBindings);
eval1.c:	for(pcEnd=(CELLP)&pcStart;pcEnd->pcNext;pcEnd=pcEnd->pcNext);
eval1.c:	pcEnd->pcNext=CopyCellList(pcInitialFacts);
eval1.c://	dfInitializationTime=GetInternalRunTime()-dfInitializationTime;
eval1.c://	dfInitializationTime=GetInternalRunTime()-dfInitializationTime;
eval1.c:		plpInitialWorld->apbtWorld[i]=BTreeBalance(plpInitialWorld->apbtWorld[i]);
eval1.c:		ErrorMessage("set-initialization-sequence: No described symbols declared.  "
eval1.c:			"Call declare-described-symbols first.\n");
eval1.c://	for(pc=(CELLP)&pcInitializationSequence;pc->pcNext;pc=pc->pcNext);
eval1.c://	pc->pcNext=pcFormula->pfForm->pcArgs;	/* set initialization list */
eval1.c:	// debug -- prefix the list instead
eval1.c:	for(pc=pcFormula->pfForm->pcArgs;pc->pcNext;pc=pc->pcNext);
eval1.c:	pc->pcNext=pcInitializationSequence;
eval1.c:	pcInitializationSequence=pcFormula->pfForm->pcArgs;
eval1.c:		ErrorMessage("set-initial-facts: No described symbols declared.  "
eval1.c:			"Call declare-described-symbols first.\n");
eval1.c:	pcInitialFacts=pcFormula->pfForm->pcArgs;	/* set initializer list */
eval1.c:(define (get-initial-world )
eval1.c:  initial-world/action)
eval1.c:/* Goal Interface -------------------------------------------------------------- */
eval1.c:(define process-goal process-classic-goal)
eval1.c:(define initial-world/action '())
eval1.c:(define goal-list '())
eval1.c:(define initial-time 0)
eval1.c:(define goal-type 'classic)
eval1.c:(define plan= plan-classic=)
eval1.c:		(*pcGoalFormula->pfForm->paAction->pfEval)(pcGoalFormula,plpLinearPlan,pbGlobalVariables):TRUE;
eval1.c:(define (process-classic-goal goal-list)
eval1.c:	(create-goal-world/action goal-list)
eval1.c:	(set! final-world-goal?
eval1.c:			(eval-formula `(and ,@goal-list) world/action '()))))
eval1.c:		plpGoalWorld->apbtWorld[i]=BTreeBalance(plpGoalWorld->apbtWorld[i]);
eval1.c:	if(!pcFormula||!pcFormula->pcNext)
eval1.c:The function that does this is part of the progress-formula code.
eval1.c:(define (process-extended-goal goal-formula)
eval1.c:  (set-tl-control goal-formula)
eval1.c:  (set! final-world-goal? (lambda (tlform world/action)
eval1.c:		(idle-formula tlform world/action '()))))
eval1.c:(define (set-goal-type type)
eval1.c:	(set! goal-type 'classic)
eval1.c:	(set! plan= plan-classic=)
eval1.c:	(set! process-goal process-classic-goal))
eval1.c:	(set! goal-type 'extended)
eval1.c:	(set! plan= plan-extended=)
eval1.c:	(set! process-goal process-extended-goal))
eval1.c:	(set! process-goal process-classic-goal))))
eval1.c:	pc=pcFormula->pfForm->pcArgs;
eval1.c:	if(StringEqQ(IdentName(pc->pfForm),apsStringTab[STRING_EXTENDED]))
eval1.c:		if(!StringEqQ(IdentName(pc->pfForm),apsStringTab[STRING_CLASSIC]))
eval1.c:(define (set-goal goal)
eval1.c:	(set! goal-list goal)
eval1.c:	(process-goal goal)
eval1.c:	goal-list)
eval1.c:		ErrorMessage("set-goal:  No described symbols declared.  "
eval1.c:			"Call declare-described-symbols first.\n");
eval1.c:	pc=pcFormula->pfForm->pcArgs;
eval1.c:	non-described function instead of a list of described
eval1.c:	if(pc&&pc->pfForm->nType==ATOM_SYMBOLINFOP&&
eval1.c:		!DescribedQ(pc->pfForm->uValue.psiSymbolInfo)&&
eval1.c:		FunctionQ(pc->pfForm->uValue.psiSymbolInfo))
eval1.c:		pc=(*pc->pfForm->paAction->pfCompute)(pc,plpLinearPlan,pbBindings);
eval1.c:		ErrorMessage("set-goal-formula:  No described symbols declared.  "
eval1.c:			"Call declare-described-symbols first.\n");
eval1.c:		ErrorMessage("set-goal-formula:  Cannot generate a goal formula for non-classic goal.\n");
eval1.c:		pcEnd->pcNext=ArgTreeToFormulaList(apbtWorld,i);
eval1.c:		for(;pcEnd->pcNext;pcEnd=pcEnd->pcNext);
eval1.c:	if(pcStart&&pcStart->pcNext)
eval1.c:		ErrorMessage("set-goal-sequence: No described symbols declared.  "
eval1.c:			"Call declare-described-symbols first.\n");
eval1.c:		ErrorMessage("set-goal-sequence:  Cannot process a goal sequence for non-classic goal.\n");
eval1.c:	for(pc=(CELLP)&pcGoalSequence;pc->pcNext;pc=pc->pcNext);
eval1.c:	pc->pcNext=pcFormula->pfForm->pcArgs;	/* set initialization list */
eval1.c:/* TLControl Interface --------------------------------------------------------- */
eval1.c:(define (set-tl-control formula)
eval1.c:	pcTLForm=pcFormula->pfForm->pcArgs;
eval1.c:(define (get-tl-control )
eval1.c:(define (reset-tl-control)
eval1.c:(define (reset-tl-control)
eval1.c:/* EvalLoadPlan -------------------------------------------------------------------
eval1.c:			ErrorMessage("load-plan:  Symbol %s has unknown type\n",
eval1.c:			ErrorMessage("load-plan:  Symbol %s is undefined\n",
eval1.c:		ErrorMessage("load-plan:  Ensure all predicates, functions and generators ",
eval1.c:			"are correctly defined\nbefore calling load-plan.\n");
eval1.c:		ErrorMessage("load-plan:  %d Error%s encountered.\n"
eval1.c:			"Please correct any problems and call clear-world-symbols before proceeding.\n",
eval1.c:		ErrorMessage("load-plan:  No initial world.\n"
eval1.c:			"Please call set-initial-world before proceeding.\n");
eval1.c:	pcPredefinedPlan=pcFormula->pfForm->pcArgs;
eval1.c:	if(plpCurrentPlan->plpNext)
eval1.c:		plpCurrentPlan=plpCurrentPlan->plpNext;
eval1.c:	if(plpCurrentPlan->plpParent)
eval1.c:		plpCurrentPlan=plpCurrentPlan->plpParent;
eval.c:Copyright C, 1996 - 2001, F. Bacchus
eval.c:--------------------------------------------------------------------------------
eval.c:/* Evaluators ------------------------------------------------------------------ */
eval.c:(define (eval-def-predicate index args world/action)
eval.c:  (let* ((df (get-symbol-eval-object index))
eval.c:		 (bindings (extend-bindings (get-def-parameters df) args '())))
eval.c:	(eval-formula (get-def-formula df) world/action bindings)))
eval.c:	psiSymbolInfo=pcFormula->pfForm->uValue.psiSymbolInfo;
eval.c:	if(!psiSymbolInfo->pcFormula)
eval.c:		ErrorMessage("Eval-def-predicate:  Undefined predicate \"%s\".\n",psiSymbolInfo->psName);
eval.c:	if(pcFormula->pfForm->pcArgs)
eval.c:		pcTerms=ComputeTerms(pcFormula->pfForm->pcArgs,plpLinearPlan,pb);
eval.c:			TermError("eval-def-predicate",pcFormula,pb);
eval.c:	b=(*pc->pfForm->paAction->pfEval)(pc,plpLinearPlan,pb);
eval.c://	if(!stricmp(psiSymbolInfo->psName,"ok-to-turn"))
eval.c://		CommandPrintf(pfTraceStream,"%s ",psiSymbolInfo->psName);
eval.c:(define (eval-true args world/action bindings)
eval.c:(define (eval-false args world/action bindings)
eval.c:(define (eval-and args world/action bindings)
eval.c:  (every (lambda (formula) (eval-formula formula world/action bindings))
eval.c:	for(pc=pcFormula->pfForm->pcArgs;pc;pc=pc->pcNext)
eval.c:		if(!(*pc->pfForm->paAction->pfEval)(pc,plpLinearPlan,pbBindings))
eval.c:(define (eval-or args world/action bindings)
eval.c:  (some (lambda (formula) (eval-formula formula world/action bindings))
eval.c:	for(pc=pcFormula->pfForm->pcArgs;pc;pc=pc->pcNext)
eval.c:		if((*pc->pfForm->paAction->pfEval)(pc,plpLinearPlan,pbBindings))
eval.c:(define (eval-xor args world/action bindings)
eval.c:	  ((loop (lambda (forms found-one)
eval.c:		   (cond ((null? forms) found-one)
eval.c:			 ((eval-formula (first forms) world/action bindings)
eval.c:			  (if found-one #f (loop (rest forms) #t)))
eval.c:			 (else (loop (rest forms) found-one))))))
eval.c:	for(pc=pcFormula->pfForm->pcArgs;pc;pc=pc->pcNext)
eval.c:		if((*pc->pfForm->paAction->pfEval)(pc,plpLinearPlan,pbBindings))
eval.c:(define (eval-implies args world/action bindings)
eval.c:  (if (eval-formula (first args) world/action bindings)
eval.c:	  (eval-formula (second args) world/action bindings)
eval.c:	pc=pcFormula->pfForm->pcArgs;
eval.c:	if((*pc->pfForm->paAction->pfEval)(pc,plpLinearPlan,pbBindings))
eval.c:		pc=pc->pcNext;
eval.c:		b=(*pc->pfForm->paAction->pfEval)(pc,plpLinearPlan,pbBindings);
eval.c:(define (eval-if-then-else args world/action bindings)
eval.c:  (if (eval-formula (first args) world/action bindings)
eval.c:	  (eval-formula (second args) world/action bindings)
eval.c:	(eval-formula (third args) world/action bindings)))
eval.c:	pc=pcFormula->pfForm->pcArgs;
eval.c:	if((*pc->pfForm->paAction->pfEval)(pc,plpLinearPlan,pbBindings))
eval.c:		pc=pc->pcNext;
eval.c:		b=(*pc->pfForm->paAction->pfEval)(pc,plpLinearPlan,pbBindings);
eval.c:		pc=pc->pcNext->pcNext;
eval.c:		b=(*pc->pfForm->paAction->pfEval)(pc,plpLinearPlan,pbBindings);
eval.c:(define (eval-not args world/action bindings)
eval.c:  (not (eval-formula (first args) world/action bindings)))
eval.c:	pc=pcFormula->pfForm->pcArgs;
eval.c:	b=!(*pc->pfForm->paAction->pfEval)(pc,plpLinearPlan,pbBindings);
eval.c:(define (eval-= args world/action bindings)
eval.c:  (eqv? (eval-term (first args) world/action bindings)
eval.c:	(eval-term (second args) world/action bindings)))
eval.c:	pc1=ComputeTerm(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings);
eval.c:		TermError("eval-eq",pcFormula,pbBindings);
eval.c:	pc2=ComputeTerm(pcFormula->pfForm->pcArgs->pcNext,plpLinearPlan,pbBindings);
eval.c:		TermError("eval-eq",pcFormula,pbBindings);
eval.c:(define (eval-forall args world/action bindings)
eval.c:	(let* ((variables (get-qf-variables args))
eval.c:			(gen-lit (get-qf-generator args))
eval.c:			(formula (get-qf-formula args))
eval.c:		(set! bindings (extend-bindings variables variables bindings))
eval.c:			(make-generator gen-lit variables world/action bindings))
eval.c:						(if (not (eval-formula formula world/action bindings))
eval.c:	pcVars=pcFormula->pfForm->pcVars;
eval.c:	pcGenLit=pcFormula->pfForm->pcGenLit;
eval.c:	pcArgs=pcFormula->pfForm->pcArgs;
eval.c:	while((*pcGenLit->pfForm->paAction->pfGenerator)
eval.c:		if(!(*pcArgs->pfForm->paAction->pfEval)(pcArgs,plpLinearPlan,pbBindings))
eval.c:(define (eval-exists args world/action bindings)
eval.c:	(let* ((variables (get-qf-variables args))
eval.c:			(gen-lit (get-qf-generator args))
eval.c:			(formula (get-qf-formula args))
eval.c:		(set! bindings (extend-bindings variables variables bindings))
eval.c:		(set! generator (make-generator gen-lit variables world/action bindings))
eval.c:								(eval-formula formula world/action bindings))
eval.c:	pcVars=pcFormula->pfForm->pcVars;
eval.c:	pcGenLit=pcFormula->pfForm->pcGenLit;
eval.c:	pc=pcFormula->pfForm->pcArgs;
eval.c:	while((*pcGenLit->pfForm->paAction->pfGenerator)
eval.c:		if(!pc||(*pc->pfForm->paAction->pfEval)(pc,plpLinearPlan,pbBindings))
eval.c:(define (eval-exists! args world/action bindings)
eval.c:  (let* ((variables (get-qf-variables args))
eval.c:		 (gen-lit   (get-qf-generator args))
eval.c:		 (formula   (get-qf-formula args))
eval.c:	(set! bindings (extend-bindings variables variables bindings))
eval.c:	  (make-generator gen-lit variables world/action bindings))
eval.c:			 (found-one? #f))
eval.c:			  (eval-formula formula world/action bindings))
eval.c:		  (cond(found-one?
eval.c:			   (else (set! found-one? #t))))
eval.c:		  (cond(found-one?
eval.c:	pcVars=pcFormula->pfForm->pcVars;
eval.c:	pcGenLit=pcFormula->pfForm->pcGenLit;
eval.c:	pc=pcFormula->pfForm->pcArgs;
eval.c:	while((*pcGenLit->pfForm->paAction->pfGenerator)
eval.c:		if(!pc||(*pc->pfForm->paAction->pfEval)(pc,plpLinearPlan,pbBindings))
eval.c:(define (eval-goal args world/action bindings)
eval.c:  (eval-formula (first args) (get-goal-world) bindings))
eval.c:	pc=pcFormula->pfForm->pcArgs;
eval.c:	b=(*pc->pfForm->paAction->pfEval)(pc,GetGoalWorld(TRUE),pbBindings);
eval.c:	pc=pcFormula->pfForm->pcArgs;
eval.c:	b=(*pc->pfForm->paAction->pfEval)(pc,plpCurrentPlan,pbBindings);
eval.c:		plp=plp->plpParent;
eval.c:	pc=pcFormula->pfForm->pcArgs;
eval.c:		b=(*pc->pfForm->paAction->pfEval)(pc,plp,pbBindings);
eval.c:/* Pseudo Predicates -------------------------------------------------------- */
eval.c:	pcVar=pcFormula->pfForm->pcArgs;
eval.c:	pcVal=ComputeTerm(pcVar->pcNext,plpLinearPlan,pbBindings);
eval.c:		TermError("eval-assign",pcFormula,pbBindings);
eval.c:	if(pcVar->pfForm->pcArgs)
eval.c:	Until we change an array-info structure to be an array of cells,
eval.c:	pcVar=pcFormula->pfForm->pcArgs;
eval.c:	if(pcVar->pfForm->pcArgs)
eval.c:		ErrorMessage("Assign-append is not supported on arrays\n");
eval.c:	for(pc=pcVar->pcNext;pc;pc=pc->pcNext)
eval.c:		if(pc->pfForm->nType==ATOM_SYMBOLINFOP&&
eval.c:			!DescribedQ(pc->pfForm->uValue.psiSymbolInfo)&&
eval.c:			FunctionQ(pc->pfForm->uValue.psiSymbolInfo))
eval.c:			TermError("eval-append",pcFormula,pbBindings);
eval.c:	Evaluate an search-global-initialization pseudo predicate.
eval.c:	This is an internal form of eval-assign.
eval.c:	pcVar=pcFormula->pfForm->pcArgs;
eval.c:	pcVal=ComputeTerm(pcVar->pcNext,plpLinearPlan,pbBindings);
eval.c:		TermError("eval-search-global-initialization",pcFormula,pbBindings);
eval.c:	if(pcVar->pfForm->nType==ATOM_ARRAYINFOP)
eval.c:		pai=pcVar->pfForm->uValue.paiArrayInfo;
eval.c:		ppc=pai->ppcArray;
eval.c:		for(i=0;i<pai->nCount;i++)
eval.c:	pcStream=pcFormula->pfForm->pcArgs;
eval.c:	if(nFile<0||nFile>MAXFILE-1)
eval.c:	pcFormat=pcStream->pcNext;
eval.c:	pcArgs=pcFormat->pcNext;
eval.c:	(tlplanner (get-initial-world) (get-tl-control) (get-search-strategy)
eval.c:		(get-priority-fn) (get-cost-fn)))
eval.c:			"Please correct any problems and call clear-world-symbols before proceeding.\n",
eval.c:			"Please call set-initial-world before proceeding.\n");
eval.c:	Evaluate a plan-name pseudo-predicate.
eval.c:	Plan-name specifies a name for the current problem.
eval.c:	if(!pcFormula->pfForm->pcArgs)
eval.c:		ErrorMessage("set-plan-name:  No arguments specified\n");
eval.c:	FormulaToString(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings,&psFormat);
eval.c:		ErrorMessage("set-plan-name:  No format specified\n");
eval.c:		pcFormula->pfForm->pcArgs->pcNext,plpLinearPlan,pbBindings);
eval.c:	Reset (clear) the plan-name.
eval.c:	Evaluate an exit pseudo-predicate.
eval.c:	Evaluate a print-world pseudo-predicate.
eval.c:	if(!FormulaToInteger(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings,&nFile))
eval.c:	if(!FormulaToInteger(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings,&nFile))
eval.c:		ErrorMessage("print-world-list:  Invalid file handle, %d\n",nFile);
eval.c:			for(pc=pcStart;pc;pc=pc->pcNext)
eval.c:/* Formula Predicates ---------------------------------------------------------- */
eval.c:(define (=-formp form)
eval.c:  (eq? (get-operator form) '=))
eval.c:	return pcFormula->pfForm->paAction==&aEqAction;
eval.c:	return pcFormula->pfForm->paAction==&aPlusEqAction;
eval.c:	Test if formula is a -= formula.
eval.c:	return pcFormula->pfForm->paAction==&aMinusEqAction;
eval.c:	return pcFormula->pfForm->paAction==&aTrueAction;
eval.c:	return pcFormula->pfForm->paAction==&aFalseAction;
eval.c:(define (and-formp form)
eval.c:  (eq? (get-operator form) 'AND))
eval.c://	return pcFormula->pfForm->paAction->pfProgress==ProgressAnd;
eval.c:	return pcFormula->pfForm->paAction==&aAndAction;
eval.c:(define (or-formp form)
eval.c:  (eq? (get-operator form) 'OR))
eval.c:	return pcFormula->pfForm->paAction==&aOrAction;
eval.c:(define (xor-formp form)
eval.c:  (eq? (get-operator form) 'XOR))
eval.c:	return pcFormula->pfForm->paAction==&aXorAction;
eval.c:(define (if-then-else-formp form)
eval.c:  (eq? (get-operator form) 'IF-THEN-ELSE))
eval.c://	return pcFormula->pfForm->paAction==&aIfThenElseAction;
eval.c:(define (not-formp form)
eval.c:  (eq? (get-operator form) 'NOT))
eval.c:	return pcFormula->pfForm->paAction==&aNotAction;
eval.c:(define (implies-formp form)
eval.c:  (eq? (get-operator form) 'IMPLIES))
eval.c:	return pcFormula->pfForm->paAction==&aImpliesAction;
eval.c:(define (goal-formp form)
eval.c:  (eq? (get-operator form) 'GOAL))
eval.c:	return pcFormula->pfForm->paAction==&aGoalAction;
eval.c:	return pcFormula->pfForm->paAction==&aPreviousAction;
eval.c:	return pcFormula->pfForm->paAction==&aPermuteAction;
eval.c:(define (forall-formp form)
eval.c:  (eq? (get-operator form) 'FORALL))
eval.c:	return pcFormula->pfForm->paAction==&aForAllAction;
eval.c:(define (exists-formp form)
eval.c:  (eq? (get-operator form) 'EXISTS))
eval.c:	return pcFormula->pfForm->paAction==&aExistsAction;
eval.c:(define (exists!-formp form)
eval.c:  (eq? (get-operator form) 'EXISTS!))
eval.c:	return pcFormula->pfForm->paAction==&aExistsXAction;
eval.c:(define (next-formp form)
eval.c:  (eq? (get-operator form) 'NEXT))
eval.c:	return pcFormula->pfForm->paAction==&aNextAction;
eval.c:(define (eventually-formp form)
eval.c:  (eq? (get-operator form) 'EVENTUALLY))
eval.c:	return pcFormula->pfForm->paAction==&aEventuallyAction;
eval.c:(define (always-formp form)
eval.c:  (eq? (get-operator form) 'ALWAYS))
eval.c:	return pcFormula->pfForm->paAction==&aAlwaysAction;
eval.c:(define (until-formp form)
eval.c:  (eq? (get-operator form) 'UNTIL))
eval.c:	return pcFormula->pfForm->paAction==&aUntilAction;
eval.c:(define (t-until-formp form)
eval.c:  (eq? (get-operator form) 'T-UNTIL))
eval.c:	return pcFormula->pfForm->paAction==&aTUntilAction;
eval.c:(define (t-eventually-formp form)
eval.c:  (eq? (get-operator form) 'T-EVENTUALLY))
eval.c:	return pcFormula->pfForm->paAction==&aTEventuallyAction;
eval.c:(define (t-always-formp form)
eval.c:  (eq? (get-operator form) 'T-ALWAYS))
eval.c:	return pcFormula->pfForm->paAction==&aTAlwaysAction;
eval.c:(define (delta-formp form)
eval.c:  (eq? (get-operator form) 'DELTA))
eval.c:	return pcFormula->pfForm->paAction==&aDeltaAction;
eval.c:(define (binding-formp form)
eval.c:  (eq? (get-operator form) 'BINDING))
eval.c:	return pcFormula->pfForm->paAction==&aBindingAction;
eval.c:(define (atomic-formp form)
eval.c:   (or (or-formp form)
eval.c:	   (and-formp form)
eval.c:	   (forall-formp form)
eval.c:	   (exists-formp form)
eval.c:	   (not-formp form)
eval.c:	   (implies-formp form)
eval.c:	   (goal-formp form)
eval.c:	   (call-formp form)
eval.c:	   (next-formp form)
eval.c:	   (eventually-formp form)
eval.c:	   (always-formp form)
eval.c:	   (until-formp form)
eval.c:	   (t-until-formp form)
eval.c:	   (t-eventually-formp form)
eval.c:	   (t-always-formp form)
eval.c:	   (delta-formp form)
eval.c:	   (binding-formp form))))
eval.c:	Test if formula is an ADD formula (pseudo-predicate).
eval.c:	return pcFormula->pfForm->paAction==&aAddAction;
eval.c:	Test if formula is a DEL formula (pseudo-predicate).
eval.c:	return pcFormula->pfForm->paAction==&aDelAction;
eval.c:/* Binding Formula Routines ---------------------------------------------------- */
eval.c:(define (get-binding-vars binding-form)
eval.c:  (first (rest binding-form)))
eval.c:	return pcBindingForm->pfForm->pcVars;
eval.c:(define (get-binding-vals binding-form)
eval.c:  (second (rest binding-form)))
eval.c:	return pcBindingForm->pfForm->pcGenLit;
eval.c:(define (get-binding-formula binding-form)
eval.c:  (third (rest binding-form)))
eval.c:	return pcBindingForm->pfForm->pcArgs;
eval.c:(define (lookup-var var bindings)
eval.c:	for(pb=pbBindings;pb;pb=pb->pbNext)
eval.c:		if(StringEqQ(IdentName(pcVar->pfForm),IdentName(pb->pcVar->pfForm)))
eval.c:			return pb->pcVal;
eval.c:		"Current bindings:\n",GetName(pcVar->pfForm,ac));
eval.c:(define (set-var! var val bindings)
eval.c:	(set-cdr! cell val)
eval.c:	for(pb=pbBindings;pb;pb=pb->pbNext)
eval.c:		if(StringEqQ(IdentName(pcVar->pfForm),IdentName(pb->pcVar->pfForm)))
eval.c:			pb->pcVal=pcVal;
eval.c:	ErrorMessage("SetVarX:  Formula contains unbound variable %s\n",GetName(pcVar->pfForm,ac));
eval.c:	for(pb=pbBindings;pb;pb=pb->pbNext)
eval.c:		if(StringEqQ(IdentName(pcVar->pfForm),IdentName(pb->pcVar->pfForm)))
eval.c:			if(FormulaEqQ(pcVar,pb->pcVal))
eval.c:				pb->pcVal=CopyCell(pcVal);
eval.c:				for(pc=pb->pcVal;pc->pcNext;pc=pc->pcNext);
eval.c:					pc->pcNext=CopyCell(pcVal);
eval.c:	ErrorMessage("AppendVarX:  Formula contains unbound variable %s\n",GetName(pcVar->pfForm,ac));
eval.c:	for(pb=pbBindings;pb;pb=pb->pbNext)
eval.c:		if(StringEqQ(IdentName(pcArray->pfForm),IdentName(pb->pcVar->pfForm)))
eval.c:			if(ArrayIndex(pcArray,pb->pcVal,plpLinearPlan,pbBindings,&nIndex))
eval.c:				pai=pb->pcVal->pfForm->uValue.paiArrayInfo;
eval.c:				pai->ppcArray[nIndex]=pcVal;
eval.c:	ErrorMessage("SetArrayX:  Formula contains unbound variable %s\n",GetName(pcArray->pfForm,ac));
eval.c:(define (extend-bindings vars vals bindings)
eval.c:	for(pc1=pcVars,pc2=pcVals;pc1&&pc2;pc1=pc1->pcNext,pc2=pc2->pcNext)
eval.c:		pbEnd=pbEnd->pbNext=(BINDINGP)MemAlloc(sizeof(BINDING));
eval.c:		pbEnd->pcVar=pc1;
eval.c:		pbEnd->pcVal=pc2;
eval.c:	pbEnd->pbNext=pbBindings;
eval.c:	the variables in the lists are pair-wise identical, so we do not compare them.
eval.c:	for(pb1=pbShare,pb2=pbCopy;pb1;pb1=pb1->pbNext,pb2=pb2->pbNext)
eval.c:		if(!FormulaEqQ(pb1->pcVal,pb2->pcVal))
eval.c:			pbShareable=pb1->pbNext;
eval.c:		for(pb2=pbCopy;pb2;pb2=pb2->pbNext)
eval.c:			pbEnd=pbEnd->pbNext=(BINDINGP)CopyAlloc(pb2,sizeof(BINDING));
eval.c:		pbEnd->pbNext=NULL;
eval.c:	for(pb1=pbShare,pb2=pbCopy;pb1!=pbShareable;pb1=pb1->pbNext,pb2=pb2->pbNext)
eval.c:		pbEnd=pbEnd->pbNext=(BINDINGP)CopyAlloc(pb2,sizeof(BINDING));
eval.c:	pbEnd->pbNext=pbShareable;
eval.c:/* Miscellaneous Formula Stuff ------------------------------------------------- */
eval.c:(define (get-delta-formula delta-form)
eval.c:  (rest delta-form))
eval.c:	return pcDeltaForm->pfForm->pcArgs;
eval.c:(define (get-bf-ispec bf-form)
eval.c:  (second bf-form))
eval.c:	return pcBFFormula->pfForm->pcArgs;
eval.c:(define (get-bf-formulas bf-form)
eval.c:  (rest (rest bf-form)))
eval.c:	return pcBFFormula->pfForm->pcArgs->pcNext;
eval.c:(define (fn-lit? lit)
eval.c:	b=StringEqQ(IdentName(pcLit->pfForm),apsStringTab[STRING_EQ]);
eval.c:/* File I/O ----------------------------------------------------------------- */
eval.c:	pc1=pcFormula->pfForm->pcArgs;
eval.c:	if(nFile1<0||nFile1>MAXFILE-1)
eval.c:			nFile1,0,MAXFILE-1);
eval.c:	pc2=pc1->pcNext;
eval.c:	if(nFile2<0||nFile2>MAXFILE-1)
eval.c:			nFile2,0,MAXFILE-1);
eval.c:	if(!FormulaToInteger(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings,&nFile))
eval.c:	if(nFile<0||nFile>MAXFILE-1)
eval.c:		ErrorMessage("close-file:  File handle out of range [%d,%d]\n",
eval.c:			0,MAXFILE-1);
eval.c:                      "+  This copy can be used only for non-commercial research purposes.                +\n"
eval.c:			"+  This copy can be used only for non-commercial research purposes.                +\n"
eval.c:	if(nFile<0||nFile>MAXFILE-1)
eval.c:	if(!FormulaToInteger(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings,&n))
eval.c:		ErrorMessage("set-search-depth-limit:  Search depth must be positive.\n");
eval.c:	if(!FormulaToDouble(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings,&df))
FloydWarshall.c:	double C[n][n],						// input edge-cost array
FloydWarshall.c:			P[i][j]=-1;
FloydWarshall.c:			P1[i][j]=-1;
FloydWarshall.c:	else if(P1[i][j]==-1)				// no path
formula.c:/* formula.c -- Formula Manipulation Routines
formula.c:Copyright C, 1997 - 2001, Fahiem Bacchus
formula.c:	CELLP pcGenLit,						/* generator formula (such-that clause) */
formula.c:	CELLP pcGenLit						/* generator formula (such-that clause) */
formula.c:/* Action Tables ------------------------------------------------------------ */
formula.c:	"if-then-else",
formula.c:	"-=",
formula.c:	"t-always",
formula.c:	"t-eventually",
formula.c:	"t-until",
formula.c:	"print-world",
formula.c:	"print-delta-time",
formula.c:	"print-world-list",
formula.c:	"set-plan-name",
formula.c:	"reset-plan-name",
formula.c:	"set-plan-name",
formula.c:	"search-global-initialization",
formula.c:	"optimal-cost",
formula.c:	"goal-distance",
formula.c:	"best-action",
formula.c:	"plan-length",
formula.c:	"plan-cost",
formula.c:	"plan-duration",
formula.c:	"action-name",
formula.c:	"action-cost",
formula.c:	"action-duration",
formula.c:	"action-priority",
formula.c:	"world-number",
formula.c://	"world-heuristic-rank",
formula.c:	"modify-world",
formula.c:ACTION aDummyAction=					/* dummy formulas -- available only in the right context */
formula.c:	"clear-world-symbols",
formula.c:	"clear-operators",
formula.c:	"declare-defined-symbols",
formula.c:	"declare-described-symbols",
formula.c:	"declare-external-symbols",
formula.c:	"declare-global-variables",
formula.c:	"declare-macro-operators",
formula.c:	"declare-elided-operators",
formula.c:	"def-adl-operator",
formula.c:	"def-defined-function",
formula.c:	"def-defined-generator",
formula.c:	"def-defined-macro",
formula.c:	"def-defined-predicate",
formula.c:	"def-domain",
formula.c:	"def-strips-operator",
formula.c:	"get-heuristic-fn",
formula.c:	"heuristic-fn",
formula.c:	"get-priority-fn",
formula.c:	"get-search-limit",
formula.c:	"get-search-strategy",
formula.c:	"get-tl-control",
formula.c:	"get-goal-addendum",
formula.c:	"get-trace-level",
formula.c:	"list-domains",
formula.c:	"load-domain",
formula.c:	"load-file",
formula.c:	"load-pddl-problem",
formula.c:	"load-plan",
formula.c:	"clear-event-queue",
formula.c:	"print-plan-list",
formula.c:	"print-pddl-plan",
formula.c:	"reset-domains",
formula.c:	"reset-heuristic-fn",
formula.c:	"reset-print-world-fn",
formula.c:	"reset-priority-fn",
formula.c:	"reset-search-limit",
formula.c:	"reset-search-strategy",
formula.c:	"reset-tl-control",
formula.c:	"set-control",
formula.c:	"set-goal-addendum",
formula.c:	"reset-goal-addendum",
formula.c:	"set-heuristic-fn",
formula.c:	"set-initial-facts",
formula.c:	"set-initial-world",
formula.c:	"set-initialization-sequence",
formula.c:	"set-goal",
formula.c:	"set-goal-sequence",
formula.c:	"set-goal-formula",
formula.c:	"set-goal-type",
formula.c:	"set-print-world-fn",
formula.c:	"set-priority-fn",
formula.c:	"set-search-limit",
formula.c:	"set-search-strategy",
formula.c:	"set-statistics-file",
formula.c:	"set-tl-control",
formula.c:	"set-trace-level",
formula.c:	"verbose-off",
formula.c:	"verbose-on",
formula.c:	"update-world",
formula.c:	"-",
formula.c:	"conditional-exp",
formula.c:	"pos-int",
formula.c:	"<-pos-int",
formula.c:	"is-between",
formula.c:	"nearest-first",
formula.c:	"nearest-first-ex",
formula.c:	"closest-first",
formula.c:	"closest-first-ex",
formula.c:	"lowest-first",
formula.c:	"all-pairs-shortest-path",
formula.c://	"fewest-edges-path",
formula.c://	"lowest-cost-path",
formula.c:	"in-the-set",
formula.c:	"select-initial-world",
formula.c:	"select-final-world",
formula.c:	"select-next-world",
formula.c:	"select-previous-world",
formula.c:	"close-file",
formula.c:	"open-file",
formula.c:	"make-literal",
formula.c:	"set-rng",
formula.c:	"set-rng",
formula.c:	"get-rng",
formula.c:	"plan-status",
formula.c:	"worlds-generated",
formula.c:	"worlds-searched",
formula.c:	"worlds-pruned",
formula.c:	"worlds-discarded",
formula.c:	"worlds-unexamined",
formula.c:	"plan-cpu-time",
formula.c:	"get-cpu-time",
formula.c:	"set-search-depth-limit",
formula.c:	"reset-search-depth-limit",
formula.c:	"get-search-depth-limit",
formula.c:	"search-max-depth",
formula.c:	"set-search-heuristic-limit",
formula.c:	"reset-search-heuristic-limit",
formula.c:	"get-search-heuristic-limit",
formula.c:	"search-max-heuristic",
formula.c:	"delayed-action",
formula.c:	"global-delayed-action",
formula.c:	"wait-for-next-event",
formula.c:	"reachable-event",
formula.c:	"current-time",
formula.c:	"inhibit-delayed-action",
formula.c:	pa->psName=IdentAlloc(pa->psName);
formula.c:/* ListToFormula ---------------------------------------------------------------
formula.c:	if(plList->nType==ATOM_LISTP)
formula.c:		pl=plList->uValue.plList;
formula.c:		if(plList->psName&&(pl->nType==ATOM_FLOAT||
formula.c:			pl->nType==ATOM_INTEGER||pl->nType==ATOM_STRING))
formula.c:			pc1->pfForm=(FORMULAP)MemAlloc(sizeof(FORMULA));
formula.c:			pc1->pfForm->nType=pl->nType;
formula.c:			if(plList->nType==ATOM_STRING)
formula.c:				pc1->pfForm->psName=StrAlloc(pl->psName);
formula.c:				pc1->pfForm->uValue.psString=pc1->pfForm->psName;
formula.c:				pc1->pfForm->psName=IdentAlloc(pl->psName);
formula.c:				pc1->pfForm->uValue=pl->uValue;
formula.c:		if(pl->nType!=ATOM_IDENT&&pl->nType!=ATOM_FUNCTIONP&&
formula.c:			pl->nType!=ATOM_SYMBOLINFOP)
formula.c:		if(StringEqQ(pl->psName,apsStringTab[STRING_TRUE])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_FALSE])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_OPTIMAL_COST])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_BEST_ACTION])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_RESET_PRINT_WORLD_FN])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_PLAN_LENGTH])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_PLAN_COST])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_PLAN_DURATION])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_ACTION_NAME])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_ACTION_COST])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_ACTION_DURATION])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_ACTION_PRIORITY])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_WORLD_NUMBER])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_WORLD_HEURISTIC_RANK])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_PLAN])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_CLEAR_EVENT_QUEUE])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_VERBOSE_ON])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_VERBOSE_OFF])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_UPDATE_WORLD])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_GET_TRACE_LEVEL])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_GET_SEARCH_STRATEGY])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_GET_SEARCH_LIMIT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_GET_TL_CONTROL])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_RESET_TL_CONTROL])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_GET_HEURISTIC_FN])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_HEURISTIC_FN])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_RESET_HEURISTIC_FN])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_GET_GOAL_ADDENDUM])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_RESET_GOAL_ADDENDUM])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_GET_PRIORITY_FN])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_RESET_PRIORITY_FN])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_RESET_SEARCH_LIMIT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_RESET_DOMAINS])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_GET_PLAN_NAME])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_RESET_PLAN_NAME])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_RESET_RNG])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_GET_RNG])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_LIST_DOMAINS])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_RAND])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_CLEAR_WORLD_SYMBOLS])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_CLEAR_OPERATORS])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SELECT_INITIAL_WORLD])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SELECT_FINAL_WORLD])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SELECT_NEXT_WORLD])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SELECT_PREVIOUS_WORLD])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_PLAN_STATUS])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_WORLDS_GENERATED])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_WORLDS_SEARCHED])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_WORLDS_PRUNED])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_WORLDS_DISCARDED])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_WORLDS_UNEXAMINED])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_PLAN_CPU_TIME])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_GET_CPU_TIME])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_GET_SEARCH_DEPTH_LIMIT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SEARCH_MAX_DEPTH])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_GET_SEARCH_HEURISTIC_LIMIT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SEARCH_MAX_HEURISTIC])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_WAIT_FOR_NEXT_EVENT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_REACHABLE_EVENT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_EXIT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SET_GOAL_FORMULA])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_PRINT_PDDL_PLAN])||
formula.c:		        StringEqQ(pl->psName,apsStringTab[STRING_CURRENT_TIME])||
formula.c:		        StringEqQ(pl->psName,apsStringTab[STRING_GOAL_DISTANCE]))
formula.c:			for(pl1=pl->plNext;pl1;pl1=pl1->plNext)
formula.c:				for(pc1=ListToFormula(pl1);pc1;pc1=pc1->pcNext)
formula.c:					pcEnd=pcEnd->pcNext=pc1;
formula.c:					pl->psName);
formula.c:			if(StringEqQ(pl->psName,apsStringTab[STRING_TRUE]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_FALSE]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_OPTIMAL_COST]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_BEST_ACTION]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_PLAN_LENGTH]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_RESET_PRINT_WORLD_FN]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_PLAN_COST]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_PLAN_DURATION]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_ACTION_NAME]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_ACTION_COST]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_ACTION_DURATION]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_ACTION_PRIORITY]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_WORLD_NUMBER]))
formula.c://			else if(StringEqQ(pl->psName,apsStringTab[STRING_WORLD_HEURISTIC_RANK]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_PLAN]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_CLEAR_EVENT_QUEUE]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_VERBOSE_OFF]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_VERBOSE_ON]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_UPDATE_WORLD]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_GET_TRACE_LEVEL]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_GET_SEARCH_STRATEGY]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_GET_SEARCH_LIMIT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_GET_TL_CONTROL]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_GET_GOAL_ADDENDUM]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_RESET_TL_CONTROL]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_GET_HEURISTIC_FN]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_HEURISTIC_FN]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_RESET_HEURISTIC_FN]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_RESET_GOAL_ADDENDUM]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_GET_PRIORITY_FN]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_RESET_PRIORITY_FN]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_RESET_SEARCH_LIMIT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_RESET_DOMAINS]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_GET_PLAN_NAME]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_RESET_PLAN_NAME]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_RESET_RNG]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_GET_RNG]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_LIST_DOMAINS]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_RAND]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_CLEAR_WORLD_SYMBOLS]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_CLEAR_OPERATORS]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SELECT_INITIAL_WORLD]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SELECT_FINAL_WORLD]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SELECT_NEXT_WORLD]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SELECT_PREVIOUS_WORLD]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_PLAN_STATUS]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_WORLDS_GENERATED]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_WORLDS_SEARCHED]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_WORLDS_PRUNED]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_WORLDS_DISCARDED]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_WORLDS_UNEXAMINED]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_PLAN_CPU_TIME]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_GET_CPU_TIME]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_GET_SEARCH_DEPTH_LIMIT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_RESET_SEARCH_DEPTH_LIMIT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SEARCH_MAX_DEPTH]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_GET_SEARCH_HEURISTIC_LIMIT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_RESET_SEARCH_HEURISTIC_LIMIT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SEARCH_MAX_HEURISTIC]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_WAIT_FOR_NEXT_EVENT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_REACHABLE_EVENT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_EXIT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_GOAL_FORMULA]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_CURRENT_TIME]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_PRINT_PDDL_PLAN]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_GOAL_DISTANCE]))
formula.c:		if(StringEqQ(pl->psName,apsStringTab[STRING_NOT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_GOAL])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_CURRENT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_PREVIOUS])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_PERMUTE])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_DELTA])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_ALWAYS])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_EVENTUALLY])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_NEXT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SET_SEARCH_LIMIT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_LOAD_DOMAIN])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_LOAD_FILE])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_LOAD_PDDL_PROBLEM])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SET_GOAL_TYPE])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SET_CONTROL])||
formula.c:		   StringEqQ(pl->psName,apsStringTab[STRING_LOG])||
formula.c:		   //			StringEqQ(pl->psName,apsStringTab[STRING_ENABLE])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_DISABLE])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SET_GOAL_ADDENDUM])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SET_RNG])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SET_STATISTICS_FILE])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SET_HEURISTIC_FN])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SET_PRIORITY_FN])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SET_TRACE_LEVEL])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SET_TL_CONTROL])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SET_SEARCH_STRATEGY])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SET_PRINT_WORLD_FN])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_PRINT_PLAN_LIST])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_EXP])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SEED])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_ROUND])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_INT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_FLOOR])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_CEIL])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_POS_INT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_CLOSE_FILE])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SET_SEARCH_DEPTH_LIMIT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SET_SEARCH_HEURISTIC_LIMIT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_PRINT_WORLD])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_PRINT_WORLD_LIST])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_ASTAR]))
formula.c:			for(pl1=pl->plNext;pl1;pl1=pl1->plNext)
formula.c:				for(pc1=ListToFormula(pl1);pc1;pc1=pc1->pcNext)
formula.c:					pcEnd=pcEnd->pcNext=pc1;
formula.c:					nArgs<1?"few":"many",pl->psName);
formula.c:			if(StringEqQ(pl->psName,apsStringTab[STRING_NOT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_GOAL]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_CURRENT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_PREVIOUS]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_PERMUTE]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_DELTA]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_ALWAYS]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_EVENTUALLY]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_NEXT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_GOAL_TYPE]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_CONTROL]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_LOG]))
formula.c:			/*else if(StringEqQ(pl->psName,apsStringTab[STRING_ENABLE]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_DISABLE]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_GOAL_ADDENDUM]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_RNG]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_SEARCH_LIMIT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_LOAD_DOMAIN]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_LOAD_FILE]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_LOAD_PDDL_PROBLEM]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_STATISTICS_FILE]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_HEURISTIC_FN]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_PRIORITY_FN]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_TRACE_LEVEL]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_TL_CONTROL]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_SEARCH_STRATEGY]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_PRINT_WORLD_FN]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_PRINT_PLAN_LIST]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_EXP]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SEED]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_ROUND]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_INT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_FLOOR]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_CEIL]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_POS_INT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_CLOSE_FILE]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_SEARCH_DEPTH_LIMIT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_SEARCH_HEURISTIC_LIMIT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_PRINT_WORLD]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_PRINT_WORLD_LIST]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_ASTAR]))
formula.c:		if(StringEqQ(pl->psName,apsStringTab[STRING_IMPLIES])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_EQ])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_ASSIGN])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_OPEN_FILE])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_LT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_LE])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_GT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_GE])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_T_ALWAYS])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_T_EVENTUALLY])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_RANDOM])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_REDIRECT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_LT_POS_INT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_UNTIL])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_INHIBIT_DELAYED_ACTION])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_PLUS_EQ])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_MINUS_EQ]))
formula.c:			for(pl1=pl->plNext;pl1;pl1=pl1->plNext)
formula.c:				for(pc1=ListToFormula(pl1);pc1;pc1=pc1->pcNext)
formula.c:					pcEnd=pcEnd->pcNext=pc1;
formula.c:					nArgs<2?"few":"many",pl->psName);
formula.c:			if(StringEqQ(pl->psName,apsStringTab[STRING_IMPLIES]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_EQ]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_LT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_LE]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_GT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_GE]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_ASSIGN]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_OPEN_FILE]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_T_ALWAYS]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_T_EVENTUALLY]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_RANDOM]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_REDIRECT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_LT_POS_INT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_UNTIL]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_INHIBIT_DELAYED_ACTION]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_PLUS_EQ]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_MINUS_EQ]))
formula.c:		if(StringEqQ(pl->psName,apsStringTab[STRING_IF_THEN_ELSE])||
formula.c:		        StringEqQ(pl->psName,apsStringTab[STRING_CONDITIONAL_EXP])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_DELAYED_ACTION])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_GLOBAL_DELAYED_ACTION])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_T_UNTIL]))
formula.c:			for(pl1=pl->plNext;pl1;pl1=pl1->plNext)
formula.c:				for(pc1=ListToFormula(pl1);pc1;pc1=pc1->pcNext)
formula.c:					pcEnd=pcEnd->pcNext=pc1;
formula.c:					nArgs<3?"few":"many",pl->psName);
formula.c:			if(StringEqQ(pl->psName,apsStringTab[STRING_IF_THEN_ELSE]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_DELAYED_ACTION]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_CONDITIONAL_EXP]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_GLOBAL_DELAYED_ACTION]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_T_UNTIL]))
formula.c:		if(StringEqQ(pl->psName,apsStringTab[STRING_SET_GOAL])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SET_INITIAL_WORLD])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_PRINT_DELTA_TIME]))
formula.c:			for(pl1=pl->plNext;pl1;pl1=pl1->plNext)
formula.c:				for(pc1=ListToFormula(pl1);pc1;pc1=pc1->pcNext)
formula.c:					pcEnd=pcEnd->pcNext=pc1;
formula.c:			if(StringEqQ(pl->psName,apsStringTab[STRING_SET_GOAL]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_INITIAL_WORLD]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_PRINT_DELTA_TIME]))
formula.c:		if(StringEqQ(pl->psName,apsStringTab[STRING_AND])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_OR])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_XOR])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_ADD])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_DEL])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SDEL])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_PRINT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_DEF_DOMAIN])||
formula.c:		   //StringEqQ(pl->psName,apsStringTab[STRING_LOG])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_ENABLE])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_DECLARE_DESCRIBED_SYMBOLS])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_DECLARE_DEFINED_SYMBOLS])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_DECLARE_EXTERNAL_SYMBOLS])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_DECLARE_GLOBAL_VARIABLES])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_DECLARE_MACRO_OPERATORS])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_DECLARE_ELIDED_OPERATORS])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_DEFINE])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_ASSIGN_APPEND])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_DEF_DEFINED_PREDICATE])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_DEF_DEFINED_FUNCTION])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_DEF_DEFINED_GENERATOR])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_DEF_DEFINED_MACRO])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_DEF_ADL_OPERATOR])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_DEF_STRIPS_OPERATOR])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SET_INITIAL_FACTS])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SET_INITIALIZATION_SEQUENCE])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SET_GOAL_SEQUENCE])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_IS_BETWEEN])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_NEAREST_FIRST])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_NEAREST_FIRST_EX])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_CLOSEST_FIRST])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_CLOSEST_FIRST_EX])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_LOWEST_FIRST])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_ALL_PAIRS_SHORTEST_PATH])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_PLUS])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_MINUS])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_STAR])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SLASH])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_MOD])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_MAX])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_MIN])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_EXPT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SQRT])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_ABS])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_SET_PLAN_NAME])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_LOAD_PLAN])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_MAKE_LITERAL]))
formula.c:			bADLPre=StringEqQ(pl->psName,apsStringTab[STRING_DEF_ADL_OPERATOR]);
formula.c:			for(pl1=pl->plNext;pl1;pl1=pl1->plNext)
formula.c:				for(pc1=ListToFormula(pl1);pc1;pc1=pc1->pcNext)
formula.c:					pcEnd=pcEnd->pcNext=pc1;
formula.c:					pl->psName);
formula.c:			if(StringEqQ(pl->psName,apsStringTab[STRING_AND]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_OR]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_XOR]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_ADD]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_DEL]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SDEL]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_PRINT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_DEF_DOMAIN]))
formula.c:			/*else if(StringEqQ(pl->psName,apsStringTab[STRING_LOG]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_ENABLE]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_DECLARE_DESCRIBED_SYMBOLS]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_DECLARE_DEFINED_SYMBOLS]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_DECLARE_EXTERNAL_SYMBOLS]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_DECLARE_GLOBAL_VARIABLES]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_DECLARE_MACRO_OPERATORS]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_DECLARE_ELIDED_OPERATORS]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_DEFINE]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_DEF_DEFINED_PREDICATE]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_DEF_DEFINED_FUNCTION]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_DEF_DEFINED_GENERATOR]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_DEF_DEFINED_MACRO]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_ASSIGN_APPEND]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_DEF_ADL_OPERATOR]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_DEF_STRIPS_OPERATOR]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_GOAL]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_INITIAL_FACTS]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_INITIAL_WORLD]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_INITIALIZATION_SEQUENCE]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_GOAL_SEQUENCE]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SET_PLAN_NAME]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_IS_BETWEEN]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_NEAREST_FIRST]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_NEAREST_FIRST_EX]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_CLOSEST_FIRST]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_CLOSEST_FIRST_EX]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_LOWEST_FIRST]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_ALL_PAIRS_SHORTEST_PATH]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_PLUS]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_MINUS]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_STAR]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SLASH]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_MOD]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_MAX]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_MIN]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_EXPT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_SQRT]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_ABS]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_LOAD_PLAN]))
formula.c:			else if(StringEqQ(pl->psName,apsStringTab[STRING_MAKE_LITERAL]))
formula.c:		if(StringEqQ(pl->psName,apsStringTab[STRING_IN_THE_SET]))
formula.c:			pl1=pl->plNext;
formula.c:			if(pl1->plNext)			/* if variables present */
formula.c:					pl->psName);
formula.c:			for(pl1=pl1->plNext;pl1;pl1=pl1->plNext)
formula.c:				pcEnd=pcEnd->pcNext=ListToFormula(pl1);
formula.c:					pl->psName);
formula.c:					"variable count in %s formula\n",pl->psName);
formula.c:			pc->pfForm->pcArgs=pcStart;
formula.c:		if(StringEqQ(pl->psName,apsStringTab[STRING_EXISTS])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_EXISTSX])||
formula.c:			StringEqQ(pl->psName,apsStringTab[STRING_FORALL]))
formula.c:			for(pl1=pl->plNext;pl1;pl1=pl1->plNext->plNext)
formula.c:				if(pl1->plNext)			/* if vargen present */
formula.c:					if(StringEqQ(pl->psName,apsStringTab[STRING_EXISTS]))
formula.c:					else if(StringEqQ(pl->psName,apsStringTab[STRING_EXISTSX]))
formula.c:					else if(StringEqQ(pl->psName,apsStringTab[STRING_FORALL]))
formula.c:							pl->psName);
formula.c:				ppc=&(*ppc)->pfForm->pcArgs;
formula.c:		if(StringEqQ(pl->psName,apsStringTab[STRING_PRE]))
formula.c:				for(pl1=pl->plNext;pl1;pl1=pl1->plNext->plNext)
formula.c:					if(pl1->plNext)		/* if vargen present */
formula.c:						pcEnd=pcEnd->pcNext=CompileVarGenForm(pc1,pc2);
formula.c:				for(pl1=pl->plNext;pl1;pl1=pl1->plNext)
formula.c:					for(pc1=ListToFormula(pl1);pc1;pc1=pc1->pcNext)
formula.c:						pcEnd=pcEnd->pcNext=pc1;
formula.c:				pc=CompileDummyForm(pl->psName,pcStart);
formula.c:		if(StringEqQ(pl->psName,apsStringTab[STRING_ISPEC]))
formula.c:			pl1=pl->plNext;
formula.c:					pl->psName);
formula.c:			pl2=pl1->plNext;
formula.c:					pl->psName);
formula.c:			pl3=pl2->plNext;
formula.c:					pl->psName);
formula.c:			pl4=pl3->plNext;
formula.c:					pl->psName);
formula.c:			if(pl4->plNext)
formula.c:					pl->psName);
formula.c:		if(*pl->psName=='?')
formula.c:			if(!pl->plNext)
formula.c:					pl->psName);
formula.c:			for(pl1=pl->plNext;pl1;pl1=pl1->plNext)
formula.c:					pcEnd=pcEnd->pcNext=pc1;
formula.c:			pc=CompileArrayForm(pl->psName,pcStart);
formula.c:		/* convert symbol-info routines */
formula.c:		if(pl->nType==ATOM_SYMBOLINFOP)
formula.c:			for(pl1=pl->plNext;pl1;pl1=pl1->plNext)
formula.c:				for(pc1=ListToFormula(pl1);pc1;pc1=pc1->pcNext)
formula.c:					pcEnd=pcEnd->pcNext=pc1;
formula.c:		/* unknown symbol -- must be a definition or a keyword */
formula.c:		for(pl1=pl->plNext;pl1;pl1=pl1->plNext)
formula.c:			for(pc1=ListToFormula(pl1);pc1;pc1=pc1->pcNext)
formula.c:				pcEnd=pcEnd->pcNext=pc1;
formula.c:		pc=CompileDummyForm(pl->psName,pcStart);
formula.c:	pc1->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
formula.c:	pf->nType=plList->nType;
formula.c:	if(plList->nType==ATOM_STRING)
formula.c:		pf->psName=StrAlloc(plList->psName);
formula.c:		pf->uValue.psString=pf->psName;
formula.c:		pf->psName=IdentAlloc(plList->psName);
formula.c:		pf->uValue=plList->uValue;
formula.c:	pf->paAction=&aLiteralAction;
formula.c:			plList->psName);
formula.c:	if(plList->nType!=ATOM_LISTP)
formula.c:	for(pl4=plList->uValue.plList;pl4;pl4=pl4->plNext)
formula.c:		if(pl4->nType!=ATOM_IDENT)
formula.c:				pl4->psName);
formula.c:		if(pl4->psName[0]!='?')
formula.c:				pl4->psName);
formula.c:			pcEnd=pcEnd->pcNext=pc;
formula.c:	pl2=plList->plNext;
formula.c:			plList->psName);
formula.c:	if(plList->nType!=ATOM_LISTP)
formula.c:	for(pl4=plList->uValue.plList;pl4;pl4=pl4->plNext)
formula.c:		if(pl4->nType!=ATOM_IDENT)
formula.c:				plList->psName);
formula.c:		if(pl4->psName[0]!='?')
formula.c:				plList->psName);
formula.c:			pcEnd=pcEnd->pcNext=pc;
formula.c:	for(pc=pcList;pc;pc=pc->pcNext)
formula.c:		pcEnd=pcEnd->pcNext=(CELLP)MemAlloc(sizeof(CELL));
formula.c:		pcEnd->pfForm=pc->pfForm;
formula.c:	for(pc=pcList;pc;pc=pc->pcNext)
formula.c:		pcEnd=pcEnd->pcNext=(CELLP)MemAlloc(sizeof(CELL));
formula.c:		pcEnd->pfForm=pc->pfForm;
formula.c:	for(pc=pcList;pc!=pcFirstPastPrefix;pc=pc->pcNext)
formula.c:		pcEnd=pcEnd->pcNext=(CELLP)MemAlloc(sizeof(CELL));
formula.c:		pcEnd->pfForm=pc->pfForm;
formula.c:		pc->pfForm=pcCell->pfForm;
formula.c:	pc->pcNext=NULL;
formula.c:	pc->pfForm=pcCell?pcCell->pfForm:NULL;
formula.c:	for(pc=pcList;pc;pc=pc->pcNext)
formula.c:		pf1=pc->pfForm;
formula.c:		pcEnd=pcEnd->pcNext=(CELLP)MemAlloc(sizeof(CELL));
formula.c:		pcEnd->pfForm=pf=(FORMULAP)CopyAlloc(pf1,sizeof(FORMULA));
formula.c://		pf->psName=pf1->psName;
formula.c:		switch(pf1->nType)
formula.c:				pf->uValue.plList=CopyList(pf1->uValue.plList);
formula.c:				pf->uValue.piISpec=(ISPECP)CopyAlloc(pf1->uValue.piISpec,sizeof(ISPEC));
formula.c:		if(pf1->pcVars)
formula.c:			pf->pcVars=CopyFormulaList(pf1->pcVars);
formula.c:		if(pf1->pcGenLit)
formula.c:			pf->pcGenLit=CopyFormulaList(pf1->pcGenLit);
formula.c:		if(pf1->pcArgs)
formula.c:			pf->pcArgs=CopyFormulaList(pf1->pcArgs);
formula.c:	pf1=pcFormula->pfForm;
formula.c:	pc->pfForm=pf=(FORMULAP)CopyAlloc(pf1,sizeof(FORMULA));
formula.c://	pf->psName=pf1->psName;
formula.c:	switch(pf1->nType)
formula.c:			pf->uValue.plList=CopyList(pf1->uValue.plList);
formula.c:			pf->uValue.piISpec=(ISPECP)CopyAlloc(pf1->uValue.piISpec,sizeof(ISPEC));
formula.c:	if(pf1->pcVars)
formula.c:		pf->pcVars=CopyFormulaList(pf1->pcVars);
formula.c:	if(pf1->pcGenLit)
formula.c:		pf->pcGenLit=CopyFormulaList(pf1->pcGenLit);
formula.c:	if(pf1->pcArgs)
formula.c:		pf->pcArgs=CopyFormulaList(pf1->pcArgs);
formula.c:	for(pc=pcFormula;pc;pc=pc->pcNext)
formula.c:		MarkForm(pc->pfForm);
formula.c:		ZoneMark(pc->pfForm);
formula.c:		MarkForm(pcFormula->pfForm);
formula.c:		ZoneMark(pcFormula->pfForm);
formula.c://		if(pf->psName)
formula.c://			ZoneMark(pf->psName);
formula.c:		switch(pf->nType)
formula.c:				ZoneMark(pf->uValue.piISpec);
formula.c:				ZoneMark(pf->uValue.poOperator);
formula.c:				pai=pf->uValue.paiArrayInfo;
formula.c://				ZoneMark(pai->psName);
formula.c:				ZoneMark(pai->pnLimits);
formula.c:				ZoneMark(pai->pnMultipliers);
formula.c:				ZoneMark(pai->ppcArray);
formula.c:				ppc=pai->ppcArray;
formula.c:				for(i=0;i<pai->nCount;i++)
formula.c:		if(pf->pcVars)
formula.c:			MarkFormulaList(pf->pcVars);
formula.c:		if(pf->pcGenLit)
formula.c:			MarkFormulaList(pf->pcGenLit);	/* pcGenLit can point to local variables! */
formula.c:		if(pf->pcArgs)
formula.c:			MarkFormulaList(pf->pcArgs);
formula.c:/* FormulaListSizeOf -----------------------------------------------------------
formula.c:	for(pc=pcFormula;pc;pc=pc->pcNext)
formula.c:		if(!ZoneMarkedQ(pc->pfForm))
formula.c:			*pnSize+=ZoneSizeOf(pc->pfForm);
formula.c:		FormSizeOf(pc->pfForm,pnSize);
formula.c:		MarkForm(pc->pfForm);
formula.c:		ZoneMark(pc->pfForm);
formula.c:		if(!ZoneMarkedQ(pcFormula->pfForm))
formula.c:			*pnSize+=ZoneSizeOf(pcFormula->pfForm);
formula.c:		FormSizeOf(pcFormula->pfForm,pnSize);
formula.c:		MarkForm(pcFormula->pfForm);
formula.c:		ZoneMark(pcFormula->pfForm);
formula.c:		switch(pf->nType)
formula.c:				if(!ZoneMarkedQ(pf->uValue.piISpec))
formula.c:					*pnSize+=ZoneSizeOf(pf->uValue.piISpec);
formula.c:					ZoneMark(pf->uValue.piISpec);
formula.c:				if(!ZoneMarkedQ(pf->uValue.poOperator))
formula.c:					*pnSize+=ZoneSizeOf(pf->uValue.poOperator);
formula.c:					ZoneMark(pf->uValue.poOperator);
formula.c:				pai=pf->uValue.paiArrayInfo;
formula.c:				if(!ZoneMarkedQ(pai->pnLimits))
formula.c:					*pnSize+=ZoneSizeOf(pai->pnLimits);
formula.c:					ZoneMark(pai->pnLimits);
formula.c:				if(!ZoneMarkedQ(pai->pnMultipliers))
formula.c:					*pnSize+=ZoneSizeOf(pai->pnMultipliers);
formula.c:					ZoneMark(pai->pnMultipliers);
formula.c:				if(!ZoneMarkedQ(pai->ppcArray))
formula.c:					*pnSize+=ZoneSizeOf(pai->ppcArray);
formula.c:					ZoneMark(pai->ppcArray);
formula.c:				ppc=pai->ppcArray;
formula.c:				for(i=0;i<pai->nCount;i++)
formula.c:		if(pf->pcVars)
formula.c:			FormulaListSizeOf(pf->pcVars,pnSize);
formula.c:			MarkFormulaList(pf->pcVars);
formula.c:		if(pf->pcGenLit)
formula.c:			FormulaListSizeOf(pf->pcGenLit,pnSize);	/* pcGenLit can point to local variables! */
formula.c:			MarkFormulaList(pf->pcGenLit);	/* pcGenLit can point to local variables! */
formula.c:		if(pf->pcArgs)
formula.c:			FormulaListSizeOf(pf->pcArgs,pnSize);
formula.c:			MarkFormulaList(pf->pcArgs);
formula.c:/* AppendFormula --------------------------------------------------------------
formula.c:		for(pc=pcFirst;pc;pc=pc->pcNext)
formula.c:			pcEnd=pcEnd->pcNext=(CELLP)MemAlloc(sizeof(CELL));
formula.c:			pcEnd->pfForm=pc->pfForm;
formula.c:		for(pcEnd=pcFirst;pcEnd->pcNext;pcEnd=pcEnd->pcNext);	/* find end of first list */
formula.c:	pcEnd->pcNext=pcSecond;
formula.c:		pc2=pc1->pcNext;
formula.c:		pc1->pcNext=pc3;
formula.c:		for(pc1=pcFormula1;pc1;pc1=pc1->pcNext)
formula.c:			for(pc2=pcFormula2;pc2;pc2=pc2->pcNext)
formula.c:				pcEnd=pcEnd->pcNext=CopyCell(pc1);
formula.c:	for(pc1=pcList1;pc1;pc1=pc1->pcNext)
formula.c:		for(pc2=pcList2;pc2;pc2=pc2->pcNext)
formula.c:				pcEnd=pcEnd->pcNext=CopyCell(pc2);
formula.c:	for(pc1=pcList1;pc1;pc1=pc1->pcNext)
formula.c:		for(pc2=pcList2;pc2;pc2=pc2->pcNext)
formula.c:		for(pc1=pcList1;pc1;pc1=pc1->pcNext)
formula.c:			for(pc2=pcList2;pc2;pc2=pc2->pcNext)
formula.c:				pc2->pcNext=pcStart;
formula.c:		pc1=pc1->pcNext,pc2=pc2->pcNext
formula.c:	if(pcFormula1==pcFormula2||pcFormula1->pfForm==pcFormula2->pfForm)
formula.c:	if(pcFormula1->pfForm->nType==ATOM_INTEGER)
formula.c:		if(pcFormula2->pfForm->nType==ATOM_INTEGER)
formula.c:			return pcFormula1->pfForm->uValue.nInteger==pcFormula2->pfForm->uValue.nInteger;
formula.c:		else if(pcFormula2->pfForm->nType==ATOM_FLOAT)
formula.c:			return pcFormula1->pfForm->uValue.nInteger==pcFormula2->pfForm->uValue.dfFloat;
formula.c:	else if(pcFormula1->pfForm->nType==ATOM_FLOAT)
formula.c:		if(pcFormula2->pfForm->nType==ATOM_INTEGER)
formula.c:			return pcFormula1->pfForm->uValue.dfFloat==pcFormula2->pfForm->uValue.nInteger;
formula.c:		else if(pcFormula2->pfForm->nType==ATOM_FLOAT)
formula.c:			return pcFormula1->pfForm->uValue.dfFloat==pcFormula2->pfForm->uValue.dfFloat;
formula.c:	else if(pcFormula1->pfForm->nType==ATOM_STRING)
formula.c:		if(!StringEqQ(pcFormula1->pfForm->psName,pcFormula2->pfForm->psName))
formula.c:		if(!StringEqQ(IdentName(pcFormula1->pfForm),IdentName(pcFormula2->pfForm)))
formula.c:	if(pcFormula1->pfForm->pcVars)
formula.c:		if(!FormulaListEqQ(pcFormula1->pfForm->pcVars,pcFormula2->pfForm->pcVars))
formula.c:	else if(pcFormula2->pfForm->pcVars)
formula.c:	if(pcFormula1->pfForm->pcGenLit)
formula.c:		if(!FormulaListEqQ(pcFormula1->pfForm->pcGenLit,pcFormula2->pfForm->pcGenLit))
formula.c:	else if(pcFormula2->pfForm->pcGenLit)
formula.c:	if(pcFormula1->pfForm->pcArgs)
formula.c:		if(!FormulaListEqQ(pcFormula1->pfForm->pcArgs,pcFormula2->pfForm->pcArgs))
formula.c:	else if(pcFormula2->pfForm->pcArgs)
formula.c:	for(pc=pcFormula;pc;pc=pc->pcNext)
formula.c:/* Formula Print Routines ------------------------------------------------------ */
formula.c:	if(pcFormula->pcNext)
formula.c:		for(pc=pcFormula;pc;pc=pc->pcNext)
formula.c:			if(pc->pcNext)
formula.c:		if(pcFormula->pfForm->pcVars)
formula.c:			for(pc=pcFormula->pfForm->pcVars;pc;pc=pc->pcNext)
formula.c:				if(pc->pcNext)
formula.c:		for(pc=pcFormula->pfForm->pcGenLit;pc;pc=pc->pcNext)
formula.c:			if(pc->pfForm->pcArgs||pc->pfForm->pcVars||pc->pfForm->pcGenLit)
formula.c:		for(pc=pcFormula->pfForm->pcArgs;pc;pc=pc->pcNext)
formula.c:			if(pc->pfForm->pcArgs||pc->pfForm->pcVars||pc->pfForm->pcGenLit)
formula.c:	switch(pcFormula->pfForm->nType)
formula.c:			ps=GetName(pcFormula->pfForm,ac);
formula.c:			ps=GetName(pcFormula->pfForm,ac);
formula.c:				po=pcFormula->pfForm->uValue.poOperator;
formula.c:				PrintFormula(pfStream,po->pcName,nLevel);
formula.c:			PrintList(pfStream,pcFormula->pfForm->uValue.plList,nLevel+1);
formula.c:				pcFormula->pfForm->nType);
formula.c:		if(pcFormula->pfForm->pcVars)
formula.c:			for(pc=pcFormula->pfForm->pcVars;pc;pc=pc->pcNext)
formula.c:				if(pc->pcNext)
formula.c:		for(pc=pcFormula->pfForm->pcGenLit;pc;pc=pc->pcNext)
formula.c:			if(pc->pfForm->pcArgs||pc->pfForm->pcVars||pc->pfForm->pcGenLit)
formula.c:		for(pc=pcFormula->pfForm->pcArgs;pc;pc=pc->pcNext)
formula.c:			if(pc->pfForm->pcArgs||pc->pfForm->pcVars||pc->pfForm->pcGenLit)
formula.c:	switch(pcFormula->pfForm->nType)
formula.c:			ps=GetName(pcFormula->pfForm,ac);
formula.c:			ps=GetName(pcFormula->pfForm,ac);
formula.c:				po=pcFormula->pfForm->uValue.poOperator;
formula.c:				PrintFlatFormula(pfStream,po->pcName);
formula.c://			PrintList(pfStream,pcFormula->pfForm->uValue.plList,1);
formula.c:				pcFormula->pfForm->nType);
formula.c:/* FormulaToInteger ------------------------------------------------------------
formula.c:		TermError("formula-to-integer",pcTerm,pbBindings);
formula.c:	switch(pcValue->pfForm->nType)
formula.c:			*pnValue=pcValue->pfForm->uValue.nInteger;
formula.c:			if(pcValue->pfForm->uValue.dfFloat<0.0)
formula.c:				*pnValue=(int)(pcValue->pfForm->uValue.dfFloat-0.5);
formula.c:				*pnValue=(int)(pcValue->pfForm->uValue.dfFloat+0.5);
formula.c:		TermError("formula-to-double",pcTerm,pbBindings);
formula.c:	switch(pcValue->pfForm->nType)
formula.c:			*pdfValue=(double)pcValue->pfForm->uValue.nInteger;
formula.c:			*pdfValue=pcValue->pfForm->uValue.dfFloat;
formula.c:		TermError("formula-to-string",pcTerm,pbBindings);
formula.c:	switch(pcValue->pfForm->nType)
formula.c:			*ppsValue=pcValue->pfForm->uValue.psString;
formula.c:/* ArgListCheck ----------------------------------------------------------------
formula.c:			for(pc=pcFormula->pfForm->pcArgs;pc;pc=pc->pcNext)
formula.c:				if(!pc->pfForm->paAction->pfEval&&!pc->pfForm->paAction->pfProgress)			/* if non-predicate */
formula.c:						GetName(pcFormula->pfForm,ac),n,GetName(pc->pfForm,ac));
formula.c:			for(pc=pcFormula->pfForm->pcVars;pc;pc=pc->pcNext)
formula.c:				if(!VarQ(pc))			/* if non-variable */
formula.c:						GetName(pcFormula->pfForm,ac),n,GetName(pc->pfForm,ac));
formula.c:			for(pc=pcFormula->pfForm->pcArgs;pc;pc=pc->pcNext)
formula.c:				if(pc->pfForm->nType!=ATOM_IDENT&&
formula.c:					pc->pfForm->nType!=ATOM_INTEGER&&
formula.c:					pc->pfForm->nType!=ATOM_FLOAT&&
formula.c:					pc->pfForm->nType!=ATOM_STRING&&
formula.c:					!pc->pfForm->paAction->pfCompute)
formula.c:						GetName(pcFormula->pfForm,ac),n,GetName(pc->pfForm,ac));
formula.c:			for(pc=pcFormula->pfForm->pcArgs;pc;pc=pc->pcNext)
formula.c:				if(StringEqQ(IdentName(pc->pfForm),apsStringTab[STRING_EQ]))	/* if function equate */
formula.c:					pc1=pc->pfForm->pcArgs;
formula.c:					if(pc1->pfForm->nType!=ATOM_SYMBOLINFOP||
formula.c:						!DescribedQ(pc1->pfForm->uValue.psiSymbolInfo)||
formula.c:						!FunctionQ(pc1->pfForm->uValue.psiSymbolInfo))
formula.c:							GetName(pcFormula->pfForm,ac),n,GetName(pc1->pfForm,ac));
formula.c:				else if(pc->pfForm->nType!=ATOM_SYMBOLINFOP||
formula.c:					!DescribedQ(pc->pfForm->uValue.psiSymbolInfo))
formula.c:						GetName(pcFormula->pfForm,ac),n,GetName(pc->pfForm,ac));
formula.c:			ErrorMessage("%s arguments unchecked\n",GetName(pcFormula->pfForm,ac));
formula.c:	switch(pf->nType)
formula.c:			sprintf(acBuffer,"%f",pf->uValue.dfFloat);
formula.c:			for(ps=acBuffer+strlen(acBuffer);ps>acBuffer&&*ps=='0';--ps);
formula.c:			pf->psName=IdentAlloc(acBuffer);
formula.c:			sprintf(acBuffer,"%d",pf->uValue.nInteger);
formula.c:			pf->psName=IdentAlloc(acBuffer);
formula.c:			ErrorMessage("MakeName:  Unexpected atomic type: %d\n",pf->nType);
formula.c:	return pf->psName;
formula.c:	switch(pf->nType)
formula.c:			sprintf(acBuffer,"%f",pf->uValue.dfFloat);
formula.c:			for(ps=acBuffer+strlen(acBuffer);ps>acBuffer&&*ps=='0';--ps);
formula.c:			sprintf(acBuffer,"%d",pf->uValue.nInteger);
formula.c:			ErrorMessage("MakeName:  Unexpected atomic type: %d\n",pf->nType);
formula.c:/* Compile Routines --------------------------------------------------------- */
formula.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
formula.c:	pf->nType=ATOM_IDENT;
formula.c:	pf->paAction=paAction;
formula.c:	pf->psName=IdentAlloc(paAction->psName);
formula.c:	pf->pcArgs=pcArgs;
formula.c:	CELLP pcGenLit,						/* generator formula (such-that clause) */
formula.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
formula.c:	pf->nType=ATOM_IDENT;
formula.c:	pf->paAction=paAction;
formula.c:	pf->psName=IdentAlloc(paAction->psName);
formula.c:	pf->pcVars=pcVariables;
formula.c:	pf->pcGenLit=pcGenLit;
formula.c:		pcGenLit->pcNext=NULL;
formula.c:	pf->pcArgs=pcFormula;
formula.c:		pcFormula->pcNext=NULL;
formula.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
formula.c:	pf->nType=ATOM_IDENT;
formula.c:	pf->paAction=&aArrayAction;
formula.c:	pf->psName=IdentAlloc(psName);
formula.c:	pf->pcArgs=pcArgs;
formula.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
formula.c:	pf->nType=ATOM_IDENT;
formula.c:	pf->paAction=&aDummyAction;
formula.c:	pf->psName=IdentAlloc(psName);
formula.c:	pf->pcArgs=pcArgs;
formula.c:	if(StringEqQ(IdentName(pcArg1->pfForm),apsStringTab[STRING_LPAREN]))
formula.c:		pi->bLowerOpen=TRUE;
formula.c:	switch(pcArg2->pfForm->nType)
formula.c:			pi->dfLower=(double)pcArg2->pfForm->uValue.nInteger;
formula.c:			pi->dfLower=pcArg2->pfForm->uValue.dfFloat;
formula.c:			pi->bLowerInfinite=TRUE;
formula.c:				pcArg2->pfForm->nType);
formula.c:	switch(pcArg3->pfForm->nType)
formula.c:			pi->dfUpper=(double)pcArg3->pfForm->uValue.nInteger;
formula.c:			pi->dfUpper=pcArg3->pfForm->uValue.dfFloat;
formula.c:			pi->bUpperInfinite=TRUE;
formula.c:				pcArg3->pfForm->nType);
formula.c:	if(StringEqQ(IdentName(pcArg4->pfForm),apsStringTab[STRING_RPAREN]))
formula.c:		pi->bUpperOpen=TRUE;
formula.c:	if(!pi->bLowerInfinite&&!pi->bUpperInfinite&&pi->dfLower>pi->dfUpper)
formula.c:			GetName(pcArg2->pfForm,ac),GetName(pcArg3->pfForm,ac));
formula.c:		GetName(pcArg1->pfForm,ac),GetName(pcArg2->pfForm,ac),
formula.c:		GetName(pcArg3->pfForm,ac),GetName(pcArg4->pfForm,ac));
formula.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
formula.c:	pf->nType=ATOM_ISPECP;
formula.c:	pf->paAction=&aISpecAction;
formula.c:	pf->psName=IdentAlloc(acBuffer);
formula.c:	pf->uValue.piISpec=pi;
formula.c:	CELLP pcGenLit						/* generator formula (such-that clause) */
formula.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
formula.c:	pf->nType=ATOM_IDENT;
formula.c:	pf->paAction=&aVarGenAction;
formula.c:	pf->psName=IdentAlloc(pf->paAction->psName);
formula.c:	pf->pcVars=pcVariables;
formula.c:	pf->pcGenLit=pcGenLit;
formula.c:	pcGenLit->pcNext=NULL;
formula.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
formula.c:	pf->nType=ATOM_IDENT;
formula.c:	pf->paAction=&aPreAction;
formula.c:	pf->psName=IdentAlloc(pf->paAction->psName);
formula.c:	pf->pcVars=pcVarGens;
formula.c:	pf->pcArgs=pcFormula;
formula.c:		pcFormula->pcNext=NULL;
formula.c:		pc1=pc->pcNext;					/* ZoneCopy clobbers pcNext field */
formula.c:		pf=pc->pfForm;
formula.c:		if(pf->psName)
formula.c:			ZoneCopy(pf->psName);
formula.c:		switch(pf->nType)
formula.c:				if(pf->uValue.plList)
formula.c:					ZoneCopyList(pf->uValue.plList);
formula.c:				if(pf->uValue.piISpec)
formula.c:					ZoneCopy(pf->uValue.piISpec);
formula.c:		if(pf->pcVars)
formula.c:			ZoneCopyFormulaList(pf->pcVars);
formula.c:		if(pf->pcGenLit)
formula.c:			ZoneCopyFormulaList(pf->pcGenLit);
formula.c:		if(pf->pcArgs)
formula.c:			ZoneCopyFormulaList(pf->pcArgs);
formula.c:	pf=pcFormula->pfForm;
formula.c:	if(pf->psName)
formula.c:		ZoneCopy(pf->psName);
formula.c:	switch(pf->nType)
formula.c:			if(pf->uValue.plList)
formula.c:				ZoneCopyList(pf->uValue.plList);
formula.c:			if(pf->uValue.piISpec)
formula.c:				ZoneCopy(pf->uValue.piISpec);
formula.c:	if(pf->pcVars)
formula.c:		ZoneCopyFormulaList(pf->pcVars);
formula.c:	if(pf->pcGenLit)
formula.c:		ZoneCopyFormulaList(pf->pcGenLit);
formula.c:	if(pf->pcArgs)
formula.c:		ZoneCopyFormulaList(pf->pcArgs);
formula.c:		pc1=pc->pcNext;					/* ZoneReloc clobbers pcNext */
formula.c:		if(pc->pcNext)
formula.c:			ZoneReloc((void **)&pc->pcNext);
formula.c:		ZoneReloc((void **)&pc->pfForm);
formula.c:		pf=pc->pfForm;
formula.c:		if(pf->psName)
formula.c:			ZoneReloc((void **)&pf->psName);
formula.c:		switch(pf->nType)
formula.c:				if(pf->uValue.plList)
formula.c:					ZoneReloc((void **)&pf->uValue.plList);
formula.c:					ZoneRelocList(pf->uValue.plList);
formula.c:				if(pf->uValue.piISpec)
formula.c:					ZoneReloc((void **)&pf->uValue.piISpec);
formula.c:		if(pf->pcVars)
formula.c:			ZoneReloc((void **)&pf->pcVars);
formula.c:			ZoneRelocFormulaList(pf->pcVars);
formula.c:		if(pf->pcGenLit)
formula.c:			ZoneReloc((void **)&pf->pcGenLit);
formula.c:			ZoneRelocFormulaList(pf->pcGenLit);
formula.c:		if(pf->pcArgs)
formula.c:			ZoneReloc((void **)&pf->pcArgs);
formula.c:			ZoneRelocFormulaList(pf->pcArgs);
formula.c:	if(pcFormula->pcNext)
formula.c:		ZoneReloc((void **)&pcFormula->pcNext);
formula.c:	ZoneReloc((void **)&pcFormula->pfForm);
formula.c:	pf=pcFormula->pfForm;
formula.c:	if(pf->psName)
formula.c:		ZoneReloc((void **)&pf->psName);
formula.c:	switch(pf->nType)
formula.c:			if(pf->uValue.plList)
formula.c:				ZoneReloc((void **)&pf->uValue.plList);
formula.c:				ZoneRelocList(pf->uValue.plList);
formula.c:			if(pf->uValue.piISpec)
formula.c:				ZoneReloc((void **)&pf->uValue.piISpec);
formula.c:	if(pf->pcVars)
formula.c:		ZoneReloc((void **)&pf->pcVars);
formula.c:		ZoneRelocFormulaList(pf->pcVars);
formula.c:	if(pf->pcGenLit)
formula.c:		ZoneReloc((void **)&pf->pcGenLit);
formula.c:		ZoneRelocFormulaList(pf->pcGenLit);
formula.c:	if(pf->pcArgs)
formula.c:		ZoneReloc((void **)&pf->pcArgs);
formula.c:		ZoneRelocFormulaList(pf->pcArgs);
gate.c:/* gate.c -- instrumentation routines
gate.c:Copyright C, 1996 - 99  F. Bacchus
gate.c:			psName,pnNameStack->psName);
gate.c:	pn->pnNext=pnNameStack;
gate.c:	pn->psName=ps;
gate.c:	if(strcmp(psName,pnNameStack->psName))
gate.c:		CommandPrintf(stderr,"Exiting %s from %s\n",psName,pnNameStack->psName);
gate.c:	pnNameStack=pn->pnNext;
gate.c:	Free(pn->psName);
hash.c:Copyright c, 1997 - 2001 F. Bacchus
hash.c:	the size of the table.  (If the table length is non-prime,
hash.c:	The sentinel value for a deleted key is a key pointer of -1.
hash.c:	requires just one probe to insert is 1-f
hash.c:	The chance that 2 probes are required is f(1-f)
hash.c:	The chance that 3 probes are required is f^2(1-f)
hash.c:	In general the chance that k probes are required is f^(k-1)(1-f)
hash.c:	(1-f) + 2f(1-f) + 3f^2(1-f) + ... = 1/(1-f)
hash.c:	insertion time) for a single entry is the average of 1/(1-f) as f varies 
hash.c:	-(ln(1-F))/F
hash.c:const int anFibonacci[16]=				/* table of 24-bit fibonacci coefficients */
hash.c:	pht->pavTable=pavTable;
hash.c:	pht->nSize=nSize;
hash.c:	pht->nRecLen=nRecLen;
hash.c:	pht->nLimit=nLimit;
hash.c:	pht->nCount=0;
hash.c:	htNew.nLimit=phtOld->nLimit*2;
hash.c:	htNew.nRecLen=phtOld->nRecLen;
hash.c:	pcCursor=(char *)phtOld->pavTable;
hash.c:	for(i=0;i<phtOld->nSize;i++)
hash.c:		if(*(char **)pcCursor!=NULL&&*(char **)pcCursor!=(char *)-1)
hash.c:		pcCursor+=phtOld->nRecLen;
hash.c:	if(pht->pavTable)
hash.c:		memset(pht->pavTable,0,pht->nSize*pht->nRecLen);
hash.c:	pht->nCount=0;
hash.c:	if(pht->nCount>=pht->nLimit)
hash.c:	pcCursor=pcStart=(char *)pht->pavTable+Hash(pht->nSize,psKey)*pht->nRecLen;
hash.c:		pht->nCount++;
hash.c:	if(*(char **)pcCursor==(char *)-1)	/* if deleted entry */
hash.c:	nSize=pht->nSize*pht->nRecLen;
hash.c:	pcLimit=(char *)pht->pavTable+nSize;
hash.c:	nCycle=ReHash(pht->nSize,psKey)*pht->nRecLen;
hash.c:		pcCursor-=nSize;
hash.c:			pht->nCount++;
hash.c:		if(*(char **)pcCursor==(char *)-1)
hash.c:			pcCursor-=nSize;
hash.c:	pcCursor=pcStart=(char *)pht->pavTable+Hash(pht->nSize,psKey)*pht->nRecLen;
hash.c:	if(*(char **)pcCursor!=(char *)-1)	/* if not deleted entry */
hash.c:	nSize=pht->nSize*pht->nRecLen;
hash.c:	pcLimit=(char *)pht->pavTable+nSize;
hash.c:	nCycle=ReHash(pht->nSize,psKey)*pht->nRecLen;
hash.c:		pcCursor-=nSize;
hash.c:		if(*(char **)pcCursor!=(char *)-1)
hash.c:			pcCursor-=nSize;
hash.c:	pcCursor=pcStart=(char *)pht->pavTable+Hash(pht->nSize,psKey)*pht->nRecLen;
hash.c:	if(*(char **)pcCursor!=(char *)-1)	/* if not deleted entry */
hash.c:			*(char **)pcCursor=(char *)-1;	/* mark slot deleted */
hash.c:			pht->nCount--;
hash.c:	nSize=pht->nSize*pht->nRecLen;
hash.c:	pcLimit=(char *)pht->pavTable+nSize;
hash.c:	nCycle=ReHash(pht->nSize,psKey)*pht->nRecLen;
hash.c:		pcCursor-=nSize;
hash.c:		if(*(char **)pcCursor!=(char *)-1)
hash.c:				*(char **)pcCursor=(char *)-1;	/* mark slot deleted */
hash.c:				pht->nCount--;
hash.c:			pcCursor-=nSize;
hash.c:	pcCursor=(char *)pht->pavTable;
hash.c:	for(i=0;i<pht->nSize;i++)
hash.c:		if(*(char **)pcCursor!=NULL&&*(char **)pcCursor!=(char *)-1)
hash.c:		pcCursor+=pht->nRecLen;
hash.c:	if(n!=pht->nCount)
hash.c:	pcCursor=(char *)pht->pavTable;
hash.c:	for(i=0;i<pht->nSize;i++)
hash.c:		if(*(char **)pcCursor!=NULL&&*(char **)pcCursor!=(char *)-1)
hash.c:		pcCursor+=pht->nRecLen;
hash.c:	Here we select the fibonacci element using bits 12-15 of
hash.c:	We return a number between 0 and count-1.
hash.c:	We return a number between 1 and count-1;
hash.c:	that we don't generate a nil-potent collision ring... that
hash.c:	every non-nil-potent collision ring is the size of the entire hash table.
hash.c:	return(nValue%(nCount-1)+1);
hash.c:// Resizeable Table Support ----------------------------------------------------
hash.c://	prt->pavTable=pavTable;
hash.c://	prt->nSize=nSize;
hash.c://	prt->nRecLen=nRecLen;
hash.c://	prt->nCount=0;
hash.c:	pavTable=(void **)MemAlloc(2*prt->nSize*prt->nRecLen);
hash.c:	memcpy(pavTable,prt->pavTable,prt->nSize*prt->nRecLen);
hash.c:	prt->pavTable=pavTable;
hash.c:	prt->nSize*=2;
hash.c://	fprintf(stderr,"Expanding resizeable table to %d cells\n",prt->nSize);
hash.c://	if(prt->pavTable)
hash.c://		memset(prt->pavTable,0,prt->nSize*prt->nRecLen);
hash.c://	prt->nCount=0;
hash.c://	if(prt->nCount>=prt->nSize)
hash.c://	*ppvRec=(void *)((char *)prt->pavTable+prt->nCount*prt->nRecLen);
hash.c://	prt->nCount++;
heap.c:	Heap support routines for best-first search open list.
heap.c:	The routines are specific to best-first search.  They are not general purpose!
heap.c:	if(nLeft<=nHeapCount&&MergeCompareFn(pplpHeap[nLeft-1],pplpHeap[nNode-1])==-1)
heap.c:	if(nRight<=nHeapCount&&MergeCompareFn(pplpHeap[nRight-1],pplpHeap[nSmallest-1])==-1)
heap.c:		plp=pplpHeap[nNode-1];			// exchange nodes
heap.c:		pplpHeap[nNode-1]=pplpHeap[nSmallest-1];
heap.c:		pplpHeap[nSmallest-1]=plp;
heap.c:	for(i=nHeapCount/2;i>0;--i)
heap.c:	for(i=nHeapCount;i>1;--i)
heap.c:		--nHeapCount;					// shorten heap
heap.c:	--nHeapCount;
heap.c:	for(i=nHeapCount;i>1&&MergeCompareFn(pplpHeap[Parent(i)-1],plpNode)==1;i=Parent(i))
heap.c:		pplpHeap[i-1]=pplpHeap[Parent(i)-1];
heap.c:	pplpHeap[i-1]=plpNode;
heap.c:	--nHeapCount;
idle.c:Copyright C, 1996 - 2001  F. Bacchus
idle.c:/* Run Time Routines ----------------------------------------------------------- */
idle.c:(define (idle-formula form world/action bindings)
idle.c:	(let ((dispatch-fn (lookup-idle-eval (get-operator form))))
idle.c:	  (if dispatch-fn
idle.c:		  (dispatch-fn form world/action bindings)
idle.c:		(eval-atomic (get-operator form)
idle.c:					 (eval-terms (get-args form) world/action bindings)
idle.c:	b=(*pcFormula->pfForm->paAction->pfIdle)(pcFormula,plpLinearPlan,pbBindings);
idle.c:(define (idle-and form world/action bindings)
idle.c:  (every (lambda (formula) (idle-formula formula world/action bindings))
idle.c:	 (get-args form)))
idle.c:	for(pc=pcFormula->pfForm->pcArgs;pc;pc=pc->pcNext)
idle.c:(define (idle-or form world/action bindings)
idle.c:  (some (lambda (formula) (idle-formula formula world/action bindings))
idle.c:		(get-args form)))
idle.c:	for(pc=pcFormula->pfForm->pcArgs;pc;pc=pc->pcNext)
idle.c:(define (idle-xor form world/action bindings)
idle.c:  (do ((found-one? #f)
idle.c:	   (args (get-args form))
idle.c:	  ((null? args) (and found-one? (not false?)))
idle.c:	(if (idle-formula arg world/action bindings)
idle.c:	(if found-one? (set! false? #t) (set! found-one? #t)))))
idle.c:	for(pc=pcFormula->pfForm->pcArgs;pc;pc=pc->pcNext)
idle.c:(define (idle-implies form world/action bindings)
idle.c:  (if (idle-formula (first (get-args form)) world/action bindings)
idle.c:	  (idle-formula (second (get-args form)) world/action bindings)
idle.c:	pc=pcFormula->pfForm->pcArgs;
idle.c:		b=IdleFormula(pc->pcNext,plpLinearPlan,pbBindings);
idle.c:(define (idle-if-then-else form world/action bindings)
idle.c:  (let ((args (get-args form)))
idle.c:	(if (idle-formula (first args) world/action bindings)
idle.c:		(idle-formula (second args) world/action bindings)
idle.c:	(idle-formula (third args) world/action bindings))))
idle.c:	pc=pcFormula->pfForm->pcArgs;
idle.c:		b=IdleFormula(pc->pcNext,plpLinearPlan,pbBindings);
idle.c:		b=IdleFormula(pc->pcNext->pcNext,plpLinearPlan,pbBindings);
idle.c:(define (idle-not form world/action bindings)
idle.c:  (not (idle-formula (first (get-args form)) world/action bindings)))
idle.c:	b=!IdleFormula(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings);
idle.c:/* Temporal Formulas ----------------------------------------------------------- */
idle.c:(define (idle-ignore-op form world/action bindings)
idle.c:  (idle-formula (first (get-args form)) world/action bindings))
idle.c:	b=IdleFormula(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings);
idle.c:(define (idle-until form world/action bindings)
idle.c:  (idle-formula (second (get-args form)) world/action bindings))
idle.c:	b=IdleFormula(pcFormula->pfForm->pcArgs->pcNext,plpLinearPlan,pbBindings);
idle.c:/*  MTL Timed Temporal Formulas ------------------------------------------------ */
idle.c:(define (idle-t-always form world/action bindings)
idle.c:  (if (ispec<0 (get-bf-ispec form))
idle.c:	  (idle-formula
idle.c:	   (first (get-bf-formulas form)) world/action bindings)))
idle.c:	if(ISpecLt0(GetBFISpec(pcFormula)->pfForm->uValue.piISpec))
idle.c:(define (idle-delta form world/action bindings)
idle.c:	(let* ((formula (get-delta-formula form))
idle.c:			(ispec (get-bf-ispec formula)))
idle.c:		(idle-formula
idle.c:				(list (get-operator formula)
idle.c:					(ispec-lshift ispec
idle.c:						(world/action-action-duration world/action)))
idle.c:				(get-bf-formulas formula))
idle.c:	pcShiftedForm=CopyCell(pcFormula->pfForm->pcArgs);
idle.c:	pcShiftedForm->pfForm=CopyAlloc(pcShiftedForm->pfForm,sizeof(FORMULA));
idle.c:	pcISpec=pcShiftedForm->pfForm->pcArgs;
idle.c:	pcTail=pcISpec->pcNext;
idle.c:	pcISpec->pcNext=pcTail;
idle.c:	pcShiftedForm->pfForm->pcArgs=pcISpec;
idle.c://	piISpec=GetBFISpec(pcForm)->pfForm->uValue.piISpec;
idle.c://	pcShiftedForm->pfForm=pcForm->pfForm;
idle.c://	pcShiftedForm->pfForm->pcArgs->pfForm->uValue.piISpec=
idle.c:(define (idle-t-eventually form world/action bindings)
idle.c:  (if (ispec<0  (get-bf-ispec form))
idle.c:	  (idle-formula
idle.c:	   (first (get-bf-formulas form)) world/action bindings)))
idle.c:	if(ISpecLt0(GetBFISpec(pcFormula)->pfForm->uValue.piISpec))
idle.c:(define (idle-t-until form world/action bindings)
idle.c:  (if (ispec<0 (get-bf-ispec form))
idle.c:	  (idle-formula
idle.c:	   (second (get-bf-formulas form)) world/action bindings)))
idle.c:	if(ISpecLt0(GetBFISpec(pcFormula)->pfForm->uValue.piISpec))
idle.c:		b=IdleFormula(GetBFFormulas(pcFormula)->pcNext,plpLinearPlan,pbBindings);
idle.c:/* Quantified Formulas --------------------------------------------------------- */
idle.c:(define (idle-forall form world/action bindings)
idle.c:		((args (get-args form))
idle.c:			(variables (get-qf-variables args))
idle.c:			(gen-lit (get-qf-generator args))
idle.c:			(formula (get-qf-formula args))
idle.c:		(set! bindings (extend-pbBindings variables variables bindings))
idle.c:		(set! generator (make-generator gen-lit variables world/action bindings))
idle.c:						(if (not (idle-formula formula world/action bindings))
idle.c:	pcVars=pcFormula->pfForm->pcVars;
idle.c:	pcGenLit=pcFormula->pfForm->pcGenLit;
idle.c:	pcQfFormula=pcFormula->pfForm->pcArgs;
idle.c:	while((*pcGenLit->pfForm->paAction->pfGenerator)
idle.c://		(pcGenLit,&(pbBindings->pvContext),pcVars,plpLinearPlan,pbBindings))
idle.c:(define (idle-exists form world/action bindings)
idle.c:  (let* ((args (get-args form))
idle.c:		 (variables (get-qf-variables args))
idle.c:		 (gen-lit   (get-qf-generator args))
idle.c:		 (formula   (get-qf-formula args))
idle.c:	(set! bindings (extend-pbBindings variables variables bindings))
idle.c:	  (make-generator gen-lit variables world/action bindings))
idle.c:			(idle-formula formula world/action bindings))
idle.c:	pcVars=pcFormula->pfForm->pcVars;
idle.c:	pcGenLit=pcFormula->pfForm->pcGenLit;
idle.c:	pcQfFormula=pcFormula->pfForm->pcArgs;
idle.c:	while((*pcGenLit->pfForm->paAction->pfGenerator)
idle.c://		(pcGenLit,&(pbBindings->pvContext),pcVars,plpLinearPlan,pbBindings))
idle.c:(define (idle-exists! form world/action bindings)
idle.c:	(let* ((args (get-args form))
idle.c:			(variables (get-qf-variables args))
idle.c:			(gen-lit (get-qf-generator args))
idle.c:			(formula (get-qf-formula args))
idle.c:		(set! bindings (extend-pbBindings variables variables bindings))
idle.c:		(set! generator (make-generator gen-lit variables world/action bindings))
idle.c:			(do ((finish? #f) (result #f) (found-one? #f))
idle.c:							(idle-formula formula world/action bindings))
idle.c:							(found-one?
idle.c:							(else (set! found-one? #t))))
idle.c:							(found-one?
idle.c:	pcVars=pcFormula->pfForm->pcVars;
idle.c:	pcGenLit=pcFormula->pfForm->pcGenLit;
idle.c:	pcQfFormula=pcFormula->pfForm->pcArgs;
idle.c:	while((*pcGenLit->pfForm->paAction->pfGenerator)
idle.c://		(pcGenLit,&(pbBindings->pvContext),pcVars,plpLinearPlan,pbBindings))
idle.c:/* Auxiliary Formulas ---------------------------------------------------------- */
idle.c:(define (idle-binding form world/action bindings)
idle.c:  (idle-formula
idle.c:   (get-binding-formula form)
idle.c:   (extend-pbBindings (get-binding-vars form)
idle.c:					(get-binding-vals form)
iface.c:Copyright C, 1996 - 2001  F. Bacchus
iface.c:/* Utility Routines ------------------------------------------------------------ */
iface.c:	A term is undefined, or mis-defined.
iface.c:	Message("Error, %s cannot be evaluated.\n",GetName(pcFormula->pfForm,ac));
iface.c:	Message("Error, %s cannot be idled.\n",GetName(pcFormula->pfForm,ac));
iface.c:	Message("Error, %s cannot be progressed.\n",GetName(pcFormula->pfForm,ac));
iface.c:	Message("Error, Cannot calculate the current value of %s.\n",GetName(pcFormula->pfForm,ac));
iface.c:	Message("Error, %s cannot be computed.\n",GetName(pcFormula->pfForm,ac));
iface.c:	Message("Error, %s cannot be used as a generator.\n",GetName(pcGenLit->pfForm,ac));
iface.c:	Message("Error, Cannot generate the current condition formula of %s.\n",GetName(pcForm->pfForm,ac));
iface.c:	Message("Error, %s hasn't been implemented in the current condition algorithm.\n",GetName(pcForm->pfForm,ac));
internal.c:Copyright C, 1997 - 99  F. Bacchus
internal.c:--------------------------------------------------------------------------------
internal.c:/* Arithmetic Routines --------------------------------------------------------- */
internal.c:	for(pc=pcFormula->pfForm->pcArgs;pc;pc=pc->pcNext)
internal.c:			TermError("compute-plus",pcFormula,pbBindings);
internal.c:			switch(pcValue->pfForm->nType)
internal.c:					nSum+=pcValue->pfForm->uValue.nInteger;
internal.c:					dfSum=nSum+pcValue->pfForm->uValue.dfFloat;
internal.c:					ErrorMessage("ComputePlus:  Invalid or non-numeric argument\n");
internal.c:			switch(pcValue->pfForm->nType)
internal.c:					dfSum+=pcValue->pfForm->uValue.nInteger;
internal.c:					dfSum+=pcValue->pfForm->uValue.dfFloat;
internal.c:					ErrorMessage("ComputePlus:  Invalid or non-numeric argument\n");
internal.c:	pc=pcFormula->pfForm->pcArgs;
internal.c:		TermError("compute-minus",pcFormula,pbBindings);
internal.c:	switch(pcValue->pfForm->nType)
internal.c:			nDifference=pcValue->pfForm->uValue.nInteger;
internal.c:			dfDifference=pcValue->pfForm->uValue.dfFloat;
internal.c:			ErrorMessage("ComputeMinus:  Invalid or non-numeric argument\n");
internal.c:	if(!pc->pcNext)
internal.c:			pc=MakeIntegerForm(-nDifference);
internal.c:			pc=MakeFloatForm(-dfDifference);
internal.c:	for(pc=pc->pcNext;pc;pc=pc->pcNext)
internal.c:			TermError("compute-minus",pcFormula,pbBindings);
internal.c:			switch(pcValue->pfForm->nType)
internal.c:					nDifference-=pcValue->pfForm->uValue.nInteger;
internal.c:					dfDifference=nDifference-pcValue->pfForm->uValue.dfFloat;
internal.c:					ErrorMessage("ComputeMinus:  Invalid or non-numeric argument\n");
internal.c:			switch(pcValue->pfForm->nType)
internal.c:					dfDifference-=pcValue->pfForm->uValue.nInteger;
internal.c:					dfDifference-=pcValue->pfForm->uValue.dfFloat;
internal.c:					ErrorMessage("ComputeMinus:  Invalid or non-numeric argument\n");
internal.c:	pc=pcFormula->pfForm->pcArgs;
internal.c:	for(;pc;pc=pc->pcNext)
internal.c:			TermError("compute-multiply",pcFormula,pbBindings);
internal.c:			switch(pcValue->pfForm->nType)
internal.c:					nProduct*=pcValue->pfForm->uValue.nInteger;
internal.c:					dfProduct=nProduct*pcValue->pfForm->uValue.dfFloat;
internal.c:					ErrorMessage("ComputeMultiply:  Invalid or non-numeric argument\n");
internal.c:			switch(pcValue->pfForm->nType)
internal.c:					dfProduct*=pcValue->pfForm->uValue.nInteger;
internal.c:					dfProduct*=pcValue->pfForm->uValue.dfFloat;
internal.c:					ErrorMessage("ComputeMultiply:  Invalid or non-numeric argument\n");
internal.c:	pc=pcFormula->pfForm->pcArgs;
internal.c:		TermError("compute-divide",pcFormula,pbBindings);
internal.c:	switch(pcValue->pfForm->nType)
internal.c:			nQuotient=pcValue->pfForm->uValue.nInteger;
internal.c:			dfQuotient=pcValue->pfForm->uValue.dfFloat;
internal.c:			ErrorMessage("ComputeDivide:  Invalid or non-numeric argument\n");
internal.c:	if(!pc->pcNext)
internal.c:	for(pc=pc->pcNext;pc;pc=pc->pcNext)
internal.c:			TermError("compute-divide",pcFormula,pbBindings);
internal.c:			switch(pcValue->pfForm->nType)
internal.c:					nDivisor=pcValue->pfForm->uValue.nInteger;
internal.c:					dfDivisor=pcValue->pfForm->uValue.dfFloat;
internal.c:					ErrorMessage("ComputeDivide:  Invalid or non-numeric argument\n");
internal.c:			switch(pcValue->pfForm->nType)
internal.c:					dfDivisor=pcValue->pfForm->uValue.nInteger;
internal.c:					dfDivisor=pcValue->pfForm->uValue.dfFloat;
internal.c:					ErrorMessage("ComputeDivide:  Invalid or non-numeric argument\n");
internal.c:	pc=pcFormula->pfForm->pcArgs;
internal.c:		TermError("compute-mod",pcFormula,pbBindings);
internal.c:	switch(pcValue->pfForm->nType)
internal.c:			dfRemainder=pcValue->pfForm->uValue.nInteger;
internal.c:			dfRemainder=pcValue->pfForm->uValue.dfFloat;
internal.c:			ErrorMessage("ComputeMod:  Invalid or non-numeric argument\n");
internal.c:	for(pc=pc->pcNext;pc;pc=pc->pcNext)
internal.c:			TermError("compute-mod",pcFormula,pbBindings);
internal.c:		switch(pcValue->pfForm->nType)
internal.c:				dfDivisor=pcValue->pfForm->uValue.nInteger;
internal.c:				dfDivisor=pcValue->pfForm->uValue.dfFloat;
internal.c:				ErrorMessage("ComputeMod:  Invalid or non-numeric argument\n");
internal.c:	pc=pcFormula->pfForm->pcArgs;
internal.c:	dfMax=-DBL_MAX;
internal.c:	for(;pc;pc=pc->pcNext)
internal.c:			TermError("compute-max",pcFormula,pbBindings);
internal.c:		switch(pcValue->pfForm->nType)
internal.c:				if(dfMax<pcValue->pfForm->uValue.nInteger)
internal.c:					dfMax=pcValue->pfForm->uValue.nInteger;
internal.c:				if(dfMax<pcValue->pfForm->uValue.dfFloat)
internal.c:					dfMax=pcValue->pfForm->uValue.dfFloat;
internal.c:				ErrorMessage("ComputeMax:  Invalid or non-numeric argument\n");
internal.c:	pc=pcFormula->pfForm->pcArgs;
internal.c:	for(;pc;pc=pc->pcNext)
internal.c:			TermError("compute-min",pcFormula,pbBindings);
internal.c:		switch(pcValue->pfForm->nType)
internal.c:				if(dfMin>pcValue->pfForm->uValue.nInteger)
internal.c:					dfMin=pcValue->pfForm->uValue.nInteger;
internal.c:				if(dfMin>pcValue->pfForm->uValue.dfFloat)
internal.c:					dfMin=pcValue->pfForm->uValue.dfFloat;
internal.c:				ErrorMessage("ComputeMin:  Invalid or non-numeric argument\n");
internal.c:	pc=pcFormula->pfForm->pcArgs;
internal.c:	if((*pc->pfForm->paAction->pfEval)(pc,plpLinearPlan,pbBindings))
internal.c:	    pc=pc->pcNext;
internal.c:	    pc=pc->pcNext->pcNext;
internal.c:	switch(pcValue->pfForm->nType)
internal.c:		pc=MakeIntegerForm(pcValue->pfForm->uValue.nInteger);
internal.c:		pc=MakeFloatForm(pcValue->pfForm->uValue.dfFloat);
internal.c:		ErrorMessage("conditional-exp:  Invalid or non-numeric argument\n");
internal.c:	pc=pcFormula->pfForm->pcArgs;
internal.c:		TermError("compute-expt",pcFormula,pbBindings);
internal.c:	switch(pcValue->pfForm->nType)
internal.c:			dfValue=pcValue->pfForm->uValue.nInteger;
internal.c:			dfValue=pcValue->pfForm->uValue.dfFloat;
internal.c:			ErrorMessage("ComputeExpt:  Invalid or non-numeric argument\n");
internal.c:	if(!pc->pcNext)
internal.c:	for(pc=pc->pcNext;pc;pc=pc->pcNext)
internal.c:			TermError("compute-expt",pcFormula,pbBindings);
internal.c:		switch(pcValue->pfForm->nType)
internal.c:				nPower=pcValue->pfForm->uValue.nInteger;
internal.c:						for(i=-1;i>nPower;i--)
internal.c:					ErrorMessage("ComputeExpt:  Non-integer power of negative value\n");
internal.c:					dfValue=exp(log(dfValue)*pcValue->pfForm->uValue.dfFloat);
internal.c:					if(pcValue->pfForm->uValue.dfFloat==0.0)
internal.c:				ErrorMessage("ComputeExpt:  Invalid or non-numeric argument\n");
internal.c:	pc=pcFormula->pfForm->pcArgs;
internal.c:		TermError("compute-sqrt",pcFormula,pbBindings);
internal.c:	switch(pcValue->pfForm->nType)
internal.c:			dfValue=pcValue->pfForm->uValue.nInteger;
internal.c:			dfValue=pcValue->pfForm->uValue.dfFloat;
internal.c:			ErrorMessage("ComputeSqrt:  Invalid or non-numeric argument\n");
internal.c:	pc=pcFormula->pfForm->pcArgs;
internal.c:	if(!pc->pcNext)
internal.c:			TermError("compute-abs",pcFormula,pbBindings);
internal.c:		switch(pcValue->pfForm->nType)
internal.c:				dfValue=pcValue->pfForm->uValue.nInteger;
internal.c:				dfValue=pcValue->pfForm->uValue.dfFloat;
internal.c:				ErrorMessage("ComputeAbs:  Invalid or non-numeric argument\n");
internal.c:			dfValue=-dfValue;
internal.c:	for(;pc;pc=pc->pcNext)
internal.c:			TermError("compute-abs",pcFormula,pbBindings);
internal.c:		switch(pcValue->pfForm->nType)
internal.c:				dfValue+=pcValue->pfForm->uValue.nInteger*pcValue->pfForm->uValue.nInteger;
internal.c:				dfValue+=pcValue->pfForm->uValue.dfFloat*pcValue->pfForm->uValue.dfFloat;
internal.c:				ErrorMessage("ComputeAbs:  Invalid or non-numeric argument\n");
internal.c:	pc=pcFormula->pfForm->pcArgs;
internal.c:			TermError("compute-exp",pcFormula,pbBindings);
internal.c:		switch(pcValue->pfForm->nType)
internal.c:				dfValue=exp(pcValue->pfForm->uValue.nInteger);
internal.c:				dfValue=exp(pcValue->pfForm->uValue.dfFloat);
internal.c:				ErrorMessage("ComputeExp:  Invalid or non-numeric argument\n");
internal.c:	pc=pcFormula->pfForm->pcArgs;
internal.c:		TermError("compute-log",pcFormula,pbBindings);
internal.c:	switch(pcValue->pfForm->nType)
internal.c:			dfValue=pcValue->pfForm->uValue.nInteger;
internal.c:			dfValue=pcValue->pfForm->uValue.dfFloat;
internal.c:			ErrorMessage("ComputeLog:  Invalid or non-numeric argument\n");
internal.c:	if(!pc->pcNext)
internal.c:	pc=pc->pcNext;
internal.c:		TermError("compute-log",pcFormula,pbBindings);
internal.c:	switch(pcValue->pfForm->nType)
internal.c:			dfBase=pcValue->pfForm->uValue.nInteger;
internal.c:			dfBase=pcValue->pfForm->uValue.dfFloat;
internal.c:			ErrorMessage("ComputeLog:  Invalid or non-numeric argument\n");
internal.c:	pc=MakeIntegerForm((*prCurrentRNG->pfRNG)());
internal.c:	pc=pcFormula->pfForm->pcArgs;
internal.c:		ErrorMessage("ComputeRandom:  Invalid or non-numeric argument\n");
internal.c:	pc=pc->pcNext;
internal.c:		ErrorMessage("ComputeRandom:  Invalid or non-numeric argument\n");
internal.c:	pc=MakeFloatForm((dfMax-dfMin)*(unsigned)(*prCurrentRNG->pfRNG)()/prCurrentRNG->dfMaxValue+dfMin);
internal.c:	This is implemented as a pseudo-predicate, since it returns no value.
internal.c:	pc=pcFormula->pfForm->pcArgs;
internal.c:		ErrorMessage("EvalSeed:  Invalid or non-numeric argument\n");
internal.c:	(*prCurrentRNG->pfSeed)(nSeed);
internal.c:	pc=pcFormula->pfForm->pcArgs;
internal.c:			TermError("compute-round",pcFormula,pbBindings);
internal.c:		switch(pcValue->pfForm->nType)
internal.c:				nValue=pcValue->pfForm->uValue.nInteger;
internal.c:				if(pcValue->pfForm->uValue.dfFloat<0.0)
internal.c:					nValue=(int)(pcValue->pfForm->uValue.dfFloat-0.5);
internal.c:					nValue=(int)(pcValue->pfForm->uValue.dfFloat+0.5);
internal.c:				ErrorMessage("ComputeRound:  Invalid or non-numeric argument\n");
internal.c:	pc=pcFormula->pfForm->pcArgs;
internal.c:			TermError("compute-int",pcFormula,pbBindings);
internal.c:		switch(pcValue->pfForm->nType)
internal.c:				nValue=pcValue->pfForm->uValue.nInteger;
internal.c:				nValue=(int)(pcValue->pfForm->uValue.dfFloat);
internal.c:				ErrorMessage("ComputeInt:  Invalid or non-numeric argument\n");
internal.c:	pc=pcFormula->pfForm->pcArgs;
internal.c:			TermError("compute-floor",pcFormula,pbBindings);
internal.c:		switch(pcValue->pfForm->nType)
internal.c:				nValue=pcValue->pfForm->uValue.nInteger;
internal.c:				if(pcValue->pfForm->uValue.dfFloat<0.0)
internal.c:					if(pcValue->pfForm->uValue.dfFloat<(int)pcValue->pfForm->uValue.dfFloat)
internal.c:						nValue=(int)(pcValue->pfForm->uValue.dfFloat-1.0);
internal.c:						nValue=(int)(pcValue->pfForm->uValue.dfFloat);
internal.c:					nValue=(int)(pcValue->pfForm->uValue.dfFloat);
internal.c:				ErrorMessage("ComputeFloor:  Invalid or non-numeric argument\n");
internal.c:	pc=pcFormula->pfForm->pcArgs;
internal.c:			TermError("compute-ceil",pcFormula,pbBindings);
internal.c:		switch(pcValue->pfForm->nType)
internal.c:				nValue=pcValue->pfForm->uValue.nInteger;
internal.c:				if(pcValue->pfForm->uValue.dfFloat>0.0)
internal.c:					if(pcValue->pfForm->uValue.dfFloat>(int)pcValue->pfForm->uValue.dfFloat)
internal.c:						nValue=(int)(pcValue->pfForm->uValue.dfFloat+1.0);
internal.c:						nValue=(int)(pcValue->pfForm->uValue.dfFloat);
internal.c:					nValue=(int)(pcValue->pfForm->uValue.dfFloat);
internal.c:				ErrorMessage("ComputeCeil:  Invalid or non-numeric argument\n");
internal.c:/* Boolean Relations ----------------------------------------------------------- */
internal.c:	if(!FormulaToDouble(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings,&df1))
internal.c:		ErrorMessage("EvalLt:  Invalid or non-numeric argument\n");
internal.c:	if(!FormulaToDouble(pcFormula->pfForm->pcArgs->pcNext,plpLinearPlan,pbBindings,&df2))
internal.c:		ErrorMessage("EvalLt:  Invalid or non-numeric argument\n");
internal.c:		if(!FormulaToDouble(pcGenLit->pfForm->pcArgs->pcNext,
internal.c:		pbBindings->pgcContext=(GCONTEXTP)pgc;
internal.c:			pgc->nValue=(int)floor(dfVal);
internal.c:			pgc->nValue=(int)floor(dfVal)-1;
internal.c:	lv.nInteger=pgc->nValue--;			/* generate next integer */
internal.c:	if(!FormulaToDouble(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings,&df1))
internal.c:		ErrorMessage("EvalLe:  Invalid or non-numeric argument\n");
internal.c:	if(!FormulaToDouble(pcFormula->pfForm->pcArgs->pcNext,plpLinearPlan,pbBindings,&df2))
internal.c:		ErrorMessage("EvalLe:  Invalid or non-numeric argument\n");
internal.c:		if(!FormulaToDouble(pcGenLit->pfForm->pcArgs->pcNext,
internal.c:		pbBindings->pgcContext=(GCONTEXTP)pgc;
internal.c:		pgc->nValue=(int)floor(dfVal);
internal.c:	lv.nInteger=pgc->nValue--;			/* generate next integer */
internal.c:	if(!FormulaToDouble(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings,&df1))
internal.c:		ErrorMessage("EvalGt:  Invalid or non-numeric argument\n");
internal.c:	if(!FormulaToDouble(pcFormula->pfForm->pcArgs->pcNext,plpLinearPlan,pbBindings,&df2))
internal.c:		ErrorMessage("EvalGt:  Invalid or non-numeric argument\n");
internal.c:		if(!FormulaToDouble(pcGenLit->pfForm->pcArgs->pcNext,
internal.c:		pbBindings->pgcContext=(GCONTEXTP)pgc;
internal.c:			pgc->nValue=(int)ceil(dfVal);
internal.c:			pgc->nValue=(int)ceil(dfVal)+1;
internal.c:	lv.nInteger=pgc->nValue++;			/* generate next integer */
internal.c:	if(!FormulaToDouble(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings,&df1))
internal.c:		ErrorMessage("EvalGe:  Invalid or non-numeric argument\n");
internal.c:	if(!FormulaToDouble(pcFormula->pfForm->pcArgs->pcNext,plpLinearPlan,pbBindings,&df2))
internal.c:		ErrorMessage("EvalGe:  Invalid or non-numeric argument\n");
internal.c:		if(!FormulaToDouble(pcGenLit->pfForm->pcArgs->pcNext,
internal.c:		pbBindings->pgcContext=(GCONTEXTP)pgc;
internal.c:		pgc->nValue=(int)ceil(dfVal);
internal.c:	lv.nInteger=pgc->nValue++;	/* generate next integer */
internal.c:/* Integer Generators ---------------------------------------------------------- */
internal.c:	(pos-int ?x)
internal.c:	(<-pos-int ?x 20)
internal.c:		if(!FormulaToDouble(pcGenLit->pfForm->pcArgs->pcNext,
internal.c:	lv.nInteger=--(*(int *)ppvContext);	/* generate next integer */
internal.c:/* additional generators and evaluators ------------------------------------- */
internal.c:	(is-between ?x a b)
internal.c:		pc=pcGenLit->pfForm->pcArgs;
internal.c:			ErrorMessage("is-between:  No arguments\n");
internal.c:		pc=pc->pcNext;					/* skip over binding variable */
internal.c:			ErrorMessage("is-between:  No limits\n");
internal.c:		pc=pc->pcNext;
internal.c:			ErrorMessage("is-between:  No maximum limit\n");
internal.c:		pbBindings->pgcContext=(GCONTEXTP)pgc;
internal.c:		pgc->nNext=nMin;
internal.c:		pgc->nLast=nMax;
internal.c:	if(pgc->nNext>pgc->nLast)
internal.c:	lv.nInteger=pgc->nNext++;	/* generate next integer */
internal.c:	(is-between ?x a b)
internal.c:	pc=pcFormula->pfForm->pcArgs;
internal.c:		ErrorMessage("is-between:  No arguments\n");
internal.c:	pc=pc->pcNext;
internal.c:		ErrorMessage("is-between:  No limits\n");
internal.c:	pc=pc->pcNext;
internal.c:		ErrorMessage("is-between:  No maximum limit\n");
internal.c:	(in-the-set (?x ?y) aa ab ba bb ...)
internal.c:		*(CELLP *)ppvContext=pcGenLit->pfForm->pcArgs;
internal.c:			ErrorMessage("in-the-set:  No values\n");
internal.c:	else if(*ppvContext==(void *)-1)
internal.c:	for(pc1=pcVars;pc1;pc1=pc1->pcNext)
internal.c:		pc2=pc2->pcNext;
internal.c:		*ppvContext=(void *)-1;
internal.c:	pc=pcFormula->pfForm->pcVars;
internal.c:		TermError("eval-in-the-set",pcFormula,pbBindings);
internal.c:		for(pc1=pcFormula->pfForm->pcArgs;pc1;)
internal.c:			for(pc2=pcVars;pc2;pc2=pc2->pcNext)
internal.c:				pcNext=pcNext->pcNext=CopyCell(ComputeTerm(pc1,plpLinearPlan,pbBindings));
internal.c:				pc1=pc1->pcNext;
internal.c:/* GenerateNearestFirst --------------------------------------------------------
internal.c:	Do a breadth first search on a graph described by an edge-predicate.
internal.c:	(nearest-first <edge-predicate> start-vertex ?next-vertex ?next-distance)
internal.c:	If a vertex is new, then breadth-first-search adds the vertex to its queue or open list.
internal.c:	pnVertexIndices - This is the vertex indirection array.  InsertVertex maintains
internal.c:	ppcVertices - This is the vertex literal pointer array.  InsertVertex uses the literal
internal.c:	pnDistances - This is the vertex distance array.  GenerateNearestFirst returns this
internal.c:	pnQueue - This is the open list.  GenerateNearestFirst maintains a list of vertex
internal.c:		pcEdge=pcGenLit->pfForm->pcArgs;
internal.c:			ErrorMessage("nearest-first:  No edge predicate\n");
internal.c:		if(pcEdge->pfForm->nType!=ATOM_SYMBOLINFOP)
internal.c:			ErrorMessage("nearest-first:  Edge argument is not a symbol (described predicate)\n");
internal.c:		psi=pcEdge->pfForm->uValue.psiSymbolInfo;
internal.c:		if(psi->nSymbolType!=SYMBOL_PREDICATE)
internal.c:			ErrorMessage("nearest-first:  Edge argument is not a predicate\n");
internal.c:		if(psi-asiWorldSymbols>=nNumberOfWorldSymbols)
internal.c:			ErrorMessage("nearest-first:  Edge predicate is not described\n");
internal.c:		if(psi->nArity!=2)
internal.c:			ErrorMessage("nearest-first:  Edge predicate must have arity 2\n");
internal.c:		pcStart=pcEdge->pcNext;
internal.c:			ErrorMessage("nearest-first:  No start vertex\n");
internal.c:		pcVarVertex=pcStart->pcNext;
internal.c:			ErrorMessage("nearest-first:  No vertex variable\n");
internal.c:		pcVarDistance=pcVarVertex->pcNext;
internal.c:			ErrorMessage("nearest-first:  No distance variable\n");
internal.c:		pbBindings->pgcContext=(GCONTEXTP)pgc;
internal.c:		pgc->pfMark=(void (*)(GCONTEXTP))MarkNearestFirst;
internal.c:		pgc->pbtEdge=plpLinearPlan->apbtWorld[psi-asiWorldSymbols];
internal.c:		nCount=BTreeCount(pgc->pbtEdge,0)+1;	// at most nEdges+1 vertices can be reached
internal.c:		pgc->pnVertexIndices=(int *)MemAlloc(sizeof(int)*nCount);
internal.c:		pgc->ppcVertices=(CELLP *)MemAlloc(sizeof(CELLP)*nCount);
internal.c:		pgc->pnDistances=(int *)MemAlloc(sizeof(int)*nCount);
internal.c:		pgc->pnQueue=(int *)MemAlloc(sizeof(int)*nCount);
internal.c:		pgc->pnNext=pgc->pnQueue-1;
internal.c:		pgc->pnFree=pgc->pnQueue;
internal.c:		pgc->nVertices=0;		// number of vertices
internal.c:		pgc->pcVarVertex=pcVarVertex;
internal.c:		pgc->pcVarDistance=pcVarDistance;
internal.c:			pgc->pnVertexIndices,
internal.c:			pgc->ppcVertices,
internal.c:			&pgc->nVertices,
internal.c:		pgc->pnDistances[nIndex]=0;	// starting distance
internal.c:		*pgc->pnFree++=nIndex;	// put vertex on the open list
internal.c:	while(pgc->pnNext<pgc->pnFree)	// search all open vertices
internal.c:		nOpenIndex=*++pgc->pnNext;	// fetch next vertex from open list
internal.c:		pcArgs=CopyCell(pgc->ppcVertices[nOpenIndex]);
internal.c:		pcArgs->pcNext=pgc->pcVarVertex;
internal.c:		BTreeGeneratorWithBoundVars(pgc->pbtEdge,&pvStack,pcArgs);			// Initialize btree search
internal.c:			if(InsertVertex(pcTuple->pcNext,	// add next vertex to vertex array
internal.c:				pgc->pnVertexIndices,
internal.c:				pgc->ppcVertices,
internal.c:				&pgc->nVertices,
internal.c:				pgc->pnDistances[nIndex]=pgc->pnDistances[nOpenIndex]+1;	// calculate distance from start
internal.c:				*pgc->pnFree++=nIndex;	// put vertex on the open list
internal.c:			SetVarX(pgc->pcVarVertex,pgc->ppcVertices[nOpenIndex],pbBindings);
internal.c:			pcDistance=MakeIntegerForm(pgc->pnDistances[nOpenIndex]);
internal.c:			SetVarX(pgc->pcVarDistance,pcDistance,pbBindings);
internal.c:	ZoneMark(pgc->ppcVertices);
internal.c:	ZoneMark(pgc->pnDistances);
internal.c:	ZoneMark(pgc->pnQueue);
internal.c:/* GenerateNearestFirstEx ------------------------------------------------------
internal.c:	Do a breadth first search on a graph described by an edge-predicate.
internal.c:	(nearest-first-ex (?loc-from ?loc-to) (<edge-predicate> ?arg1 ?arg2 ...) 
internal.c:		start-vertex ?next-vertex ?next-distance)
internal.c:	If a vertex is new, then breadth-first-search adds the vertex to its queue or open list.
internal.c:	pnVertexIndices - This is the vertex indirection array.  InsertVertex maintains
internal.c:	ppcVertices - This is the vertex literal pointer array.  InsertVertex uses the literal
internal.c:	pnDistances - This is the vertex distance array.  GenerateNearestFirst returns this
internal.c:	pnQueue - This is the open list.  GenerateNearestFirst maintains a list of vertex
internal.c:	CELLP pcEdgeCount;					/* returned edge-count */
internal.c:		pcLocal=pcGenLit->pfForm->pcArgs;
internal.c:		pcEdge=pcLocal->pcNext;
internal.c:			ErrorMessage("nearest-first-ex:  No edge predicate\n");
internal.c:		if(pcEdge->pfForm->nType!=ATOM_SYMBOLINFOP)
internal.c:			ErrorMessage("nearest-first-ex:  Edge argument is not a symbol (described predicate)\n");
internal.c:		psi=pcEdge->pfForm->uValue.psiSymbolInfo;
internal.c:		if(psi->nSymbolType!=SYMBOL_PREDICATE)
internal.c:			ErrorMessage("nearest-first-ex:  Edge argument is not a predicate\n");
internal.c:		if(psi-asiWorldSymbols>=nNumberOfWorldSymbols)
internal.c:			ErrorMessage("nearest-first-ex:  Edge predicate is not described\n");
internal.c:		if(psi->nArity<2)
internal.c:			ErrorMessage("nearest-first-ex:  Edge predicate arity must be atleast 2\n");
internal.c:		pcStart=pcEdge->pcNext;
internal.c:			ErrorMessage("nearest-first-ex:  No start vertex\n");
internal.c:		pcVarVertex=pcStart->pcNext;
internal.c:			ErrorMessage("nearest-first-ex:  No vertex variable\n");
internal.c:		pcVarDist=pcVarVertex->pcNext;
internal.c:			ErrorMessage("nearest-first-ex:  No distance variable\n");
internal.c:		pbBindings->pgcContext=(GCONTEXTP)pgc;
internal.c:		pgc->pfMark=(void (*)(GCONTEXTP))MarkNearestFirstEx;
internal.c:		pgc->pcLocal=pcLocal;
internal.c:		pgc->pcEdge=pcEdge;
internal.c:		pgc->pcVarVertex=pcVarVertex;
internal.c:		pgc->pcVarDist=pcVarDist;
internal.c:		pbt=plpLinearPlan->apbtWorld[psi-asiWorldSymbols];
internal.c:		pgc->pnVertexIndices=(int *)MemAlloc(sizeof(int)*nCount);
internal.c:		pgc->ppcVertices=(CELLP *)MemAlloc(sizeof(CELLP)*nCount);
internal.c:		pgc->pnEdgeCounts=(int *)MemAlloc(sizeof(int)*nCount);
internal.c:		pgc->pnQueue=(int *)MemAlloc(sizeof(int)*nCount);
internal.c:		pgc->pnNext=pgc->pnQueue-1;
internal.c:		pgc->pnFree=pgc->pnQueue;
internal.c:		pgc->nVertices=0;				// number of vertices
internal.c:			pgc->pnVertexIndices,
internal.c:			pgc->ppcVertices,
internal.c:			&pgc->nVertices,
internal.c:		pgc->pnEdgeCounts[nIndex]=0;	// starting edge-count
internal.c:		*pgc->pnFree++=nIndex;	// put vertex on the open list
internal.c:	while(pgc->pnNext<pgc->pnFree)	// search all open vertices
internal.c:		nOpenIndex=*++pgc->pnNext;	// fetch next vertex from open list
internal.c://		pcArgs=CopyCell(pgc->ppcVertices[nOpenIndex]);
internal.c://		pcArgs->pcNext=pgc->pcVarVertex;
internal.c:		pcLocal=CopyCell2(&c1,pgc->pcLocal);
internal.c:		pcLocal->pcNext=pcLocal->pfForm->pcArgs;
internal.c:		pcArgs=CopyCell2(&c2,pgc->ppcVertices[nOpenIndex]);
internal.c:		pcArgs->pcNext=pcLocal->pfForm->pcArgs;
internal.c:		while(GenerateDescPredicate(pgc->pcEdge,(void *) &pbBindings->pgcContext,NULL,plpLinearPlan,pbBindings))
internal.c:			pc=ComputeTerm(pcLocal->pfForm->pcArgs,plpLinearPlan,pbBindings);
internal.c:				pgc->pnVertexIndices,
internal.c:				pgc->ppcVertices,
internal.c:				&pgc->nVertices,
internal.c:				pgc->pnEdgeCounts[nIndex]=pgc->pnEdgeCounts[nOpenIndex]+1;	// calculate distance from start
internal.c:				*pgc->pnFree++=nIndex;	// put vertex on the open list
internal.c:			SetVarX(pgc->pcVarVertex,pgc->ppcVertices[nOpenIndex],pbBindings);
internal.c:			pcEdgeCount=MakeIntegerForm(pgc->pnEdgeCounts[nOpenIndex]);
internal.c:			SetVarX(pgc->pcVarDist,pcEdgeCount,pbBindings);
internal.c:	ZoneMark(pgc->ppcVertices);
internal.c:	for(i=0;i<pgc->nVertices;i++)
internal.c:		MarkFormula(pgc->ppcVertices[i]);
internal.c:	ZoneMark(pgc->pnEdgeCounts);
internal.c:	ZoneMark(pgc->pnQueue);
internal.c:		if(StringEqQ(pcVertex->pfForm->psName,ppcVertices[pnVertexIndices[nMiddle]]->pfForm->psName))
internal.c:		nFlag=strcmp(pcVertex->pfForm->psName,ppcVertices[pnVertexIndices[nMiddle]]->pfForm->psName);
internal.c:	memmove(pnVertexIndices+nLeft+1,pnVertexIndices+nLeft,(*pnCount-nLeft)*sizeof(int));
internal.c:	Do a best first search on a graph described by an edge-predicate and cost function.
internal.c:	(closest-first <edge-predicate> <cost-function> start-vertex ?var-vertex ?var-cost [?var-edge-count])
internal.c:	This routine uses a best-first graph search to generate the
internal.c:	If a vertex is new, then best-first-search adds the vertex to its heap or open list.
internal.c:	pnVertexIndices - This is the vertex indirection array.  InsertVertex maintains
internal.c:	ppcVertices - This is the vertex literal pointer array.  InsertVertex uses the literal
internal.c:	pnDistances - This is the edge count array.  GenerateClosestFirst optionally returns this
internal.c:	pdfCosts - This is the total cost array.  GenerateClosestFirst returns this
internal.c:	pnHeap - This is the open list.  GenerateClosestFirst maintains a list of vertex
internal.c:	int nEdgeCount;						/* edge-count value */
internal.c:	CELLP pcEdgeCount;					/* edge-count */
internal.c:		pcEdge=pcGenLit->pfForm->pcArgs;
internal.c:			ErrorMessage("closest-first:  No edge predicate\n");
internal.c:		if(pcEdge->pfForm->nType!=ATOM_SYMBOLINFOP)
internal.c:			ErrorMessage("closest-first:  Edge argument is not a symbol (described predicate)\n");
internal.c:		psiEdge=pcEdge->pfForm->uValue.psiSymbolInfo;
internal.c:		if(psiEdge->nSymbolType!=SYMBOL_PREDICATE)
internal.c:			ErrorMessage("closest-first:  Edge argument is not a predicate\n");
internal.c:		if(psiEdge-asiWorldSymbols>=nNumberOfWorldSymbols)
internal.c:			ErrorMessage("closest-first:  Edge predicate is not described\n");
internal.c:		if(psiEdge->nArity!=2)
internal.c:			ErrorMessage("closest-first:  Edge predicate must have arity 2\n");
internal.c:		pcCost=pcEdge->pcNext;
internal.c:			ErrorMessage("closest-first:  No cost function\n");
internal.c:		if(pcCost->pfForm->nType!=ATOM_SYMBOLINFOP)
internal.c:			ErrorMessage("closest-first:  Cost argument is not a symbol (described function)\n");
internal.c:		psiCost=pcCost->pfForm->uValue.psiSymbolInfo;
internal.c:		if(psiCost->nSymbolType!=SYMBOL_FUNCTION)
internal.c:			ErrorMessage("closest-first:  Cost argument is not a function\n");
internal.c:		if(psiCost-asiWorldSymbols>=nNumberOfWorldSymbols)
internal.c:			ErrorMessage("closest-first:  Cost function is not described\n");
internal.c:		if(psiCost->nArity!=2)
internal.c:			ErrorMessage("closest-first:  Cost function must have arity 2\n");
internal.c:		pcStart=pcCost->pcNext;
internal.c:			ErrorMessage("closest-first:  No start vertex\n");
internal.c:		pcVarVertex=pcStart->pcNext;
internal.c:			ErrorMessage("closest-first:  No vertex variable\n");
internal.c:		pcVarCost=pcVarVertex->pcNext;
internal.c:			ErrorMessage("closest-first:  No cost variable\n");
internal.c:		// fetch edge-count variable
internal.c:		pcVarDist=pcVarCost->pcNext;
internal.c:		pbBindings->pgcContext=(GCONTEXTP)pgc;
internal.c:		pgc->pfMark=(void (*)(GCONTEXTP))MarkClosestFirst;
internal.c:		pgc->pbtEdge=plpLinearPlan->apbtWorld[psiEdge-asiWorldSymbols];
internal.c:		pgc->pbtCost=plpLinearPlan->apbtWorld[psiCost-asiWorldSymbols];
internal.c:		nCount=BTreeCount(pgc->pbtEdge,0)+1;	// at most nEdges+1 vertices can be reached
internal.c:		pgc->pnVertexIndices=(int *)MemAlloc(sizeof(int)*nCount);
internal.c:		pgc->ppcVertices=(CELLP *)MemAlloc(sizeof(CELLP)*nCount);
internal.c:		pgc->pdfCosts=(double *)MemAlloc(sizeof(double)*nCount);
internal.c:		pgc->pnEdgeCounts=(int *)MemAlloc(sizeof(int)*nCount);
internal.c:		pgc->pnHeap=(int *)MemAlloc(sizeof(int)*nHeapLength);
internal.c:		pgc->nHeapLength=nHeapLength;	// heap length
internal.c:		pgc->nHeapCount=0;				// heap empty
internal.c:		pgc->nVertices=0;				// number of vertices
internal.c:		pgc->pcVarVertex=pcVarVertex;
internal.c:		pgc->pcVarCost=pcVarCost;
internal.c:		pgc->pcVarDist=pcVarDist;
internal.c:			pgc->pnVertexIndices,
internal.c:			pgc->ppcVertices,
internal.c:			&pgc->nVertices,
internal.c:		pgc->pdfCosts[nIndex]=0.0;		// starting cost
internal.c:		pgc->pnEdgeCounts[nIndex]=0;	// starting edge-count
internal.c:	while((nOpenIndex=VHeapExtractMin(pgc))!=-1)	// search all open vertices
internal.c:		pcArgs=CopyCell(pgc->ppcVertices[nOpenIndex]);
internal.c:		pcArgs->pcNext=pgc->pcVarVertex;
internal.c:		BTreeGeneratorWithBoundVars(pgc->pbtEdge,&pvStack,pcArgs);	// Initialize btree search
internal.c:			pbt=BTreeSearch(pcTuple,pgc->pbtCost);
internal.c:				ErrorMessage("closest-first:  Cost function does not have cost for every edge.\n");
internal.c:			if(!FormulaToDouble(pbt->pcValue,plpLinearPlan,pbBindings,&dfCost))
internal.c:				ErrorMessage("closest-first:  Cost function has null or non-numeric value.\n");
internal.c:			dfCost+=pgc->pdfCosts[nOpenIndex];
internal.c:			nEdgeCount=pgc->pnEdgeCounts[nOpenIndex]+1;
internal.c:			if(InsertVertex(pcTuple->pcNext,	// add next vertex to vertex array
internal.c:				pgc->pnVertexIndices,pgc->ppcVertices,&pgc->nVertices,&nIndex))
internal.c:				pgc->pdfCosts[nIndex]=dfCost;	// store the total cost
internal.c:				pgc->pnEdgeCounts[nIndex]=nEdgeCount;	// store the total edge-count
internal.c:				if(dfCost<pgc->pdfCosts[nIndex]||	// if this path is cheaper
internal.c:					(dfCost==pgc->pdfCosts[nIndex]&&nEdgeCount<pgc->pnEdgeCounts[nIndex]))
internal.c:					pgc->pdfCosts[nIndex]=dfCost;	// store the new total cost
internal.c:					pgc->pnEdgeCounts[nIndex]=nEdgeCount;	// store the total edge-count
internal.c:					for(nNode=0;nNode<pgc->nHeapCount;nNode++)
internal.c:						if(pgc->pnHeap[nNode]==nIndex)
internal.c:					if(nNode==pgc->nHeapCount)	// if vertex not on open list (this can't happen!)
internal.c:						Message("closest-first:  Node index not found in heap.\n");
internal.c:		// return next vertex, cost (and edge-count)
internal.c:			SetVarX(pgc->pcVarVertex,pgc->ppcVertices[nOpenIndex],pbBindings);
internal.c:			pcCost=MakeFloatForm(pgc->pdfCosts[nOpenIndex]);
internal.c:			SetVarX(pgc->pcVarCost,pcCost,pbBindings);
internal.c:			if(pgc->pcVarDist)
internal.c:				pcEdgeCount=MakeIntegerForm(pgc->pnEdgeCounts[nOpenIndex]);
internal.c:				SetVarX(pgc->pcVarDist,pcEdgeCount,pbBindings);
internal.c:	Mark the data structures associated with a closest-first context block.
internal.c:	ZoneMark(pgc->ppcVertices);
internal.c:	ZoneMark(pgc->pdfCosts);
internal.c:	ZoneMark(pgc->pnEdgeCounts);
internal.c:	ZoneMark(pgc->pnHeap);
internal.c:// Vertex Heap Support Routines ------------------------------------------------
internal.c:	assert(pgc->nHeapCount<pgc->nHeapLength);
internal.c:	pgc->nHeapCount++;
internal.c:	for(i=pgc->nHeapCount;i>1&&VHeapCompareFn(pgc,pgc->pnHeap[Parent(i)-1],nVertex)==1;i=Parent(i))
internal.c:		pgc->pnHeap[i-1]=pgc->pnHeap[Parent(i)-1];
internal.c:	pgc->pnHeap[i-1]=nVertex;
internal.c:	if(pgc->nHeapCount<1)
internal.c:		return -1;
internal.c:	nMin=pgc->pnHeap[0];
internal.c:	--pgc->nHeapCount;
internal.c:	pgc->pnHeap[0]=pgc->pnHeap[pgc->nHeapCount];
internal.c:	if(nLeft<=pgc->nHeapCount&&VHeapCompareFn(pgc,pgc->pnHeap[nLeft-1],pgc->pnHeap[nNode-1])==-1)
internal.c:	if(nRight<=pgc->nHeapCount&&VHeapCompareFn(pgc,pgc->pnHeap[nRight-1],pgc->pnHeap[nSmallest-1])==-1)
internal.c:		n=pgc->pnHeap[nNode-1];			// exchange nodes
internal.c:		pgc->pnHeap[nNode-1]=pgc->pnHeap[nSmallest-1];
internal.c:		pgc->pnHeap[nSmallest-1]=n;
internal.c:		if(VHeapCompareFn(pgc,pgc->pnHeap[nParent-1],pgc->pnHeap[nNode-1])==1)
internal.c:			n=pgc->pnHeap[nNode-1];		// exchange nodes
internal.c:			pgc->pnHeap[nNode-1]=pgc->pnHeap[nParent-1];
internal.c:			pgc->pnHeap[nParent-1]=n;
internal.c:	This routine is used to compare vertices for best-first search.
internal.c:	if(pgc->pdfCosts[nVertex1]<pgc->pdfCosts[nVertex2])
internal.c:		return -1;
internal.c:	if(pgc->pdfCosts[nVertex1]>pgc->pdfCosts[nVertex2])
internal.c:	if(pgc->pnEdgeCounts[nVertex1]<pgc->pnEdgeCounts[nVertex2])
internal.c:		return -1;
internal.c:	if(pgc->pnEdgeCounts[nVertex1]>pgc->pnEdgeCounts[nVertex2])
internal.c://	for(i=0;i<pgc->nHeapCount;i++)
internal.c://		nVertex=pgc->pnHeap[i];
internal.c://		Message("(%d %s %f) ",nVertex,pgc->ppcVertices[nVertex]->pfForm->psName,pgc->pdfCosts[nVertex]);
internal.c://	for(i=1;i<pgc->nHeapCount;i++)
internal.c://		if(pgc->pdfCosts[pgc->pnHeap[Parent(i+1)-1]]>pgc->pdfCosts[pgc->pnHeap[i]])
internal.c://			Message("Heap invalid (%d>%d) (%f>%f)\n",Parent(i+1)-1,i,
internal.c://				pgc->pdfCosts[pgc->pnHeap[Parent(i+1)-1]],pgc->pdfCosts[pgc->pnHeap[i]]);
internal.c:/* GenerateClosestFirstEx ------------------------------------------------------
internal.c:	Do a best first search on a graph described by an edge-predicate and cost function.
internal.c:	(closest-first 
internal.c:		(?var-from ?var-to)
internal.c:		(<edge-predicate> arg1 arg2 ...)
internal.c:		(<cost-function> arg1 arg2 ...) 
internal.c:		<start-vertex> ?var-vertex ?var-cost [?var-edge-count])
internal.c:	This routine uses a best-first graph search to generate the
internal.c:	If a vertex is new, then best-first-search adds the vertex to its heap or open list.
internal.c:	pnVertexIndices - This is the vertex indirection array.  InsertVertex maintains
internal.c:	ppcVertices - This is the vertex literal pointer array.  InsertVertex uses the literal
internal.c:	pnDistances - This is the edge count array.  GenerateClosestFirst optionally returns this
internal.c:	pdfCosts - This is the total cost array.  GenerateClosestFirst returns this
internal.c:	pnHeap - This is the open list.  GenerateClosestFirst maintains a list of vertex
internal.c:	int nEdgeCount;						/* edge-count value */
internal.c:	CELLP pcEdgeCount;					/* edge-count */
internal.c:		pcLocal=pcGenLit->pfForm->pcArgs;
internal.c:		pcEdge=pcLocal->pcNext;
internal.c:			ErrorMessage("closest-first-ex:  No edge predicate\n");
internal.c:		if(pcEdge->pfForm->nType!=ATOM_SYMBOLINFOP)
internal.c:			ErrorMessage("closest-first-ex:  Edge argument is not a symbol (described predicate)\n");
internal.c:		psiEdge=pcEdge->pfForm->uValue.psiSymbolInfo;
internal.c:		if(psiEdge->nSymbolType!=SYMBOL_PREDICATE)
internal.c:			ErrorMessage("closest-first-ex:  Edge argument is not a predicate\n");
internal.c:		if(psiEdge-asiWorldSymbols>=nNumberOfWorldSymbols)
internal.c:			ErrorMessage("closest-first-ex:  Edge predicate is not described\n");
internal.c:		if(psiEdge->nArity<2)
internal.c:			ErrorMessage("closest-first-ex:  Edge predicate arity must be atleast 2\n");
internal.c:		pcCost=pcEdge->pcNext;
internal.c:			ErrorMessage("closest-first-ex:  No cost function\n");
internal.c://		if(pcCost->pfForm->nType!=ATOM_SYMBOLINFOP)
internal.c://			ErrorMessage("closest-first-ex:  Cost argument is not a symbol (described function)\n");
internal.c://		psiCost=pcCost->pfForm->uValue.psiSymbolInfo;
internal.c://		if(psiCost->nSymbolType!=SYMBOL_FUNCTION)
internal.c://			ErrorMessage("closest-first-ex:  Cost argument is not a function\n");
internal.c:		pcStart=pcCost->pcNext;
internal.c:			ErrorMessage("closest-first-ex:  No start vertex\n");
internal.c:		pcVarVertex=pcStart->pcNext;
internal.c:			ErrorMessage("closest-first-ex:  No vertex variable\n");
internal.c:		pcVarCost=pcVarVertex->pcNext;
internal.c:			ErrorMessage("closest-first-ex:  No cost variable\n");
internal.c:		// fetch edge-count variable (optional)
internal.c:		pcVarDist=pcVarCost->pcNext;
internal.c:		pbBindings->pgcContext=(GCONTEXTP)pgc;
internal.c:		pgc->pfMark=(void (*)(GCONTEXTP))MarkClosestFirstEx;
internal.c:		pgc->pcLocal=pcLocal;
internal.c:		pgc->pcEdge=pcEdge;
internal.c:		pgc->pcCost=pcCost;
internal.c:		pgc->pcVarVertex=pcVarVertex;
internal.c:		pgc->pcVarCost=pcVarCost;
internal.c:		pgc->pcVarDist=pcVarDist;
internal.c:		pbt=plpLinearPlan->apbtWorld[psiEdge-asiWorldSymbols];
internal.c:		pgc->pnVertexIndices=(int *)MemAlloc(sizeof(int)*nCount);
internal.c:		pgc->ppcVertices=(CELLP *)MemAlloc(sizeof(CELLP)*nCount);
internal.c:		pgc->pdfCosts=(double *)MemAlloc(sizeof(double)*nCount);
internal.c:		pgc->pnEdgeCounts=(int *)MemAlloc(sizeof(int)*nCount);
internal.c:		pgc->pnHeap=(int *)MemAlloc(sizeof(int)*nCount);
internal.c:		pgc->nHeapLength=nCount;		// heap empty
internal.c:		pgc->nHeapCount=0;				// heap empty
internal.c:		pgc->nVertices=0;				// number of vertices
internal.c:			pgc->pnVertexIndices,
internal.c:			pgc->ppcVertices,
internal.c:			&pgc->nVertices,
internal.c:		pgc->pdfCosts[nIndex]=0.0;		// starting cost
internal.c:		pgc->pnEdgeCounts[nIndex]=0;	// starting edge-count
internal.c:	while((nOpenIndex=VHeapExtractMinEx(pgc))!=-1)	// search all open vertices
internal.c:		pcLocal=CopyCell2(&c1,pgc->pcLocal);
internal.c:		pcLocal->pcNext=pcLocal->pfForm->pcArgs;
internal.c:		pcArgs=CopyCell2(&c2,pgc->ppcVertices[nOpenIndex]);
internal.c:		pcArgs->pcNext=pcLocal->pfForm->pcArgs;
internal.c:		while(GenerateDescPredicate(pgc->pcEdge,(void *)&pbBindings->pgcContext,NULL,plpLinearPlan,pbBindings))
internal.c:			pcCost=ComputeTerm(pgc->pcCost,plpLinearPlan,pbBindings);
internal.c:				ErrorMessage("closest-first:  Cost function has null or non-numeric value.\n");
internal.c:			dfCost+=pgc->pdfCosts[nOpenIndex];
internal.c:			nEdgeCount=pgc->pnEdgeCounts[nOpenIndex]+1;
internal.c:			pc=ComputeTerm(pcLocal->pfForm->pcArgs,plpLinearPlan,pbBindings);
internal.c:				pgc->pnVertexIndices,pgc->ppcVertices,&pgc->nVertices,&nIndex))
internal.c:				pgc->pdfCosts[nIndex]=dfCost;	// store the total cost
internal.c:				pgc->pnEdgeCounts[nIndex]=nEdgeCount;	// store the total edge-count
internal.c:				if(dfCost<pgc->pdfCosts[nIndex]||	// if this path is cheaper
internal.c:					(dfCost==pgc->pdfCosts[nIndex]&&nEdgeCount<pgc->pnEdgeCounts[nIndex]))
internal.c:					pgc->pdfCosts[nIndex]=dfCost;	// store the new total cost
internal.c:					pgc->pnEdgeCounts[nIndex]=nEdgeCount;	// store the total edge-count
internal.c:					for(nNode=0;nNode<pgc->nHeapCount;nNode++)
internal.c:						if(pgc->pnHeap[nNode]==nIndex)
internal.c:					if(nNode==pgc->nHeapCount)	// if vertex not on open list (this can't happen!)
internal.c:						Message("closest-first:  Node index not found in heap.\n");
internal.c:		// return next vertex, cost (and edge-count)
internal.c:			SetVarX(pgc->pcVarVertex,pgc->ppcVertices[nOpenIndex],pbBindings);
internal.c:			pcCost=MakeFloatForm(pgc->pdfCosts[nOpenIndex]);
internal.c:			SetVarX(pgc->pcVarCost,pcCost,pbBindings);
internal.c:			if(pgc->pcVarDist)
internal.c:				pcEdgeCount=MakeIntegerForm(pgc->pnEdgeCounts[nOpenIndex]);
internal.c:				SetVarX(pgc->pcVarDist,pcEdgeCount,pbBindings);
internal.c:	Mark the data structures associated with a closest-first-ex context block.
internal.c:	ZoneMark(pgc->ppcVertices);
internal.c:	for(i=0;i<pgc->nVertices;i++)
internal.c:		MarkFormula(pgc->ppcVertices[i]);
internal.c:	ZoneMark(pgc->pdfCosts);
internal.c:	ZoneMark(pgc->pnEdgeCounts);
internal.c:	ZoneMark(pgc->pnHeap);
internal.c:// Vertex Heap Support Routines ------------------------------------------------
internal.c:	assert(pgc->nHeapCount<pgc->nHeapLength);
internal.c:	pgc->nHeapCount++;
internal.c:	for(i=pgc->nHeapCount;i>1&&VHeapCompareFnEx(pgc,pgc->pnHeap[Parent(i)-1],nVertex)==1;i=Parent(i))
internal.c:		pgc->pnHeap[i-1]=pgc->pnHeap[Parent(i)-1];
internal.c:	pgc->pnHeap[i-1]=nVertex;
internal.c:	if(pgc->nHeapCount<1)
internal.c:		return -1;
internal.c:	nMin=pgc->pnHeap[0];
internal.c:	--pgc->nHeapCount;
internal.c:	pgc->pnHeap[0]=pgc->pnHeap[pgc->nHeapCount];
internal.c:	if(nLeft<=pgc->nHeapCount&&VHeapCompareFnEx(pgc,pgc->pnHeap[nLeft-1],pgc->pnHeap[nNode-1])==-1)
internal.c:	if(nRight<=pgc->nHeapCount&&VHeapCompareFnEx(pgc,pgc->pnHeap[nRight-1],pgc->pnHeap[nSmallest-1])==-1)
internal.c:		n=pgc->pnHeap[nNode-1];			// exchange nodes
internal.c:		pgc->pnHeap[nNode-1]=pgc->pnHeap[nSmallest-1];
internal.c:		pgc->pnHeap[nSmallest-1]=n;
internal.c:		if(VHeapCompareFnEx(pgc,pgc->pnHeap[nParent-1],pgc->pnHeap[nNode-1])==1)
internal.c:			n=pgc->pnHeap[nNode-1];		// exchange nodes
internal.c:			pgc->pnHeap[nNode-1]=pgc->pnHeap[nParent-1];
internal.c:			pgc->pnHeap[nParent-1]=n;
internal.c:	This routine is used to compare vertices for best-first search.
internal.c:	if(pgc->pdfCosts[nVertex1]<pgc->pdfCosts[nVertex2])
internal.c:		return -1;
internal.c:	if(pgc->pdfCosts[nVertex1]>pgc->pdfCosts[nVertex2])
internal.c:	if(pgc->pnEdgeCounts[nVertex1]<pgc->pnEdgeCounts[nVertex2])
internal.c:		return -1;
internal.c:	if(pgc->pnEdgeCounts[nVertex1]>pgc->pnEdgeCounts[nVertex2])
internal.c://	for(i=0;i<pgc->nHeapCount;i++)
internal.c://		nVertex=pgc->pnHeap[i];
internal.c://		Message("(%d %s %f) ",nVertex,pgc->ppcVertices[nVertex]->pfForm->psName,pgc->pdfCosts[nVertex]);
internal.c://	for(i=1;i<pgc->nHeapCount;i++)
internal.c://		if(pgc->pdfCosts[pgc->pnHeap[Parent(i+1)-1]]>pgc->pdfCosts[pgc->pnHeap[i]])
internal.c://			Message("Heap invalid (%d>%d) (%f>%f)\n",Parent(i+1)-1,i,
internal.c://				pgc->pdfCosts[pgc->pnHeap[Parent(i+1)-1]],pgc->pdfCosts[pgc->pnHeap[i]]);
internal.c:/* GenerateLowestFirst ---------------------------------------------------------
internal.c:	(lowest-first <function> arg1 arg2 ...)
internal.c:		pcFunction=pcGenLit->pfForm->pcArgs;
internal.c:			ErrorMessage("lowest-first:  No function argument\n");
internal.c:		if(pcFunction->pfForm->nType!=ATOM_SYMBOLINFOP)
internal.c:			ErrorMessage("lowest-first:  Function argument is not a symbol (described function)\n");
internal.c:		psi=pcFunction->pfForm->uValue.psiSymbolInfo;
internal.c:		if(psi->nSymbolType!=SYMBOL_FUNCTION)
internal.c:			ErrorMessage("lowest-first:  Function argument is not a function\n");
internal.c:		if(psi-asiWorldSymbols>=nNumberOfWorldSymbols)
internal.c:			ErrorMessage("lowest-first:  Function is not described\n");
internal.c:		pcVarList=pcFunction->pcNext;
internal.c:			ErrorMessage("lowest-first:  No variables\n");
internal.c:		pbtFunction=plpLinearPlan->apbtWorld[psi-asiWorldSymbols];
internal.c:		pgc=(LFCONTEXTP)MemAlloc(sizeof(LFCONTEXT)+(nCount-1)*sizeof(BTREEP));
internal.c:		pbBindings->pgcContext=(GCONTEXTP)pgc;
internal.c:		pgc->pfMark=(void (*)(GCONTEXTP))MarkLowestFirst;
internal.c:		pgc->pcVarList=pcVarList;
internal.c:		pgc->nCount=nCount;
internal.c:		pgc->nNext=0;
internal.c:		BTreeEnumerate(pbtFunction,pgc->apbtIndirect);
internal.c:		qsort(pgc->apbtIndirect,nCount,sizeof(BTREEP),(int (*)(const void *, const void *))LFCompare);
internal.c:	if(pgc->nNext>=pgc->nCount)
internal.c:	for(pcVar=pgc->pcVarList,pcVal=pgc->apbtIndirect[pgc->nNext++]->pcKey;pcVar;pcVar=pcVar->pcNext,pcVal=pcVal->pcNext)
internal.c:	Mark the data structures associated with a lowest-first context block.
internal.c:	ZoneMark(pgc->apbtIndirect);
internal.c:	df1=TermToDouble((*ppbt1)->pcValue);
internal.c:	df2=TermToDouble((*ppbt2)->pcValue);
internal.c:		return -1;
internal.c:	switch(pcValue->pfForm->nType)
internal.c:			return (double)pcValue->pfForm->uValue.nInteger;
internal.c:			return pcValue->pfForm->uValue.dfFloat;
internal.c:			ErrorMessage("TermToDouble:  Argument must be numeric %s\n",pcValue->pfForm->psName);
internal.c:/* GenerateAllPairsShortestPath ------------------------------------------------
internal.c:	(all-pairs-shortest-path 
internal.c:		<vertex-predicate>
internal.c:		<cost-function>
internal.c:		?var-vertex1					// enumerated starting vertex
internal.c:		?var-vertex2					// enumerated ending vertex
internal.c:		?var-cost						// minimum cost
internal.c:		?var-next)						// successor vertex on minimum cost path
internal.c:	We use the Floyd-Warshall algorithm.
internal.c:		// fetch vertex predicate -- must be described
internal.c:		pcVertex=pcGenLit->pfForm->pcArgs;
internal.c:			ErrorMessage("all-pairs-shortest-path:  No Vertex predicate\n");
internal.c:		if(pcVertex->pfForm->nType!=ATOM_SYMBOLINFOP)
internal.c:			ErrorMessage("all-pairs-shortest-path:  Vertex argument is not a symbol (described predicate)\n");
internal.c:		psiVertex=pcVertex->pfForm->uValue.psiSymbolInfo;
internal.c:		if(psiVertex->nSymbolType!=SYMBOL_PREDICATE)
internal.c:			ErrorMessage("all-pairs-shortest-path:  Vertex argument is not a predicate\n");
internal.c:		if(psiVertex-asiWorldSymbols>=nNumberOfWorldSymbols)
internal.c:			ErrorMessage("all-pairs-shortest-path:  Vertex predicate is not described\n");
internal.c:		if(psiVertex->nArity!=1)
internal.c:			ErrorMessage("all-pairs-shortest-path:  Vertex predicate must have arity 1\n");
internal.c:		// fetch cost function -- must be described... 
internal.c:		pcCost=pcVertex->pcNext;
internal.c:			ErrorMessage("all-pairs-shortest-path:  No cost function\n");
internal.c:		if(pcCost->pfForm->nType!=ATOM_SYMBOLINFOP)
internal.c:			ErrorMessage("all-pairs-shortest-path:  Cost argument is not a symbol (described function)\n");
internal.c:		psiCost=pcCost->pfForm->uValue.psiSymbolInfo;
internal.c:		if(psiCost->nSymbolType!=SYMBOL_FUNCTION)
internal.c:			ErrorMessage("all-pairs-shortest-path:  Cost argument is not a function\n");
internal.c:		if(psiCost-asiWorldSymbols>=nNumberOfWorldSymbols)
internal.c:			ErrorMessage("all-pairs-shortest-path:  Cost function is not described\n");
internal.c:		if(psiCost->nArity!=2)
internal.c:			ErrorMessage("all-pairs-shortest-path:  Cost function must have arity 2\n");
internal.c:		pcVarVertex1=pcCost->pcNext;
internal.c:			ErrorMessage("all-pairs-shortest-path:  No vertex1 variable\n");
internal.c:		pcVarVertex2=pcVarVertex1->pcNext;
internal.c:			ErrorMessage("all-pairs-shortest-path:  No vertex2 variable\n");
internal.c:		pcVarCost=pcVarVertex2->pcNext;
internal.c:			ErrorMessage("all-pairs-shortest-path:  No cost variable\n");
internal.c:		pcVarNext=pcVarCost->pcNext;
internal.c:			ErrorMessage("all-pairs-shortest-path:  No next variable\n");
internal.c:		pbBindings->pgcContext=(GCONTEXTP)pgc;
internal.c:		pgc->pfMark=(void (*)(GCONTEXTP))MarkAllPairsShortestPath;
internal.c:		pbtVertex=plpLinearPlan->apbtWorld[psiVertex-asiWorldSymbols];
internal.c:		pbtCost=plpLinearPlan->apbtWorld[psiCost-asiWorldSymbols];
internal.c:		pgc->nCount=nCount;
internal.c:		pgc->apbtVertices=(BTREEP *)MemAlloc(nCount*sizeof(BTREEP));
internal.c:		pgc->pdfCosts=(double *)MemAlloc(nCount*nCount*sizeof(double));	
internal.c:		pgc->pnNext=(int *)MemAlloc(nCount*nCount*sizeof(int));	
internal.c:		pgc->pcVarVertex1=pcVarVertex1;
internal.c:		pgc->pcVarVertex2=pcVarVertex2;
internal.c:		pgc->pcVarCost=pcVarCost;
internal.c:		pgc->pcVarNext=pcVarNext;
internal.c:		pgc->i=0;
internal.c:		pgc->j=0;
internal.c:		BTreeEnumerate(pbtVertex,pgc->apbtVertices);
internal.c:					pgc->pdfCosts[INDEX(i,j)]=0.0;	// our cost function may be missing the i==j entries
internal.c:					pcTuple=CopyCell2(&c1,pgc->apbtVertices[i]->pcKey);
internal.c:					pcTuple->pcNext=pgc->apbtVertices[j]->pcKey;
internal.c:						ErrorMessage("all-pairs-shortest-path:  Cost function does not have cost for every edge.\n");
internal.c:					if(!FormulaToDouble(pbt->pcValue,plpLinearPlan,pbBindings,&dfCost))
internal.c:						ErrorMessage("all-pairs-shortest-path:  Cost function has null or non-numeric value.\n");
internal.c:					pgc->pdfCosts[INDEX(i,j)]=dfCost;
internal.c:				pgc->pnNext[INDEX(i,j)]=j;		// best so far
internal.c://			Message("%s ",pgc->apbtVertices[i]->pcKey->pfForm->psName);
internal.c://				Message("%.2f ",pgc->pdfCosts[INDEX(i,j)]);
internal.c:					if(pgc->pdfCosts[INDEX(i,k)]+pgc->pdfCosts[INDEX(k,j)]<pgc->pdfCosts[INDEX(i,j)])
internal.c:						pgc->pdfCosts[INDEX(i,j)]=pgc->pdfCosts[INDEX(i,k)]+pgc->pdfCosts[INDEX(k,j)];
internal.c:						pgc->pnNext[INDEX(i,j)]=pgc->pnNext[INDEX(i,k)];	// new best next
internal.c://				Message("%.2f ",pgc->pdfCosts[INDEX(i,j)]);
internal.c://				Message("%d ",pgc->pnNext[INDEX(i,j)]);
internal.c:	for(i=pgc->i;i<pgc->nCount;i++)
internal.c:		for(j=pgc->j;j<pgc->nCount;j++)
internal.c:			SetVarX(pgc->pcVarVertex1,pgc->apbtVertices[i]->pcKey,pbBindings);
internal.c:			SetVarX(pgc->pcVarVertex2,pgc->apbtVertices[j]->pcKey,pbBindings);
internal.c:			pcCost=MakeFloatForm(pgc->pdfCosts[INDEX(i,j)]);
internal.c:			SetVarX(pgc->pcVarCost,pcCost,pbBindings);
internal.c:			SetVarX(pgc->pcVarNext,pgc->apbtVertices[pgc->pnNext[INDEX(i,j)]]->pcKey,pbBindings);
internal.c:			pgc->j=j+1;
internal.c:		pgc->i=i+1;
internal.c:		pgc->j=0;
internal.c:/* MarkAllPairsShortestPath ----------------------------------------------------
internal.c:	Mark the data structures associated with an all-pairs-shortest-paths context block.
internal.c:	ZoneMark(pgc->apbtVertices);
internal.c:	ZoneMark(pgc->pdfCosts);
internal.c:	ZoneMark(pgc->pnNext);
interval.c:Copyright C, 1996 - 99	F. Bacchus
interval.c:	Compute a new ispec shifted to the left by delta; i.e., ispec - delta.
interval.c:(define (ispec-lshift ispec delta)
interval.c:  (let ((lb (ispec- (second ispec) delta))
interval.c:		(ub (ispec- (third ispec) delta)))
interval.c://	if(!piISpec->bLowerInfinite)
interval.c://		pi->dfLower-=dfDelta;
interval.c://	if(!piISpec->bUpperInfinite)
interval.c://		pi->dfUpper-=dfDelta;
interval.c:	Shift an ispec formula to the left by delta; i.e., ispec - delta.
interval.c:	pi=pc->pfForm->uValue.piISpec;
interval.c:	if(!pi->bLowerInfinite)
interval.c:		pi->dfLower-=dfDelta;
interval.c:	if(!pi->bUpperInfinite)
interval.c:		pi->dfUpper-=dfDelta;
interval.c:	*ps++=(char)(pi->bLowerOpen?'(':'[');
interval.c:	if(pi->bLowerInfinite)
interval.c:		strcpy(ps,"inf-,");
interval.c:		sprintf(ps,"%f,",pi->dfLower);
interval.c:	if(pi->bUpperInfinite)
interval.c:		sprintf(ps,"%f",pi->dfUpper);
interval.c:	*ps++=(char)(pi->bUpperOpen?')':']');
interval.c:	pc->pfForm->psName=IdentAlloc(acBuffer);
interval.c:	if(piISpec->bUpperInfinite)
interval.c:	else if(piISpec->bUpperOpen)
interval.c:		b=piISpec->dfUpper<=0.0;
interval.c:		b=piISpec->dfUpper<0.0;
interval.c:	if(piISpec->bLowerOpen)
interval.c:		if(!piISpec->bLowerInfinite&&piISpec->dfLower>=0.0)
interval.c:		if(!piISpec->bLowerInfinite&&piISpec->dfLower>0.0)
interval.c:	if(piISpec->bUpperOpen)
interval.c:		if(!piISpec->bUpperInfinite&&piISpec->dfUpper<=0.0)
interval.c:		if(!piISpec->bUpperInfinite&&piISpec->dfUpper<0.0)
isaac.c:/* Isaac.c -- cryptographic random number generator by Bob Jenkins 
isaac.c:#define ind(mm,x) (*(unsigned int *)((unsigned char *)(mm)+((x)&((ISAACSIZE-1)<<2))))
isaac.c:		if(picContext->randcnt--)
isaac.c:			return picContext->randrsl[picContext->randcnt];
isaac.c:	mm=picContext->randmem; 
isaac.c:	r=picContext->randrsl;
isaac.c:	a=picContext->randa;
isaac.c:	b=picContext->randb+(++picContext->randc);
isaac.c:	picContext->randb=b;
isaac.c:	picContext->randa=a;
isaac.c:	picContext->randcnt=ISAACSIZE-1;
isaac.c:	return picContext->randrsl[picContext->randcnt];
isaac.c:		picContext->randrsl[i]=uSeed;
isaac.c:	picContext->randa=picContext->randb=picContext->randc=0;
isaac.c:	m=picContext->randmem;
isaac.c:	r=picContext->randrsl;
isaac.c:	picContext->randcnt=0;
isaac.c:b8f6fd4a6a158d1001913fd3af7d1fb80b5e435f90c107576554abda7a68710f <-start here!
isaac.c:9d8d190886ba527ff943f672ef73fbf046d95ca5c54cd95b9d855e894bb5af29 <- then here!
lexpddl.c:/* The "const" storage-class-modifier is valid. */
lexpddl.c: #pragma warn -rch
lexpddl.c: #pragma warn -use
lexpddl.c:/* Returned upon end-of-file. */
lexpddl.c: * we want to instead treat it as an 8-bit unsigned char, hence the
lexpddl.c: * but we do it the disgusting crufty way forced on us by the ()-less
lexpddl.c:#define YY_START ((yy_start - 1) / 2)
lexpddl.c:/* The funky do-while in the following #define is used to turn the definition
lexpddl.c: * int a single C statement (which needs a semi-colon terminator).  This
lexpddl.c: * Prior to using the do-while the compiler would get upset at the
lexpddl.c:		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
lexpddl.c: * flex-generated scanners to compile on their own).
lexpddl.c:	/* Whether we "own" the buffer - i.e., we know we created it,
lexpddl.c:	 * possible backing-up.
lexpddl.c:	yy_current_buffer->yy_is_interactive = is_interactive; \
lexpddl.c:	yy_current_buffer->yy_at_bol = at_bol; \
lexpddl.c:#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
lexpddl.c: * corresponding action - sets up yytext.
lexpddl.c:	yyleng = (int) (yy_cp - yy_bp); \
lexpddl.c:/* lexpddl.c -- pddl language lexical analyzer
lexpddl.c: * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
lexpddl.c:	if ( yy_current_buffer->yy_is_interactive ) \
lexpddl.c:/* No semi-colon after return; correct usage is to write "yyterminate();" -
lexpddl.c:/* Number of entries by which start-condition stack grows. */
lexpddl.c:/* Default declaration of generated scanner - a define so the user can
lexpddl.c:	while ( 1 )		/* loops until end-of-file is reached */
lexpddl.c:yy_c_buf_p = yy_cp -= 1;
lexpddl.c:		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
lexpddl.c:		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
lexpddl.c:			 * back-up) that will match for the new input source.
lexpddl.c:			yy_n_chars = yy_current_buffer->yy_n_chars;
lexpddl.c:			yy_current_buffer->yy_input_file = yyin;
lexpddl.c:			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
lexpddl.c:		 * end-of-buffer state).  Contrast this with the test
lexpddl.c:		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
lexpddl.c:					 * YY_NULL, it'll still work - another
lexpddl.c:				&yy_current_buffer->yy_ch_buf[yy_n_chars];
lexpddl.c:			"fatal flex scanner internal error--no action found" );
lexpddl.c:/* yy_get_next_buffer - try to read in a new buffer
lexpddl.c: *	EOB_ACT_LAST_MATCH -
lexpddl.c: *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
lexpddl.c: *	EOB_ACT_END_OF_FILE - end of file
lexpddl.c:	register char *dest = yy_current_buffer->yy_ch_buf;
lexpddl.c:	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
lexpddl.c:		"fatal flex scanner internal error--end of buffer missed" );
lexpddl.c:	if ( yy_current_buffer->yy_fill_buffer == 0 )
lexpddl.c:		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
lexpddl.c:	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
lexpddl.c:	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
lexpddl.c:			yy_current_buffer->yy_buf_size - number_to_move - 1;
lexpddl.c:			{ /* Not enough room in the buffer - grow it. */
lexpddl.c:				(int) (yy_c_buf_p - b->yy_ch_buf);
lexpddl.c:			if ( b->yy_is_our_buffer )
lexpddl.c:				int new_size = b->yy_buf_size * 2;
lexpddl.c:					b->yy_buf_size += b->yy_buf_size / 8;
lexpddl.c:					b->yy_buf_size *= 2;
lexpddl.c:				b->yy_ch_buf = (char *)
lexpddl.c:					yy_flex_realloc( (void *) b->yy_ch_buf,
lexpddl.c:							 b->yy_buf_size + 2 );
lexpddl.c:				b->yy_ch_buf = 0;
lexpddl.c:			if ( ! b->yy_ch_buf )
lexpddl.c:				"fatal error - scanner input buffer overflow" );
lexpddl.c:			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
lexpddl.c:			num_to_read = yy_current_buffer->yy_buf_size -
lexpddl.c:						number_to_move - 1;
lexpddl.c:		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
lexpddl.c:			yy_current_buffer->yy_buffer_status =
lexpddl.c:	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
lexpddl.c:	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
lexpddl.c:	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
lexpddl.c:/* yy_get_previous_state - get the state just before the EOB char was reached */
lexpddl.c:/* yy_try_NUL_trans - try to make a transition on the NUL character
lexpddl.c:	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
lexpddl.c:		register char *dest = &yy_current_buffer->yy_ch_buf[
lexpddl.c:					yy_current_buffer->yy_buf_size + 2];
lexpddl.c:				&yy_current_buffer->yy_ch_buf[number_to_move];
lexpddl.c:		while ( source > yy_current_buffer->yy_ch_buf )
lexpddl.c:			*--dest = *--source;
lexpddl.c:		yy_cp += (int) (dest - source);
lexpddl.c:		yy_bp += (int) (dest - source);
lexpddl.c:		yy_n_chars = yy_current_buffer->yy_buf_size;
lexpddl.c:		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
lexpddl.c:			YY_FATAL_ERROR( "flex scanner push-back overflow" );
lexpddl.c:	*--yy_cp = (char) c;
lexpddl.c:		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
lexpddl.c:	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
lexpddl.c:		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
lexpddl.c:		yy_current_buffer->yy_n_chars = yy_n_chars;
lexpddl.c:	yy_n_chars = yy_current_buffer->yy_n_chars;
lexpddl.c:	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
lexpddl.c:	yyin = yy_current_buffer->yy_input_file;
lexpddl.c:	b->yy_buf_size = size;
lexpddl.c:	 * we need to put in 2 end-of-buffer characters.
lexpddl.c:	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
lexpddl.c:	if ( ! b->yy_ch_buf )
lexpddl.c:	b->yy_is_our_buffer = 1;
lexpddl.c:	if ( b->yy_is_our_buffer )
lexpddl.c:		yy_flex_free( (void *) b->yy_ch_buf );
lexpddl.c:	b->yy_input_file = file;
lexpddl.c:	b->yy_fill_buffer = 1;
lexpddl.c:	b->yy_is_interactive = 1;
lexpddl.c:	b->yy_is_interactive = 0;
lexpddl.c:	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
lexpddl.c:	b->yy_n_chars = 0;
lexpddl.c:	/* We always need two end-of-buffer characters.  The first causes
lexpddl.c:	 * a transition to the end-of-buffer state.  The second causes
lexpddl.c:	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
lexpddl.c:	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
lexpddl.c:	b->yy_buf_pos = &b->yy_ch_buf[0];
lexpddl.c:	b->yy_at_bol = 1;
lexpddl.c:	b->yy_buffer_status = YY_BUFFER_NEW;
lexpddl.c:	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
lexpddl.c:	     base[size-1] != YY_END_OF_BUFFER_CHAR )
lexpddl.c:	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
lexpddl.c:	b->yy_buf_pos = b->yy_ch_buf = base;
lexpddl.c:	b->yy_is_our_buffer = 0;
lexpddl.c:	b->yy_input_file = 0;
lexpddl.c:	b->yy_n_chars = b->yy_buf_size;
lexpddl.c:	b->yy_is_interactive = 0;
lexpddl.c:	b->yy_at_bol = 1;
lexpddl.c:	b->yy_fill_buffer = 0;
lexpddl.c:	b->yy_buffer_status = YY_BUFFER_NEW;
lexpddl.c:	b->yy_is_our_buffer = 1;
lexpddl.c:			"out of memory expanding start-condition stack" );
lexpddl.c:	if ( --yy_start_stack_ptr < 0 )
lexpddl.c:		YY_FATAL_ERROR( "start-condition stack underflow" );
lexpddl.c:	return yy_start_stack[yy_start_stack_ptr - 1];
lexpddl.c:		yy_c_buf_p = yytext + n - YY_MORE_ADJ; \
lexpddl.c:/* ParsePddl -------------------------------------------------------------------
lexpddl.c:	px->nType=XATOM_LIST;
lexpddl.c:	ppxNext=&pxParent->pxValue;
lexpddl.c:				ppxNext=&pxNested->pxNext;
lexpddl.c:				ppxNext=&pxValue->pxNext;
lexpddl.c:	TranslatePddlProblem(pxTree->pxValue);
lexpddl.c:	if(pxTree->nType!=XATOM_LIST)
lexpddl.c:		fprintf(stderr,"load-pddl-problem:  Expected a list.\n");
lexpddl.c:	px=pxTree->pxValue;
lexpddl.c:	if(!px||px->nCode!=DEFINE)
lexpddl.c:		fprintf(stderr,"load-pddl-problem:  Expected \"define\"\n");
lexpddl.c:	px=px->pxNext;
lexpddl.c:	if(!px||px->nType!=XATOM_LIST)
lexpddl.c:		fprintf(stderr,"load-pddl-problem:  Expected a problem list.\n");
lexpddl.c:	px1=px->pxValue;
lexpddl.c:	if(px1->nCode!=PROBLEM)
lexpddl.c:		fprintf(stderr,"load-pddl-problem:  Expected \"problem\"\n");
lexpddl.c:	px1=px1->pxNext;
lexpddl.c:	if(px1->nCode!=NAME)
lexpddl.c:		fprintf(stderr,"load-pddl-problem:  Expected problem name\n");
lexpddl.c:	psProblem=px1->psValue;				/* save problem name */
lexpddl.c:	for(px=pxSave;px;px=px->pxNext)
lexpddl.c:		if(px->nType!=XATOM_LIST)
lexpddl.c:			fprintf(stderr,"load-pddl-problem:  Expected a list.\n");
lexpddl.c:	for(px=pxSave;px;px=px->pxNext)
lexpddl.c:		px1=px->pxValue;
lexpddl.c:		switch(px1->nCode)
lexpddl.c:				px1=px1->pxNext;
lexpddl.c:				if(px1->nCode!=NAME)
lexpddl.c:					fprintf(stderr,"load-pddl-problem:  Expected domain name\n");
lexpddl.c:				psDomain=px1->psValue;
lexpddl.c:				(*pcCommand->pfForm->paAction->pfEval)(pcCommand,plpCurrentPlan,pbGlobalVariables);
lexpddl.c:	for(px=pxSave;px;px=px->pxNext)
lexpddl.c:		px1=px->pxValue;
lexpddl.c:		switch(px1->nCode)
lexpddl.c:				px1=px1->pxNext;		/* point to first object name */
lexpddl.c:				for(px2=px1;px2;px2=px2->pxNext)	/* scan object list for next type */
lexpddl.c:					if(px2->nCode==HYPHEN)	/* next token is type if we see a hyphen */
lexpddl.c:						px2=px2->pxNext;	/* point to type */
lexpddl.c:							fprintf(stderr,"load-pddl-problem:  Unexpected end of object list\n");
lexpddl.c:						if(SymbolLookup(strlwr(px2->psValue),&psSymbol))	/* if this is a domain symbol */
lexpddl.c:							for(;px1!=px3;px1=px1->pxNext)	/* for all objects of this type */
lexpddl.c:								pxEnd=pxEnd->pxNext=NewXList(XATOM_LIST,0,NULL);	/* create a (type name) list */
lexpddl.c:								pxEnd->pxValue=NewXList(XATOM_IDENT,NAME,px2->psValue);
lexpddl.c:								pxEnd->pxValue->pxNext=CopyXList(px1);
lexpddl.c:						px1=px2->pxNext;	/* point to next object name */
lexpddl.c:	for(px=pxSave;px;px=px->pxNext)
lexpddl.c:		px1=px->pxValue;
lexpddl.c:		switch(px1->nCode)
lexpddl.c:				plEnd=plEnd->plNext=NewList(ATOM_IDENT,"define");
lexpddl.c:				sprintf(acBuf,"state-%s",psProblem);
lexpddl.c:				plEnd=plEnd->plNext=NewList(ATOM_IDENT,acBuf);
lexpddl.c:				for(px2=pxStart;px2;px2=px2->pxNext)
lexpddl.c:					plEnd=plEnd->plNext=TranslateXList(px2);
lexpddl.c:				for(px1=px1->pxNext;px1;px1=px1->pxNext)
lexpddl.c:					plEnd=plEnd->plNext=TranslateXList(px1);
lexpddl.c:		for(px=pxSave;px;px=px->pxNext)
lexpddl.c:			px1=px->pxValue;
lexpddl.c:			switch(px1->nCode)
lexpddl.c:					px2=px1->pxNext;
lexpddl.c:					if(!px2||px2->nType!=XATOM_LIST)
lexpddl.c:						fprintf(stderr,"load-pddl-problem:  Expected a list.\n");
lexpddl.c:					px2=px2->pxValue;
lexpddl.c:					if(px2->nCode==AND)
lexpddl.c:					plEnd=plEnd->plNext=NewList(ATOM_IDENT,"define");
lexpddl.c:					sprintf(acBuf,"goal-%s",psProblem);
lexpddl.c:					plEnd=plEnd->plNext=NewList(ATOM_IDENT,acBuf);
lexpddl.c:					for(px1=px1->pxNext;px1;px1=px1->pxNext)
lexpddl.c:						plEnd=plEnd->plNext=TranslateXList(px1);
lexpddl.c:		// set-goal
lexpddl.c:		plEnd=plEnd->plNext=NewList(ATOM_IDENT,"set-goal");
lexpddl.c:		sprintf(acBuf,"goal-%s",psProblem);
lexpddl.c:		plEnd=plEnd->plNext=NewList(ATOM_LISTP,"",NewList(ATOM_IDENT,acBuf));
lexpddl.c:	// set-initial-world
lexpddl.c:	plEnd=plEnd->plNext=NewList(ATOM_IDENT,"set-initial-world");
lexpddl.c:	sprintf(acBuf,"state-%s",psProblem);
lexpddl.c:	plEnd=plEnd->plNext=NewList(ATOM_LISTP,"",NewList(ATOM_IDENT,acBuf));
lexpddl.c:	// set-plan-name
lexpddl.c:	(*pcCommand->pfForm->paAction->pfEval)(pcCommand,plpCurrentPlan,pbGlobalVariables);
lexpddl.c:	// set-heuristic-fn or set-priority-fn
lexpddl.c:		for(px=pxSave;px;px=px->pxNext)
lexpddl.c:			px1=px->pxValue;
lexpddl.c:			switch(px1->nCode)
lexpddl.c:					/* def-defined-function */
lexpddl.c:					plEnd=plEnd->plNext=NewList(ATOM_IDENT,"def-defined-function");
lexpddl.c:					plEnd=plEnd->plNext=NewList(ATOM_LISTP,"",NewList(ATOM_IDENT,"metric"));
lexpddl.c:					px2=px1->pxNext;		// point to minimize/maximize
lexpddl.c:					px3=px2->pxNext;		// point to expression to evaluate
lexpddl.c:					if((px2->nCode==MAXIMIZE)!=(nPddlSupport==PDDL_PRIORITY_METRIC))	// invert formula for maximize xor priority
lexpddl.c:						plEnd1=plEnd1->plNext=NewList(ATOM_IDENT,"*");
lexpddl.c:						plEnd1=plEnd1->plNext=NewList(ATOM_FLOAT,"-1.0");
lexpddl.c:					plEnd1=plEnd1->plNext=TranslateXList(px3);
lexpddl.c:					if(px2->nCode==MAXIMIZE)
lexpddl.c:					plEnd2=plEnd2->plNext=NewList(ATOM_IDENT,":=");
lexpddl.c:					plEnd2=plEnd2->plNext=NewList(ATOM_IDENT,"metric");
lexpddl.c:					plEnd2->plNext=plStart1;
lexpddl.c:					plEnd=plEnd->plNext=plStart2;
lexpddl.c:					/* set-heuristic-fn or set-priority-fn */
lexpddl.c:						plStart=NewList(ATOM_IDENT,"set-heuristic-fn");
lexpddl.c:						plStart=NewList(ATOM_IDENT,"set-priority-fn");
lexpddl.c:					plStart->plNext=plStart1;
lexpddl.c://	(*pcCommand->pfForm->paAction->pfEval)(pcCommand,plpCurrentPlan,pbGlobalVariables);
lexpddl.c:	for(px=pxList->pxValue;px;px=px->pxNext)
lexpddl.c:		if(px->nType==XATOM_LIST)
lexpddl.c:			plEnd=plEnd->plNext=TranslateXList(px);
lexpddl.c:			if(!stricmp(psDomain,"zeno-travel"))	/* kludge alert! */
lexpddl.c:				if(!stricmp(px->psValue,"next"))
lexpddl.c:					px->psValue=(char *)MemAlloc(strlen("fuel-next")+1);
lexpddl.c:					strcpy(px->psValue,"fuel-next");
lexpddl.c:			plEnd=plEnd->plNext=NewList(ListType(px->nCode),px->psValue);
lexpddl.c:	px->nType=nType;
lexpddl.c:	px->nCode=nCode;
lexpddl.c:		px->psValue=(char *)MemAlloc(strlen(psName)+1);
lexpddl.c:		strcpy(px->psValue,psName);
lexpddl.c:	pxNew->pxNext=NULL;
lexpddl.c:	pxNew->pxValue=NULL;
list.c:/* list.c -- basic list class
list.c:	-This is an implementation of lazy lists.  This implementation aims to
list.c:	-There are no distinct atom structures; We often call any single list
list.c:	-There are no car.cdr cells, so Car(pl) simply returns pl, unless the
list.c:	-Many operators which expect atoms as operands implicitly ignore the fact
list.c:	-The null list is represented by the null pointer, i.e. NULL or 0.
list.c:	-Unless a copy operation is specified, nothing is ever copied.
list.c:	-Copy operations always copy names.
list.c:	-Depending on the copy operation, a list pointed to by an atom may or may
list.c:	-The operators provided here are not sufficient for fully general
list.c:	pl->nType=nType;
list.c:			pl->psName=(char *)MemAlloc(strlen(psName)+1);
list.c:			DoEscapes(pl->psName,(unsigned char *)psName);
list.c:			pl->psName=StrAlloc(pl->psName);
list.c:			pl->psName=IdentAlloc(psName);
list.c:				SymbolLookup(pl->psName,&psSymbol);
list.c:					pl->uValue=psSymbol->uValue;
list.c:					pl->nType=psSymbol->nType;
list.c:				SymbolLookup(pl->psName,&psSymbol);
list.c:					pl->uValue=psSymbol->uValue;
list.c:					pl->nType=psSymbol->nType;
list.c:			pl->uValue.psString=pl->psName;
list.c:				pl->psName=IdentAlloc(acBuffer);
list.c:				pl->uValue.nInteger=atoi(psName);
list.c:				pl->psName=IdentAlloc(acBuffer);
list.c:				pl->uValue.dfFloat=atof(psName);
list.c:			pl->uValue.plList=va_arg(pArg,LISTP);
list.c:			pl->uValue.pbtTree=va_arg(pArg,BTREEP);
list.c:			pl->uValue.pfFunction=va_arg(pArg,FUNCTIONP);
list.c:	if(!pl->psName)
list.c://	return plList->nType!=ATOM_LISTP;
list.c:		pl->plNext=NULL;
list.c:		if(plAtom->psName)
list.c:			if(plAtom->nType==ATOM_STRING)
list.c:				pl->uValue.psString=pl->psName=StrAlloc(plAtom->psName);
list.c:				pl->uValue.psString=pl->psName=IdentAlloc(plAtom->psName);
list.c:	for(plSource=plList;plSource;plSource=plSource->plNext)
list.c:		plEnd=plEnd->plNext=CopyAtom(plSource);
list.c:		if(plEnd->nType==ATOM_LISTP)
list.c:			plEnd->uValue.plList=CopyList(plEnd->uValue.plList);
list.c://		plEnd=plEnd->plNext=CopyAtom(plList);
list.c://		if(plEnd->nType==ATOM_LISTP)
list.c://			plEnd->uValue.plList=CopyList(plEnd->uValue.plList);
list.c://		pl2=pl1->plNext;
list.c://		if(pl1->nType==ATOM_LISTP)
list.c://			FreeList(pl1->uValue.plList);
list.c://		if(pl1->psName)
list.c://			Free(pl1->psName);
list.c:	for(pl=plList;pl;pl=pl->plNext)
list.c:		if(pl->nType==ATOM_LISTP)
list.c:			MarkList(pl->uValue.plList);
list.c://	else if(plList->nType==ATOM_LISTP)
list.c://		pl=CopyList(plList->uValue.plList);
list.c://		for(pl=plList->plNext;pl;pl=pl->plNext)
list.c://			plEnd=plEnd->plNext=CopyAtom(pl);
list.c://			if(plEnd->nType==ATOM_LISTP)
list.c://				plEnd->uValue.plList=CopyList(plEnd->uValue.plList);
list.c://		pl->plNext=CopyList(plRight);
list.c:		if(plLeft->plNext)
list.c:			pl->plNext=plRight;
list.c:			plLeft->plNext=plRight;
list.c://	for(i=0,pl=plList;i<=n&&pl;i++,pl=pl->plNext);
list.c://	return pl->nType==ATOM_LISTP?pl->uValue.plList:pl;
list.c://	for(i=0,pl=plList;pl;i++,pl=pl->plNext);
list.c://		plEnd=plEnd->plNext=NewList(ATOM_LISTP,"",pl);
list.c:	for(pl=plList;pl;pl=pl->plNext)
list.c:		switch(pl->nType)
list.c:				if(pl->psName)
list.c:					nLength=strlen(pl->psName)+2;
list.c:					CommandPrintf(pf,"\"%s\"",pl->psName);
list.c:				if(pl->psName)
list.c:					nLength=strlen(pl->psName);
list.c:					CommandPrintf(pf,"%s",pl->psName);
list.c:				sprintf(acBuffer,"%d",pl->uValue.nInteger);
list.c:				sprintf(acBuffer,"%f",pl->uValue.dfFloat);
list.c:				for(ps=acBuffer+strlen(acBuffer);ps>acBuffer&&*ps=='0';--ps);
list.c:				PrintList(pf,pl->uValue.plList,nLevel+1);
list.c:				PrintFormula(pf,pl->uValue.pcFormula,nLevel+1);
list.c:				ErrorMessage("PrintList:  Unsupported atom type %d\n",pl->nType);
list.c:		if(pl->plNext)
list.c://	for(pl=plList;pl;pl=pl->plNext)
list.c://		switch(pl->nType)
list.c://				sprintf(psBuffer,"\"%s\"",pl->psName);
list.c://				sprintf(psBuffer,"%s",pl->psName);
list.c://				psBuffer=ListToString(pl->uValue.plList,psBuffer);
list.c://				ErrorMessage("Unsupported atom type %d\n",pl->nType);
list.c://		if(pl->plNext)
list.c://	for(pl=plList;pl;pl=pl->plNext)
list.c://		switch(pl->nType)
list.c://				nCount+=strlen(pl->psName)+2;
list.c://				nCount+=strlen(pl->psName);
list.c://				nCount+=ListStringLength(pl->uValue.plList,3);
list.c://				ErrorMessage("Unsupported atom type %d\n",pl->nType);
list.c://		if(pl->plNext)
list.c://		pl1=pl1->plNext,pl2=pl2->plNext
list.c://		if(pl1->nType!=pl2->nType)
list.c://		switch(pl1->nType)
list.c://				if(!StringEqQ(pl1->psName,pl2->psName))
list.c://				if(pl1->uValue.nInteger!=pl2->uValue.nInteger)
list.c://				if(pl1->uValue.pbtTree!=pl2->uValue.pbtTree)
list.c://				if(!ListEqQ(pl1->uValue.plList,pl2->uValue.plList))
list.c://				ErrorMessage("Unknown atomic type: %d\n",pl1->nType);
list.c://	if(plList1->nType!=plList2->nType)
list.c://	switch(plList1->nType)
list.c://			if(!StringEqQ(plList1->psName,plList2->psName))
list.c://			if(plList1->uValue.nInteger!=plList2->uValue.nInteger)
list.c://			if(plList1->uValue.pbtTree!=plList2->uValue.pbtTree)
list.c://			if(!ListEqQ(plList1->uValue.plList,plList2->uValue.plList))
list.c://			ErrorMessage("Unknown atomic type: %d\n",plList1->nType);
list.c://	for(pl=plList;pl;pl=pl->plNext)
list.c:		if(plAtom->psName)
list.c:			ZoneCopy(plAtom->psName);
list.c:		pl1=pl->plNext;					/* ZoneCopyAtom clobbers plNext */
list.c:		if(pl->nType==ATOM_LISTP)
list.c:			ZoneCopyList(pl->uValue.plList);
list.c:		if(plAtom->plNext)
list.c:			ZoneReloc((void **)&plAtom->plNext);
list.c:		if(plAtom->psName)
list.c:			ZoneReloc((void **)&plAtom->psName);
list.c:		pl1=pl->plNext;					/* ZoneRelocAtom clobbers plNext */
list.c:		if(pl->nType==ATOM_LISTP)
list.c:			ZoneRelocList(pl->uValue.plList);
makeform.c:Copyright C, 1998 - 2001 Fahiem Bacchus
makeform.c:/* Non-Atomic Formula Constructors --------------------------------------------- */
makeform.c:	pcTrue->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aTrueAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:	pcFalse->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aFalseAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:(define (make-and-form args)
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aAndAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:	pf->pcArgs=bCopy?CopyCellList(pcArgs):pcArgs;
makeform.c:(define (make-not-form arg)
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aNotAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:		pf->pcArgs=CopyCell(pcArgs);
makeform.c:		pf->pcArgs=pcArgs;
makeform.c:		pcArgs->pcNext=NULL;
makeform.c:(define (make-or-form args)
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aOrAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:	pf->pcArgs=bCopy?CopyCellList(pcArgs):pcArgs;
makeform.c:(define (make-xor-form args)
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aXorAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:	pf->pcArgs=bCopy?CopyCellList(pcArgs):pcArgs;
makeform.c:(define (make-implies-form arg1 arg2)
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aImpliesAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:		pf->pcArgs=CopyCell(pcArg1);
makeform.c:		pf->pcArgs->pcNext=CopyCell(pcArg2);
makeform.c:	  pf->pcArgs=pcArg1;
makeform.c:	  pcArg1->pcNext=pcArg2;
makeform.c:	  pcArg2->pcNext=NULL;
makeform.c:(define (make-if-then-else-form arg1 arg2 arg3)
makeform.c:  (cons 'IF-THEN-ELSE (list arg1 arg2 arg3)))
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aIfThenElseAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:		pf->pcArgs=CopyCell(pcArg1);
makeform.c:		pf->pcArgs->pcNext=CopyCell(pcArg2);
makeform.c:		pf->pcArgs->pcNext->pcNext=CopyCell(pcArg3);
makeform.c:	  pf->pcArgs=pcArg1;
makeform.c:	  pcArg1->pcNext=pcArg2;
makeform.c:	  pcArg2->pcNext=pcArg3;
makeform.c:	  pcArg3->pcNext=NULL;
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aInTheSetAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:		pf->pcVars=CopyCell(pcVars);
makeform.c:		pf->pcArgs=CopyCell(pcVals);
makeform.c:		pf->pcVars=pcVars;
makeform.c:		pf->pcArgs=pcVals;
makeform.c:	CELLP pcGenLit,						/* generator formula (such-that clause) */
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aForAllAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:		pf->pcVars=CopyCellList(pcVariables);
makeform.c:		pf->pcGenLit=CopyCell(pcGenLit);
makeform.c:		pf->pcArgs=CopyCell(pcFormula);
makeform.c:		pf->pcVars=pcVariables;
makeform.c:		pf->pcGenLit=pcGenLit;
makeform.c:		pcGenLit->pcNext=NULL;
makeform.c:		pf->pcArgs=pcFormula;
makeform.c:			pcFormula->pcNext=NULL;
makeform.c:	CELLP pcGenLit,						/* generator formula (such-that clause) */
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aExistsAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:		pf->pcVars=CopyCellList(pcVariables);
makeform.c:		pf->pcGenLit=CopyCell(pcGenLit);
makeform.c:		pf->pcArgs=CopyCell(pcFormula);
makeform.c:		pf->pcVars=pcVariables;
makeform.c:		pf->pcGenLit=pcGenLit;
makeform.c:		pcGenLit->pcNext=NULL;
makeform.c:		pf->pcArgs=pcFormula;
makeform.c:			pcFormula->pcNext=NULL;
makeform.c:	CELLP pcGenLit,						/* generator formula (such-that clause) */
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aExistsXAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:		pf->pcVars=CopyCellList(pcVariables);
makeform.c:		pf->pcGenLit=CopyCell(pcGenLit);
makeform.c:		pf->pcArgs=CopyCell(pcFormula);
makeform.c:		pf->pcVars=pcVariables;
makeform.c:		pf->pcGenLit=pcGenLit;
makeform.c:		pcGenLit->pcNext=NULL;
makeform.c:		pf->pcArgs=pcFormula;
makeform.c:			pcFormula->pcNext=NULL;
makeform.c:(define (make-binding-form vars vals formula)
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aBindingAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:		pf->pcVars=CopyCellList(pcVars);
makeform.c:		pf->pcGenLit=CopyCellList(pcVals);	/* store values in genlit location */
makeform.c:		pf->pcArgs=CopyCell(pcFormula);
makeform.c:		pf->pcVars=pcVars;
makeform.c:		pf->pcGenLit=pcVals;			/* store values in genlit location */
makeform.c:		pf->pcArgs=pcFormula;
makeform.c:		pcFormula->pcNext=NULL;
makeform.c:		for(pc1=pcVars;pc1;pc1=pc1->pcNext)
makeform.c:		for(pc1=pcVals;pc1;pc1=pc1->pcNext)
makeform.c:(define (make-delta-form formula)
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aDeltaAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:		pf->pcArgs=CopyCell(pcArgs);
makeform.c:		pf->pcArgs=pcArgs;
makeform.c:		pcArgs->pcNext=NULL;
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_INTEGER;
makeform.c:	pf->paAction=&aIntegerAction;
makeform.c:	pf->psName=IdentAlloc(acBuffer);
makeform.c:	pf->uValue.nInteger=nValue;
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_FLOAT;
makeform.c:	pf->paAction=&aFloatAction;
makeform.c:	for(ps=acBuffer+strlen(acBuffer);ps>acBuffer&&*ps=='0';--ps);
makeform.c:	pf->psName=IdentAlloc(acBuffer);
makeform.c:	pf->uValue.dfFloat=dfValue;
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_STRING;
makeform.c:	pf->paAction=&aStringAction;
makeform.c:	pf->psName=StrAlloc(psValue);
makeform.c:	pf->uValue.psString=pf->psName;
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=nType;
makeform.c:	pf->paAction=&aLiteralAction;
makeform.c:	pf->uValue=lValue;
makeform.c://			pf->psName=IdentAlloc(ac);
makeform.c://			for(ps=ac+strlen(ac);ps>ac&&*ps=='0';--ps);
makeform.c://			pf->psName=IdentAlloc(ac);
makeform.c:			pf->psName=IdentAlloc(lValue.psString);
makeform.c:			pf->psName=StrAlloc(lValue.psString);
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aAddAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:	pf->pcArgs=bCopy?CopyCellList(pcArgs):pcArgs;
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=plName->nType;
makeform.c:	pf->uValue=plName->uValue;
makeform.c:	pf->psName=IdentAlloc(plName->psName);
makeform.c:	psiSymbolInfo=GetSymbolInfoPtr(pf->psName);
makeform.c:		ErrorMessage("MakeSymbolInfoForm:  Unknown symbol %s\n",plName->psName);
makeform.c:		if(psiSymbolInfo->nArity>=0)
makeform.c:			for(pc1=pcArgs;pc1;pc1=pc1->pcNext)
makeform.c:			if(psiSymbolInfo->nArity!=nLength)
makeform.c:					pf->psName,nLength,nLength==1?"":"s",psiSymbolInfo->nArity);
makeform.c:		pf->paAction=psiSymbolInfo->paAction;
makeform.c:	pf->pcArgs=bCopy?CopyCellList(pcArgs):pcArgs;
makeform.c:	if(psiSymbolInfo->nSymbolType==SYMBOL_MACRO)
makeform.c:		pc=(*pc->pfForm->paAction->pfCompute)(pc,NULL,NULL);
makeform.c:	Make an search-global-initialization formula.
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aSearchGlobalInitializationAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:		pf->pcArgs=CopyCell(pcArg1);
makeform.c:		pf->pcArgs->pcNext=CopyCell(pcArg2);
makeform.c:		pf->pcArgs=pcArg1;
makeform.c:		pcArg1->pcNext=pcArg2;
makeform.c:		pcArg2->pcNext=NULL;
makeform.c:	Make an optimal-cost formula.
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aOptimalCostAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:	Make a best-action formula.
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aBestActionAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:/* routines called from user libraries -------------------------------------- */
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aEqAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:		pf->pcArgs=CopyCell(pcArg1);
makeform.c:		pf->pcArgs->pcNext=CopyCell(pcArg2);
makeform.c:	  pf->pcArgs=pcArg1;
makeform.c:	  pcArg1->pcNext=pcArg2;
makeform.c:	  pcArg2->pcNext=NULL;
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aGlobalDelayedActionAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:		pf->pcArgs=CopyCell(pcArg1);
makeform.c:		pf->pcArgs->pcNext=CopyCell(pcArg2);
makeform.c:		pf->pcArgs->pcNext->pcNext=CopyCell(pcArg3);
makeform.c:	  pf->pcArgs=pcArg1;
makeform.c:	  pcArg1->pcNext=pcArg2;
makeform.c:	  pcArg2->pcNext=pcArg3;
makeform.c:	  pcArg3->pcNext=NULL;
makeform.c:	Make a set-initialization-sequence formula
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aSetInitializationSequenceAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:	pf->pcArgs=bCopy?CopyCellList(pcArgs):pcArgs;
makeform.c:	Make a set-initial-world formula
makeform.c:	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c:	pf->nType=ATOM_IDENT;
makeform.c:	pf->paAction=&aSetInitialWorldAction;
makeform.c:	pf->psName=pf->paAction->psName;
makeform.c:	pf->pcArgs=bCopy?CopyCellList(pcArgs):pcArgs;
makeform.c:	Make a print-delta-time formula
makeform.c://	pc->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makeform.c://	pf->nType=ATOM_IDENT;
makeform.c://	pf->paAction=&aPrintDeltaTimeAction;
makeform.c://	pf->psName=pf->paAction->psName;
makeform.c://	pf->pcArgs=bCopy?CopyCellList(pcArgs):pcArgs;
makegen.c:/* makegen.c -- Generator Routines
makegen.c:/* GenerateDescPredicate -------------------------------------------------------
makegen.c:(define (make-desc-pred-generator gen-lit variables world/action bindings)
makegen.c:	(let* ((index (get-symbol-index (get-operator gen-lit)))
makegen.c:			(args (eval-terms (get-args gen-lit) world/action bindings))
makegen.c:			(generator (desc-predicate-generator index world/action)))
makegen.c:		(letrec ((find-next
makegen.c:							(if (test-tuple)
makegen.c:								(begin (set-bindings) #t)
makegen.c:								(find-next))
makegen.c:				(test-tuple
makegen.c:				(set-bindings
makegen.c:						(for-each
makegen.c:								(if (var? arg) (set-var! arg val bindings)))
makegen.c:					(find-next))
makegen.c:		pbBindings->pgcContext=(GCONTEXTP)pgc;
makegen.c:		nIndex=pcGenLit->pfForm->uValue.psiSymbolInfo-asiWorldSymbols;
makegen.c:		if(pcGenLit->pfForm->pcArgs)
makegen.c:			pgc->pcArgs=ComputeTerms(pcGenLit->pfForm->pcArgs,
makegen.c:			if(!pgc->pcArgs)
makegen.c:				TermError("generate-desc-predicate",pcGenLit,pbBindings);
makegen.c:		if(VarQ(pgc->pcArgs))
makegen.c:			BTreeGenerator(pbtArgTree,&pgc->pvContext);	/* initialize generator */
makegen.c:			BTreeGeneratorWithBoundVars(pbtArgTree,&pgc->pvContext,pgc->pcArgs);
makegen.c:	if(VarQ(pgc->pcArgs))
makegen.c:		for(pcTuple=BTreeGenerator(NULL,&pgc->pvContext);pcTuple;
makegen.c:			pcTuple=BTreeGenerator(NULL,&pgc->pvContext))
makegen.c:			if(TestTuple(pcTuple,pgc->pcArgs))
makegen.c:				SetBindings(pcTuple,pgc->pcArgs,pbBindings);
makegen.c:		for(pcTuple=BTreeGeneratorWithBoundVars(NULL,&pgc->pvContext,pgc->pcArgs);pcTuple;
makegen.c:			pcTuple=BTreeGeneratorWithBoundVars(NULL,&pgc->pvContext,pgc->pcArgs))
makegen.c:			if(TestTuple(pcTuple,pgc->pcArgs))
makegen.c:				SetBindings(pcTuple,pgc->pcArgs,pbBindings);
makegen.c:	for(pc1=pcTuple,pc2=pcArgs;pc1&&pc2;pc1=pc1->pcNext,pc2=pc2->pcNext)
makegen.c:		pbBindings->pgcContext=(GCONTEXTP)pgc;
makegen.c:		psiSymbolInfo=pcGenLit->pfForm->uValue.psiSymbolInfo;
makegen.c:		pcGenerator->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makegen.c:		pf->nType=ATOM_IDENT;
makegen.c:		sprintf(acBuffer,"?%s",psiSymbolInfo->psName);
makegen.c:		pf->psName=IdentAlloc(acBuffer);
makegen.c:		if(pcGenLit->pfForm->pcArgs)
makegen.c:			pcTerms=ComputeTerms(pcGenLit->pfForm->pcArgs,plpLinearPlan,pbBindings);
makegen.c:				TermError("generate-def-generator",pcGenLit,pbBindings);	
makegen.c:		pgc->pbBindings=pb;				/* save our bindings list */
makegen.c:		pgc->pbTranslation=NULL;
makegen.c:		for(pc=pcVars;pc;pc=pc->pcNext)
makegen.c:			for(pc1=GetDefParameters(psiSymbolInfo),pc2=pcGenLit->pfForm->pcArgs;pc2;pc1=pc1->pcNext,pc2=pc2->pcNext)
makegen.c:					pgc->pbTranslation=ExtendBindings(CopyCell(pc1),CopyCell(pc2),pgc->pbTranslation);
makegen.c:		psiSymbolInfo=pcGenLit->pfForm->uValue.psiSymbolInfo;
makegen.c:		pb=pgc->pbBindings;
makegen.c:		pcGenerator->pfForm=pf=(FORMULAP)MemAlloc(sizeof(FORMULA));
makegen.c:		pf->nType=ATOM_IDENT;
makegen.c:		sprintf(acBuffer,"?%s",psiSymbolInfo->psName);
makegen.c:		pf->psName=IdentAlloc(acBuffer);
makegen.c:	b=(*pc->pfForm->paAction->pfEval)(pc,plpLinearPlan,pb);
makegen.c:	for(pb=pgc->pbTranslation;pb;pb=pb->pbNext)
makegen.c:		pc=LookupVar(pb->pcVar,pgc->pbBindings);
makegen.c:		SetVarX(pb->pcVal,pc,pbBindings);
makegen.c:  for(pc1=pcTuple,pc2=pcArgs;pc1&&pc2;pc1=pc1->pcNext,pc2=pc2->pcNext)
makegen.c:/* GenerateEq ------------------------------------------------------------------
makegen.c:		if(VarQ(pcGenLit->pfForm->pcArgs))
makegen.c:			pcVar=pcGenLit->pfForm->pcArgs;
makegen.c:			pcGen=pcVar->pcNext;
makegen.c:			pcGen=pcGenLit->pfForm->pcArgs;
makegen.c:			pcVar=pcGen->pcNext;
makegen.c:		if(!StringEqQ(IdentName(pcVar->pfForm),IdentName(pcVars->pfForm))||pcVars->pcNext)
makegen.c:			ErrorMessage("generate-eq:	Free variable mismatch.\n");
makegen.c:		if(!pcGen->pfForm->paAction->pfCompute)
makegen.c:			ErrorMessage("generate-eq:	Value cannot be computed.\n");
makegen.c:			if(pcGen->pfForm->paAction->pfCompute!=ComputeDescFunction)
makegen.c:				TermError("generate-eq:	Invalid expression.\n",pcVal,pbBindings);
makegen.c:/* GenerateFunction --------------------------------------------------------
makegen.c:(define (make-fn-value-generator gen-lit variables world/action bindings)
makegen.c:	(let* ((value (eval-term (get-fn-lit-gen gen-lit) world/action bindings))
makegen.c:			(first-time #t))
makegen.c:			(if first-time
makegen.c:				(begin (set-var! (first variables) value bindings)
makegen.c:					(set! first-time #f)
makegen.c:/* Modalities ---------------------------------------------------------------- */
makegen.c:	b=(*pcGenLit->pfForm->pcArgs->pfForm->paAction->pfGenerator)
makegen.c:		(pcGenLit->pfForm->pcArgs,ppvContext,pcVars,GetGoalWorld(TRUE),pbBindings);
makegen.c:	b=(*pcGenLit->pfForm->pcArgs->pfForm->paAction->pfGenerator)
makegen.c:		(pcGenLit->pfForm->pcArgs,ppvContext,pcVars,plpCurrentPlan,pbBindings);
makegen.c:		plp=plp->plpParent;
makegen.c:		b=(*pcGenLit->pfForm->pcArgs->pfForm->paAction->pfGenerator)
makegen.c:			(pcGenLit->pfForm->pcArgs,ppvContext,pcVars,plp,pbBindings);
makegen.c:		pcGen=pcGenLit->pfForm->pcArgs;
makegen.c:			ErrorMessage("permute-generator:  Generator argument missing\n");
makegen.c:		if(pcGen->pfForm->nType!=ATOM_SYMBOLINFOP)
makegen.c:			ErrorMessage("permute-generator:  Unsupported generator type\n");
makegen.c:		psiSymbolInfo=pcGen->pfForm->uValue.psiSymbolInfo;
makegen.c:			ErrorMessage("permute-generator:  Unsupported generator type\n");
makegen.c:		pbBindings->pgcContext=(GCONTEXTP)pgc;	
makegen.c:		nIndex=psiSymbolInfo-asiWorldSymbols;
makegen.c:		if(pcGen->pfForm->pcArgs)
makegen.c:			pgc->pcArgs=ComputeTerms(pcGen->pfForm->pcArgs,plpLinearPlan,pbBindings);
makegen.c:			if(!pgc->pcArgs)
makegen.c:				TermError("permute-generator",pcGen,pbBindings);
makegen.c:			if(TestTuple(pcTuple,pgc->pcArgs))
makegen.c:				pcEnd=pcEnd->pcNext=(CELLP)MemAlloc(sizeof(CELL));
makegen.c:				pcEnd->pfForm=(FORMULAP)MemAlloc(sizeof(FORMULA));	// dummy formula
makegen.c:				pcEnd->pfForm->pcArgs=pcTuple;
makegen.c:			pc=pc->pcNext;
makegen.c:		pgc->pcVals=NULL;
makegen.c:		pcEnd=(CELLP)&pgc->pcVals;
makegen.c:			pcEnd=pcEnd->pcNext=ppc1[i];
makegen.c:			ppc1[i]=ppc1[--nCount];
makegen.c:		pcEnd->pcNext=NULL;
makegen.c:	if(!pgc->pcVals)
makegen.c:	pc=pgc->pcVals;
makegen.c:	pgc->pcVals=pc->pcNext;
makegen.c:	SetBindings(pc->pfForm->pcArgs,pgc->pcArgs,pbBindings);
msort.c:Copyright C, 1997 - 99  Winter City Software Corp.
msort.c:	if(pmList&&pmList->pmNext)			/* if something to sort */
msort.c:	pm2=pmList->pmNext->pmNext;			/* must be at least 2 nodes in list */
msort.c:		pm1=pm1->pmNext;
msort.c:		pm2=pm2->pmNext;
msort.c:			pm2=pm2->pmNext;
msort.c:	pm2=pm1->pmNext;					/* break after pm1 */
msort.c:	pm1->pmNext=0;
msort.c:		pm1=pm1->pmNext;
msort.c:		pm2=pm2->pmNext;
msort.c:			pm=pm->pmNext=pm1;
msort.c:			pm1=pm1->pmNext;
msort.c:			pm=pm->pmNext=pm2;
msort.c:			pm2=pm2->pmNext;
msort.c:		pm->pmNext=pm1;					/* attach remaining list */
msort.c:		pm->pmNext=pm2;
oper.c:/* oper.c -- Operators
oper.c:Copyright C, 1996 - 99  F. Bacchus
oper.c:(define (make-operator . keyword-args)
oper.c:	   (duration 1) (cost 1) (priority 0) (update '()) (eval-object '()))
oper.c:	((null? keyword-args))
oper.c:	  (case (first keyword-args)
oper.c:	(:name (set! name (cadr keyword-args)))
oper.c:	(:pre (set! pre (cadr keyword-args)))
oper.c:	(:add (set! add (cadr keyword-args)))
oper.c:	(:del (set! del (cadr keyword-args)))
oper.c:	(:duration (set! duration (cadr keyword-args)))
oper.c:	(:cost (set! cost (cadr keyword-args)))
oper.c:	(:priority (set! priority (cadr keyword-args)))
oper.c:	(:update (set! update (cadr keyword-args)))
oper.c:	(:eval-object (set! eval-object (cadr keyword-args)))
oper.c:	(else (error "Illegal keyword: ~A" (first keyword-args))))
oper.c:	  (set! keyword-args (cddr keyword-args)))
oper.c:		eval-object)))
oper.c:	po->pcName=(CELLP)MemAlloc(sizeof(CELL));
oper.c:	po->pcName->pfForm=pcName->pfForm;
oper.c:	po->pcSuccessor=pcSuccessor;
oper.c:	po->pcDuration=pcDuration;
oper.c:	po->pcCost=pcCost;
oper.c:	po->pcPriority=pcPriority;
oper.c:	poOperEnd=poOperEnd->poNext=po;
oper.c:	if(po->pcName)
oper.c:		MarkFormula(po->pcName);
oper.c:	if(po->pcSuccessor)
oper.c:		MarkFormula(po->pcSuccessor);
oper.c:	if(po->pcDuration)
oper.c:		MarkFormula(po->pcDuration);
oper.c:	if(po->pcCost)
oper.c:		MarkFormula(po->pcCost);
oper.c:	if(po->pcPriority)
oper.c:		MarkFormula(po->pcPriority);
oper.c:(define (clear-ops )
oper.c:	pmo->psName=IdentAlloc(psName);
oper.c:	pmo->psDomain=StrAlloc(psDomain);
oper.c:	pmo->pcGoal=CopyCell(pcGoal);
oper.c:	pmoMacroOperEnd=pmoMacroOperEnd->pmoNext=pmo;
oper.c:	if(pmo->pcGoal)
oper.c:		MarkFormula(pmo->pcGoal);
oper.c:	peo->psName=IdentAlloc(psName);
oper.c:	peoElidedOperEnd=peoElidedOperEnd->peoNext=peo;
plan.c:Copyright C, 1996 - 2001	F. Bacchus
plan.c:-----------------------------------------------------------------------
plan.c:	CELLP pcFormulaList,				/* formula-list to check */
plan.c:/* -----------------------------------------------------------------------------
plan.c: startWorldAction --- a worldAction structure (as set up by worlds.cl)
plan.c: searchFn	--- return the search mode used.
plan.c: priorityFn	--- return the depthFirst priority function.
plan.c: costFn		--- return the bestFirst cost function.
plan.c:(define (tlplanner start-world/action tlform search-fn priority-fn cost-fn)
plan.c:	(let* ((initial-plan
plan.c:				(make-plan start-world/action
plan.c:			(search-result '())
plan.c:			(plan-time 0))
plan.c:				(format *trace-stream* "~%----------------------------------~
plan.c:					------------------------------------")
plan.c:				(format *trace-stream* "~%Planner invoked. Initial world:")
plan.c:				(print-world start-world/action *trace-stream*)
plan.c:				(format *trace-stream* "~%Goal is:")
plan.c:				(format *trace-stream* "~%~S" (get-goal))))
plan.c:		(set! plan-time (get-internal-run-time))
plan.c:		(set! *pruned-worlds* 0)
plan.c:		(set! search-result
plan.c:			(search-fn initial-plan plan-goal? plan-successor-fn plan=
plan.c:				cost-fn priority-fn (get-search-limit)))
plan.c:		(set! plan-time (- (get-internal-run-time) plan-time))
plan.c:				(format *trace-stream*
plan.c:					(round (/ plan-time internal-time-units-per-second)))
plan.c:					((eq? (first search-result) 'RESOURCES)
plan.c:						(format *trace-stream*
plan.c:					((eq? (first search-result) 'NO-PLAN)
plan.c:						(format *trace-stream* "~%All possible plans exhaused. ~
plan.c:						(format *trace-stream* "~%~%Found plan, final world:")
plan.c:						(print-world (plan-world/action (first search-result))
plan.c:						*trace-stream*)))
plan.c:			(format *trace-stream* "~%Worlds searched  = ~S"
plan.c:				(- (third search-result) *pruned-worlds*))
plan.c:			(format *trace-stream* "~%Worlds pruned by temporal control = ~S"
plan.c:				*pruned-worlds*)
plan.c:			(format *trace-stream* "~%Worlds unexamined  = ~S"
plan.c:				(second search-result))
plan.c:			(if (not (or (eq? (first search-result) 'RESOURCES)
plan.c:						(eq? (first search-result) 'NO-PLAN)))
plan.c:					(format *trace-stream* "~%Plan length = ~A"
plan.c:						(plan-length (first search-result)))
plan.c:					(do ((time (get-initial-time))
plan.c:							(successors (rest (plan-world/actions
plan.c:										(first search-result))))
plan.c:							(format *trace-stream* "~%At time ~A: Plan completed"
plan.c:						(format *trace-stream* "~%At time ~A: ~A"
plan.c:							time (world/action-action-name successor))
plan.c:						(set! time (+ time (world/action-action-duration
plan.c:					;;Return the planning time, and search-result.
plan.c:					(format *trace-stream* "~%Plan cost: ~A"
plan.c:						(plan-cost (first search-result)))))
plan.c:				(format *trace-stream* "~%-----------------------------------------~
plan.c:					-----------------------------")))
plan.c:		(list plan-time (first search-result)
plan.c:			(- (third search-result) *pruned-worlds*)
plan.c:			*pruned-worlds* (second search-result))))
plan.c:	pcCCForm=(pcTLForm->pfForm->paAction->pfMakeCCForm)(FALSE,pcTLForm,&bImmutable);
plan.c:	plpOpen->plpNext=NULL;				/* discard any previous plan! */
plan.c:			CommandPrintf(pfTraceStream,"-----------------------------------------"
plan.c:				"---------------------------------------\n");
plan.c:		for(pc=pcSearchGlobalInit;pc;pc=pc->pcNext)
plan.c:			(*pc->pfForm->paAction->pfEval)(pc,plpOpen,pbGlobalVariables);
plan.c:	dfPlanTime=GetInternalRunTime()-dfPlanTime;
plan.c:		CommandPrintf(pfTraceStream,"-----------------------------------------"
plan.c:			"---------------------------------------\n");
plan.c:			pfFinalWorldGoalQ==ClassicGoalQ?nWorldNumber-1:nWorldNumber);	/* don't count goal world */
plan.c:			srSearchResult.nClosedLength-srSearchResult.nWorldsPruned);
plan.c:					for(plpSuccessor=plpSuccessors->plpNext;plpSuccessor;
plan.c:						plpSuccessor=plpSuccessor->plpNext)
plan.c:							nState++,plpSuccessor->dfTime,
plan.c:							plpSuccessor->nWorldNumber);
plan.c:						PrintFlatFormula(pfTraceStream,plpSuccessor->pcActionName);
plan.c:					for(plpSuccessor=plpSuccessors->plpNext;plpSuccessor;
plan.c:						plpSuccessor=plpSuccessor->plpNext)
plan.c:							dfTime,plpSuccessor->nWorldNumber);
plan.c:						PrintFormula(pfTraceStream,plpSuccessor->pcActionName,0);
plan.c:				srSearchResult.plpState->dfCost);
plan.c:			CommandPrintf(pfTraceStream,"-----------------------------------------"
plan.c:				"---------------------------------------\n");
plan.c:	srSearchResult.nWorldsGenerated=nWorldNumber-1;	/* worlds generated */
plan.c:	srSearchResult.nWorldsSearched=srSearchResult.nClosedLength-srSearchResult.nWorldsPruned;	/* worlds searched */
plan.c://	dfGCTime=GetInternalRunTime()-dfGCTime;	// debug
plan.c://	dfGCTime=GetInternalRunTime()-dfGCTime;	// debug
plan.c:		if(!pcHeuristicFn->pfForm->uValue.psiSymbolInfo->pcFormula)
plan.c:				pcHeuristicFn->pfForm->psName);
plan.c:		if(!pcPriorityFn->pfForm->uValue.psiSymbolInfo->pcFormula)
plan.c:				pcPriorityFn->pfForm->psName);
plan.c:		if(!pcPrintWorld->pfForm->uValue.psiSymbolInfo->pcFormula)
plan.c:				pcPrintWorld->pfForm->psName);
plan.c:		if(!pcGoalAddendum->pfForm->uValue.psiSymbolInfo->pcFormula)
plan.c:				pcGoalAddendum->pfForm->psName);
plan.c:	for(pmo=pmoMacroOperators;pmo;pmo=pmo->pmoNext)
plan.c:		for(po=poOperators;po;po=po->poNext)
plan.c:			if(StringEqQ(pmo->psName,GetName(po->pcName->pfForm,ac)))
plan.c:				pmo->psName);
plan.c:	// make sure we have a wait-for-next-event if we're concurrent planning
plan.c:		for(po=poOperators;po;po=po->poNext)
plan.c:			if(FormulaCallsQ(po->pcSuccessor,&aWaitForNextEventAction))
plan.c:			ErrorMessage("Concurrent domain does not call wait-for-next-event inside any operator\n");
plan.c:	Initialize the macro-expansion local variables.
plan.c:	Scan a plan, looking for macro-actions.  For each macro-action,
plan.c:	make the macro-action's parent the initial micro-world, and the macro-action's
plan.c:	successor the goal micro-world.  Release the open and closed lists, load the 
plan.c:				plpSuffix->plpParent=plpFinal;
plan.c:			for(plpSuffix=plpFinal;plpSuffix->plpParent!=plpPrefixTail;plpSuffix=plpSuffix->plpParent);	/* new suffix is start of subplan */
plan.c:	for(plp=plpPrefixTail;plp;plp=plp->plpParent)
plan.c:		for(pmo=pmoMacroOperators;pmo;pmo=pmo->pmoNext)
plan.c:			if(!plp->pcActionName)		/* if initial world, we're done */
plan.c:			if(StringEqQ(pmo->psName,IdentName(plp->pcActionName->pfForm)))
plan.c:				plpPrefixTail=plp->plpParent;
plan.c:		CommandPrintf(pfTraceStream,"\nMacro expanding world %d: ",plp->nWorldNumber);
plan.c:		PrintFlatFormula(pfTraceStream,plpMacroWorld->pcActionName);
plan.c://		CommandPrintf(pfTraceStream,"\nParent world %d: ",plpPrefixTail->nWorldNumber);
plan.c://		PrintFlatFormula(pfTraceStream,plpPrefixTail->pcActionName);
plan.c:		CommandPrintf(stderr,"\nMacro expanding world %d: ",plp->nWorldNumber);
plan.c:		PrintFlatFormula(stderr,plpMacroWorld->pcActionName);
plan.c://		CommandPrintf(stderr,"\nParent world %d: ",plpPrefixTail->nWorldNumber);
plan.c://		PrintFlatFormula(stderr,plpPrefixTail->pcActionName);
plan.c:	if(!StringEqQ(pmo->psDomain,psMacroDomain))
plan.c:		LoadFile(pmo->psDomain);
plan.c:		psMacroDomain=pmo->psDomain;
plan.c:	pcGoalFormula=pmo->pcGoal;
plan.c:	plpOpen->plpNext=NULL;
plan.c:(define (make-linear-plan world/action tlform duration
plan.c:  (vector 'linear-plan world/action tlform duration
plan.c:	plpWorldAction->pcTLForm=pcTLForm;
plan.c:	plpWorldAction->pcCCForm=pcCCForm;
plan.c:		plpWorldAction->dfTime=dfTime;
plan.c:	plpWorldAction->dfCost=dfCost;
plan.c:	plpWorldAction->nLength=nLength;
plan.c:	plpWorldAction->plpParent=plpParent;
plan.c:		plpWorldAction->dfHeuristic=CalculateHeuristic(pcHeuristicFn,plpWorldAction,pbBindings);
plan.c:		plpWorldAction->dfPriority=CalculatePriority(pcPriorityFn,plpWorldAction,pbBindings);
plan.c:		if(plpLinearPlan->apbtWorld)
plan.c:			MarkWorld(plpLinearPlan->apbtWorld);
plan.c:			MarkFormula(plpLinearPlan->pcActionName);
plan.c:			MarkBindings((BINDINGP)(plpLinearPlan->nSignature));	/* promises bindings list stored here! */
plan.c:			MarkFormula(plpLinearPlan->pcPromise);
plan.c:				MarkFormula(plpLinearPlan->pcActionName);
plan.c:		MarkFormula(plpLinearPlan->pcTLForm);
plan.c:		if(plpLinearPlan->pcCCForm)
plan.c:			MarkFormula(plpLinearPlan->pcCCForm);
plan.c:(define copy-linear-plan vector-copy)
plan.c:	plpCopy->apbtWorld=CopyWorld(plp->apbtWorld);
plan.c:	plpCopy->pcActionName=CopyCell(plp->pcActionName);
plan.c:	plpCopy->pcPromise=CopyCell(plp->pcPromise);
plan.c:	plpCopy->pcTLForm=CopyCell(plp->pcTLForm);
plan.c:/* PlanCount -------------------------------------------------------------------
plan.c:	for(plp=plpPlan;plp;plp=plp->plpNext)
plan.c:/* -----------------------------------------------------------------------------
plan.c:(define (plan-extend new-world/action new-tlform plan)
plan.c:	(make-plan new-world/action new-tlform
plan.c:			   (+ (world/action-action-duration new-world/action)
plan.c:		  (plan-duration plan))
plan.c:			   (+ (world/action-action-cost new-world/action) (plan-cost plan))
plan.c:			   (+ 1 (plan-length plan))
plan.c:/* PlanExtendedEqQ -------------------------------------------------------------
plan.c:(defun plan-extended= (plan1 plan2)
plan.c:  (and (world= (plan-world plan1) (plan-world plan2))
plan.c:	   (equal (plan-tlform plan1) (plan-tlform plan2))))
plan.c:(define (plan-classic= plan1 plan2)
plan.c:  (world= (plan-world plan1) (plan-world plan2)))
plan.c:/* PlanGoalQ -------------------------------------------------------------------
plan.c:(define (plan-goal? plan)
plan.c:  (final-world-goal? (plan-tlform plan) (plan-world/action plan)))
plan.c:(define (plan-world/actions plan)
plan.c:  (reverse (map-plan plan-world/action plan)))
plan.c:	for(plp=plpPlan;plp;plp=plp->plpParent)
plan.c:		plp->plpNext=plpFirst;
plan.c:	for(plp=plpList;plp;plp=plp->plpNext)
plan.c:		WorldSizeOf(plp->apbtWorld,&nWorldSize);
plan.c:		FormulaSizeOf(plp->pcTLForm,&nControlSize);
plan.c://			plp->nWorldNumber,nWorldSize,nControlSize); 
plan.c://		ZoneCopyWorld(plpLinearPlan->apbtWorld);
plan.c://		ZoneCopyFormula(plpLinearPlan->pcActionName);
plan.c://		ZoneCopyFormula(plpLinearPlan->pcPromise);
plan.c://		ZoneCopyFormula(plpLinearPlan->pcTLForm);
plan.c://		ZoneReloc(&plpLineaarPlan->apbtWorld);
plan.c://		ZoneRelocWorld(plpLinearPlan->apbtWorld);
plan.c://		ZoneReloc(&plpLinearPlan->pcActionName);
plan.c://		ZoneRelocFormula(plpLinearPlan->pcActionName);
plan.c://		ZoneReloc(&plpLinearPlan->pcPromise);
plan.c://		ZoneRelocFormula(plpLinearPlan->pcPromise);
plan.c://		ZoneReloc(&plpLinearPlan->pcTLForm);
plan.c://		ZoneRelocFormula(plpLinearPlan->pcTLForm);
plan.c:	dfTime=GetInternalRunTime()-dfPddlTime;	/* calculate total time */
plan.c:			for(plpSuccessor=plpSuccessors->plpNext;plpSuccessor;
plan.c:				plpSuccessor=plpSuccessor->plpNext)
plan.c://				if(StringEqQ(plpSuccessor->pcActionName->pfForm->psName,apsStringTab[STRING_EVENT]))
plan.c:				if(!strcmp(plpSuccessor->pcActionName->pfForm->psName,"event"))
plan.c:				for(peo=peoElidedOperators;peo;peo=peo->peoNext)
plan.c:					if(StringEqQ(plpSuccessor->pcActionName->pfForm->psName,peo->psName))
plan.c:					plpSuccessor->dfTime+1.0);
plan.c:				PrintFlatFormula(ofs,plpSuccessor->pcActionName);
plan.c:				if(plpSuccessor->dfDuration)
plan.c:					fprintf(ofs," [%f]\n",plpSuccessor->dfDuration);
plan.c:			for(plpSuccessor=plpSuccessors->plpNext;plpSuccessor;
plan.c:				plpSuccessor=plpSuccessor->plpNext)
plan.c:				for(peo=peoElidedOperators;peo;peo=peo->peoNext)
plan.c:					if(StringEqQ(plpSuccessor->pcActionName->pfForm->psName,peo->psName))
plan.c:				PrintFormula(ofs,plpSuccessor->pcActionName,0);
plan.c:// -----------------------------------------------------------------------------
plan.c:	CELLP pcFormulaList,				/* formula-list to check */
plan.c:	for(pcFormula=pcFormulaList;pcFormula;pcFormula=pcFormula->pcNext)
plan.c:		if(pcFormula->pfForm->paAction==paAction)
plan.c:		for(pc=pcFormula->pfForm->pcVars;pc;pc=pc->pcNext)
plan.c:		for(pc=pcFormula->pfForm->pcGenLit;pc;pc=pc->pcNext)
plan.c:		for(pc=pcFormula->pfForm->pcArgs;pc;pc=pc->pcNext)
progress.c:Copyright C, 1996 - 2001  F. Bacchus
progress.c:Temporal Progressor -- Functions that manage temporal formulas expressed in LTL.
progress.c:/* Run Time Routines ----------------------------------------------------------- */
progress.c:(define (progress-formula form world/action bindings)
progress.c:        (let ((dispatch-fn (lookup-progress-eval (get-operator form))))
progress.c:                (if dispatch-fn
progress.c:                        (dispatch-fn form world/action bindings)
progress.c:                        (eval-atomic (get-operator form)
progress.c:                                (eval-terms (get-args form) world/action bindings)
progress.c://      pc=(*pcFormula->pfForm->paAction->pfProgress)(pcFormula,plpLinearPlan,pbBindings);
progress.c:/* Boolean Formulas ------------------------------------------------------------ */
progress.c:(define (progress-false form world/action bindings)
progress.c:(define (progress-true form world/action bindings)
progress.c:(define (progress-not form world/action bindings)
progress.c:        (let* ((subform (first (get-args form)))
progress.c:                        (new-subform (progress-formula subform world/action bindings)))
progress.c:                        ((not new-subform) #t)
progress.c:                        ((eq? #t new-subform) #f)
progress.c:                        ((eq? new-subform subform) form)
progress.c:                        (else (make-not-form new-subform)))))
progress.c:  pcArg1=pcFormula->pfForm->pcArgs;
progress.c:  pcNewArg1=(*pcArg1->pfForm->paAction->pfProgress)
progress.c:  else if(pcNewArg1->pfForm==pcArg1->pfForm) {
progress.c:    pc=MakeNotForm(FALSE,(pcNewArg1->pcNext&&immutable)?CopyCell(pcNewArg1):pcNewArg1);
progress.c:(define (progress-and form world/action bindings)
progress.c:        (let ((new-subforms '())
progress.c:                        (new-subform #f)
progress.c:                        (make-new #f)
progress.c:                (do ((subforms (get-args form))
progress.c:                        (set! new-subform (progress-formula subform world/action bindings))
progress.c:                                ((not new-subform)
progress.c:                                        (set! new-subforms '())
progress.c:                                ((eq? new-subform #t)
progress.c:                                        (set! make-new #t))
progress.c:                                ((eq? new-subform subform)
progress.c:                                        (set! new-subforms (cons subform new-subforms)))
progress.c:                                ((and-formp new-subform)
progress.c:                                        (set! make-new #t)
progress.c:                                        (set! new-subforms (append (get-args new-subform) new-subforms)))
progress.c:                                        (set! make-new #t)
progress.c:                                        (set! new-subforms (cons new-subform new-subforms)))))
progress.c:                        ((null? new-subforms) #t)
progress.c:                        ((not make-new) form)
progress.c:                        ((length=1 new-subforms) (first new-subforms))
progress.c:                        (else (make-and-form new-subforms)))))
progress.c:	for(pcSubForm=pcFormula->pfForm->pcArgs;pcSubForm;pcSubForm=pcSubForm->pcNext)
progress.c:		pcNewSubForm=(*pcSubForm->pfForm->paAction->pfProgress)
progress.c:		if(pcNewSubForm->pfForm!=pcSubForm->pfForm)
progress.c:  if(pcSubForm!=pcFormula->pfForm->pcArgs)
progress.c:    pcNewSubForms=CopyPrefixCellList(pcFormula->pfForm->pcArgs,pcSubForm,&pcNewSubFormsEnd);
progress.c:      //  pcNewSubFormsEnd->pcNext=CopyCellListReturnEndCell(pcNewSubForm->pfForm->pcArgs,&pcTemp);
progress.c:	  pcNewSubFormsEnd=pcNewSubFormsEnd->pcNext=pcNewSubForm;
progress.c:	  pcNewSubFormsEnd->pcNext=NULL;
progress.c:      pcSubForm=pcSubForm->pcNext;
progress.c:	pcNewSubForm=(*pcSubForm->pfForm->paAction->pfProgress)(pcSubForm,plpLinearPlan,pbBindings,&immutable);
progress.c:  else if(!pcNewSubForms->pcNext) {
progress.c:        Progress an or-formula checking for true/false and compressing same
progress.c:(define (progress-or form world/action bindings)
progress.c:  (let ((new-subforms '())
progress.c:                (new-subform '())
progress.c:                (make-new '())
progress.c:        (do ((subforms (get-args form))
progress.c:          (set! new-subform (progress-formula subform world/action bindings))
progress.c:          (cond ((eq? #t new-subform)
progress.c:                         (set! new-subforms '())
progress.c:                        ((not new-subform)
progress.c:                         (set! make-new #t))
progress.c:                        ((eq? new-subform subform)
progress.c:                         (set! new-subforms (cons subform new-subforms)))
progress.c:                        ((or-formp new-subform)
progress.c:                         (set! make-new #t)
progress.c:                        (set! new-subforms (append (get-args new-subform) new-subforms)))
progress.c:                         (set! make-new #t)
progress.c:                         (set! new-subforms (cons new-subform new-subforms)))))
progress.c:          ((null? new-subforms) #f)
progress.c:          ((not make-new) form)
progress.c:          ((length=1 new-subforms) (first new-subforms))
progress.c:          (else (make-or-form new-subforms)))))
progress.c:	for(pcSubForm=pcFormula->pfForm->pcArgs;pcSubForm;pcSubForm=pcSubForm->pcNext)
progress.c:		pcNewSubForm=(*pcSubForm->pfForm->paAction->pfProgress)
progress.c:		if(pcNewSubForm->pfForm!=pcSubForm->pfForm)
progress.c:  if(pcSubForm!=pcFormula->pfForm->pcArgs)
progress.c:    pcNewSubForms=CopyPrefixCellList(pcFormula->pfForm->pcArgs,pcSubForm,&pcNewSubFormsEnd);
progress.c:      //  pcNewSubFormsEnd->pcNext=CopyCellListReturnEndCell(pcNewSubForm->pfForm->pcArgs,&pcTemp);
progress.c:	  pcNewSubFormsEnd=pcNewSubFormsEnd->pcNext=pcNewSubForm;
progress.c:	  pcNewSubFormsEnd->pcNext=NULL;
progress.c:      pcSubForm=pcSubForm->pcNext;
progress.c:	pcNewSubForm=(*pcSubForm->pfForm->paAction->pfProgress)(pcSubForm,plpLinearPlan,pbBindings,&immutable);
progress.c:  else if(!pcNewSubForms->pcNext) {
progress.c:(define (progress-xor form world/action bindings)
progress.c:        (let ((new-subforms '())
progress.c:                        (new-subform '())
progress.c:                        (make-new '())
progress.c:                        (found-one? '())
progress.c:                (do ((subforms (get-args form))
progress.c:                        (set! new-subform (progress-formula subform world/action bindings))
progress.c:                                ((and (eq? #t new-subform) found-one?)
progress.c:                                        (set! new-subforms '())
progress.c:                                ((eq? #t new-subform)
progress.c:                                        (set! found-one? #t))
progress.c:                                ((not new-subform)
progress.c:                                        (set! make-new #t))
progress.c:                                ((eq? new-subform subform)
progress.c:                                        (set! new-subforms (cons subform new-subforms)))
progress.c:                                ((xor-formp new-subform)
progress.c:                                        (set! make-new #t)
progress.c:                                        (set! new-subforms (append (get-args new-subform) new-subforms)))
progress.c:                                        (set! make-new #t)
progress.c:                                        (set! new-subforms (cons new-subform new-subforms)))))
progress.c:                        ((or (and (null? new-subforms) (not found-one?)) false?)
progress.c:                        ((and (null? new-subforms) found-one?)
progress.c:                        ((and found-one? (length=1 new-subforms))
progress.c:                                (make-not-form new-subforms))
progress.c:                        (found-one?
progress.c:                                (make-not-form (make-or-form new-subforms)))
progress.c:                        ((not make-new)
progress.c:                        ((length=1 new-subforms)
progress.c:                                (first new-subforms))
progress.c:                                (make-xor-form new-subforms)))))
progress.c:	for(pcSubForm=pcFormula->pfForm->pcArgs;pcSubForm;pcSubForm=pcSubForm->pcNext)
progress.c:		pcNewSubForm=(*pcSubForm->pfForm->paAction->pfProgress)
progress.c:		if(pcNewSubForm->pfForm!=pcSubForm->pfForm)
progress.c:  if(pcSubForm!=pcFormula->pfForm->pcArgs)
progress.c:    pcNewSubForms=CopyPrefixCellList(pcFormula->pfForm->pcArgs,pcSubForm,&pcNewSubFormsEnd);
progress.c:      //  pcNewSubFormsEnd->pcNext=CopyCellListReturnEndCell(pcNewSubForm->pfForm->pcArgs,&pcTemp);
progress.c:	  pcNewSubFormsEnd=pcNewSubFormsEnd->pcNext=pcNewSubForm;
progress.c:	  pcNewSubFormsEnd->pcNext=NULL;
progress.c:      else if(!pcNewSubForms->pcNext) {
progress.c:  else if(!pcNewSubForms->pcNext) {
progress.c:(define (progress-implies form world/action bindings)
progress.c:                        (subforms (get-args form))
progress.c:                        (new-arg1 (progress-formula (first subforms) world/action bindings)))
progress.c:                (if (not new-arg1)
progress.c:                                        (new-arg2 (progress-formula (second subforms) world/action bindings)))
progress.c:                                        ((eq? #t new-arg2)
progress.c:                                        ((eq? #t new-arg1)
progress.c:                                                new-arg2)
progress.c:                                        ((not new-arg2)
progress.c:                                                (make-not-form new-arg1))
progress.c:                                        ((and (eq? new-arg1 (first subforms))
progress.c:                                                (eq? new-arg2 (second subforms)))
progress.c:                                                (make-implies-form new-arg1 new-arg2)))))))
progress.c:  pcArg1=pcFormula->pfForm->pcArgs;
progress.c:  pcArg2=pcArg1->pcNext;
progress.c:  pcNewArg1=(*pcArg1->pfForm->paAction->pfProgress)(pcArg1,plpLinearPlan,pbBindings,&immutable1);
progress.c:    pcNewArg2=(*pcArg2->pfForm->paAction->pfProgress)(pcArg2,plpLinearPlan,pbBindings,&immutable2);
progress.c:      pc=MakeNotForm(FALSE,(pcNewArg1->pcNext&&immutable1)?CopyCell(pcNewArg1):pcNewArg1);
progress.c:    else if(pcNewArg1->pfForm==pcArg1->pfForm&&pcNewArg2->pfForm==pcArg2->pfForm) {
progress.c:			 (pcNewArg2->pcNext&&immutable2)?CopyCell(pcNewArg2):pcNewArg2);
progress.c:        p(if-then-else a t f) => (if-then-else p(a) p(t) p(f))
progress.c:(define (progress-if-then-else form world/action bindings)
progress.c:                        (subforms (get-args form))
progress.c:                        (new-arg1 (progress-formula arg1 world/action bindings))
progress.c:                        (new-arg2 #f)
progress.c:                        (new-arg3 #f))
progress.c:                        ((eq? new-arg1 #t)
progress.c:                                (progress-formula arg2 world/action bindings))
progress.c:                        ((not new-arg1)
progress.c:                                (progress-formula arg3 world/action bindings))
progress.c:                                (set! new-arg2 (progress-formula arg2 world/action bindings))
progress.c:                                (set! new-arg3 (progress-formula arg3 world/action bindings))
progress.c:                                        ((eq? new-arg2 #t)
progress.c:                                                (if (eq? new-arg3 #t)
progress.c:                                                        (if (not new-arg3)
progress.c:                                                                new-arg1
progress.c:                                                                (make-implies-form (make-not-form new-arg1) new-arg3))))
progress.c:                                        ((not new-arg2)
progress.c:                                                (if (eq? new-arg3 #t)
progress.c:                                                        (make-not-form new-arg1)
progress.c:                                                        (if (not new-arg3)
progress.c:                                                                (make-and-form (list (make-not-form new-arg1) new-arg3)))))
progress.c:                                                (if (eq? new-arg3 #t)
progress.c:                                                        (make-implies-form new-arg1 new-arg2)
progress.c:                                                        (if (not new-arg3)
progress.c:                                                                (make-and-form (list new-arg1 new-arg2))
progress.c:                                                                (if (and (eq? new-arg1 arg1)
progress.c:                                                                                (eq? new-arg2 arg2)
progress.c:                                                                                (eq? new-arg3 arg3))
progress.c:                                                                        (make-if-then-else-form
progress.c:                                                                                new-arg1 new-arg2 new-arg3))))))))))
progress.c:  pcArg1=pcFormula->pfForm->pcArgs;
progress.c:  pcArg2=pcArg1->pcNext;
progress.c:  pcArg3=pcArg2->pcNext;
progress.c:  pcNewArg1=(*pcArg1->pfForm->paAction->pfProgress)(pcArg1,plpLinearPlan,pbBindings,&immutable1);
progress.c:    pc=(*pcArg2->pfForm->paAction->pfProgress)(pcArg2,plpLinearPlan,pbBindings,&immutable2);
progress.c:    pc=(*pcArg3->pfForm->paAction->pfProgress)(pcArg3,plpLinearPlan,pbBindings,&immutable3);
progress.c:  pcNewArg2=(*pcArg2->pfForm->paAction->pfProgress)(pcArg2,plpLinearPlan,pbBindings,&immutable2);
progress.c:  pcNewArg3=(*pcArg3->pfForm->paAction->pfProgress)(pcArg3,plpLinearPlan,pbBindings,&immutable3);
progress.c:      pc=MakeImpliesForm(FALSE,MakeNotForm(FALSE,(pcNewArg1->pcNext&&immutable1)
progress.c:			 (pcNewArg3->pcNext&&immutable3)?CopyCell(pcNewArg3):pcNewArg3);
progress.c:      pc=MakeNotForm(FALSE,(pcNewArg1->pcNext&&immutable1)?CopyCell(pcNewArg1):pcNewArg1);
progress.c:      pc=MakeNotForm(FALSE,(pcNewArg1->pcNext&&immutable1)?CopyCell(pcNewArg1):pcNewArg1);
progress.c:      pc->pcNext=(pcNewArg3->pcNext&&immutable3)?CopyCell(pcNewArg3):pcNewArg3;
progress.c:		       (pcNewArg2->pcNext&&immutable2)?CopyCell(pcNewArg2):pcNewArg2);
progress.c:    pcNewArg1->pcNext=(pcNewArg2->pcNext&&immutable2)?CopyCell(pcNewArg2):pcNewArg2;
progress.c:  else if(pcNewArg1->pfForm==pcArg1->pfForm&&pcNewArg2->pfForm==pcArg2->pfForm&&pcNewArg3->pfForm==pcArg3->pfForm)
progress.c:			  (pcNewArg3->pcNext&&immutable3)?CopyCell(pcNewArg3):pcNewArg3);
progress.c:/* Quantified Formulas --------------------------------------------------------- */
progress.c:(define (progress-forall form world/action bindings)
progress.c:                        (args (get-args form))
progress.c:                        (qf-vars (get-qf-variables args))
progress.c:                        (gen-lit (get-qf-generator args))
progress.c:                        (qf-form (get-qf-formula args))
progress.c:                        (progressed-form #f)
progress.c:                        (new-subforms '()))
progress.c:                (set! bindings (extend-bindings qf-vars qf-vars bindings))
progress.c:                (set! generator (make-generator gen-lit qf-vars world/action bindings))
progress.c:                                                (set! progressed-form
progress.c:                                                        (progress-formula qf-form world/action bindings))
progress.c:                                                        ((eq? progressed-form #t))
progress.c:                                                        ((not progressed-form)
progress.c:                                                                (set! new-subforms '()))
progress.c:                                                                (set! new-subforms
progress.c:                                                                                (make-binding-form
progress.c:                                                                                        qf-vars (eval-terms qf-vars
progress.c:                                                                                        progressed-form)
progress.c:                                                                                new-subforms)))))
progress.c:                        ((null? new-subforms)
progress.c:                        ((length=1 new-subforms)
progress.c:                                (first new-subforms))
progress.c:                                (make-and-form new-subforms)))))
progress.c:	pcVars=pcFormula->pfForm->pcVars;
progress.c:	pcGenLit=pcFormula->pfForm->pcGenLit;
progress.c:	pcArgs=pcFormula->pfForm->pcArgs;
progress.c:	while((*pcGenLit->pfForm->paAction->pfGenerator)
progress.c://		(pcGenLit,&(pbBindings->pvContext),pcVars,plpLinearPlan,pbBindings))
progress.c:		pcNewForm=(*pcArgs->pfForm->paAction->pfProgress)(pcArgs,plpLinearPlan,pbBindings,&immutable);
progress.c:	else if(!pcNewSubForms->pcNext) {
progress.c:        Add a formula to a list of "in-the-set" quantifiers,
progress.c:		TermError("add-instance",pcNewForm);
progress.c:		(pcNewForm->pcNext&&immutable)?CopyCell(pcNewForm):pcNewForm);
progress.c:	pc->pcNext=*ppcNewSubForms;
progress.c:		TermError("add-instance",pcNewForm,pbBindings);
progress.c:	for(pc=*ppcNewSubForms;pc;pc=pc->pcNext)
progress.c:		if(FormulaEqQ(pcNewForm,pc->pfForm->pcArgs))
progress.c:		for(pc=pc->pfForm->pcGenLit->pfForm->pcArgs;pc->pcNext;pc=pc->pcNext);
progress.c:		pc->pcNext=pcTerms;
progress.c:		pc=(*pfMake)(FALSE,pcVars,pcGenLit,(pcNewForm->pcNext&&immutable)?CopyCell(pcNewForm):pcNewForm);
progress.c:		pc->pcNext=*ppcNewSubForms;
progress.c:(define (progress-exists form world/action bindings)
progress.c:                        (args (get-args form))
progress.c:                        (qf-vars (get-qf-variables args))
progress.c:                        (gen-lit (get-qf-generator args))
progress.c:                        (qf-form (get-qf-formula args))
progress.c:                        (progressed-form #f)
progress.c:                        (new-subforms '()))
progress.c:                (set! bindings (extend-bindings qf-vars qf-vars bindings))
progress.c:                (set! generator (make-generator gen-lit qf-vars world/action bindings))
progress.c:                                                (set! progressed-form
progress.c:                                                        (if (not qf-form)
progress.c:                                                                (progress-formula qf-form world/action bindings)))
progress.c:                                                        ((eq? progressed-form #t)
progress.c:                                                                (set! new-subforms '()))
progress.c:                                                        ((not progressed-form))
progress.c:                                                                (set! new-subforms
progress.c:                                                                                (make-binding-form
progress.c:                                                                                        qf-vars (eval-terms qf-vars
progress.c:                                                                                        progressed-form)
progress.c:                                                                                new-subforms)))))
progress.c:                        ((null? new-subforms)
progress.c:                        ((length=1 new-subforms)
progress.c:                                (first new-subforms))
progress.c:                                (make-or-form new-subforms)))))
progress.c:	pcVars=pcFormula->pfForm->pcVars;
progress.c:	pcGenLit=pcFormula->pfForm->pcGenLit;
progress.c:	pcArgs=pcFormula->pfForm->pcArgs;
progress.c:	while((*pcGenLit->pfForm->paAction->pfGenerator)
progress.c://		(pcGenLit,&(pbBindings->pvContext),pcVars,plpLinearPlan,pbBindings))
progress.c:			pcNewForm=(*pcArgs->pfForm->paAction->pfProgress)
progress.c:	else if(!pcNewSubForms->pcNext) {
progress.c:(define (progress-exists! form world/action bindings)
progress.c:                        (args (get-args form))
progress.c:                        (qf-vars (get-qf-variables args))
progress.c:                        (gen-lit   (get-qf-generator args))
progress.c:                        (qf-form   (get-qf-formula args))
progress.c:                        (progressed-form #f)
progress.c:                        (new-subforms '())
progress.c:                        (found-one? #f))
progress.c:                (set! bindings (extend-bindings qf-vars qf-vars bindings))
progress.c:                (set! generator (make-generator gen-lit qf-vars world/action bindings))
progress.c:                                                (set! progressed-form
progress.c:                                                        (if (not qf-form)
progress.c:                                                                (progress-formula qf-form world/action bindings)))
progress.c:                                                        ((and (eq? progressed-form #t) found-one?)
progress.c:                                                                (set! new-subforms '()))
progress.c:                                                        ((eq? progressed-form #t)
progress.c:                                                                (set! found-one? #t))
progress.c:                                                        ((not progressed-form))
progress.c:                                                                (set! new-subforms
progress.c:                                                                        (cons (make-binding-form
progress.c:                                                                                        qf-vars (eval-terms qf-vars
progress.c:                                                                                        progressed-form)
progress.c:                                                                                new-subforms)))))
progress.c:                        ((null? new-subforms)
progress.c:                                (if found-one?
progress.c:                        ((and found-one? (length=1 new-subforms))
progress.c:                                (make-not-form new-subforms))
progress.c:                        (found-one?
progress.c:                                (make-not-form (make-or-form new-subforms)))
progress.c:                        ((length=1 new-subforms)
progress.c:                                (first new-subforms))
progress.c:                                (make-xor-form new-subforms)))))
progress.c:	pcVars=pcFormula->pfForm->pcVars;
progress.c:	pcGenLit=pcFormula->pfForm->pcGenLit;
progress.c:	while((*pcGenLit->pfForm->paAction->pfGenerator)
progress.c://		(pcGenLit,&(pbBindings->pvContext),pcVars,plpLinearPlan,pbBindings))
progress.c:		if(!pcFormula->pfForm->pcArgs)
progress.c:			pcNewForm=(*pcFormula->pfForm->pcArgs->pfForm->paAction->pfProgress)
progress.c:			(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings,&immutable);
progress.c:		if(!pcNewSubForms->pcNext) {
progress.c:	else if(!pcNewSubForms->pcNext) {
progress.c:/* Temporal Formulas ----------------------------------------------------------- */
progress.c:(define (progress-always form world/action bindings)
progress.c:                        (progressed-form
progress.c:                                (progress-formula (first (get-args form)) world/action bindings)))
progress.c:                        ((eq? progressed-form #t)
progress.c:                        ((not progressed-form)
progress.c:                        ((and-formp progressed-form)
progress.c:                                (make-and-form (append (get-args progressed-form) (list form))))
progress.c:                                (make-and-form (list progressed-form form))))))
progress.c:  pcArg1=pcFormula->pfForm->pcArgs;
progress.c:  pcNewArg1=(*pcArg1->pfForm->paAction->pfProgress)(pcArg1,plpLinearPlan,pbBindings,&immutable);
progress.c:    pc=MakeAndForm(FALSE,AppendFormula(TRUE,pcNewArg1->pfForm->pcArgs,
progress.c:		pcFormula->pcNext?CopyCell(pcFormula):pcFormula));
progress.c:    pcNewArg1->pcNext=pcFormula->pcNext?CopyCell(pcFormula):pcFormula;
progress.c:    //pcNewArg1->pcNext=pcFormula;
progress.c:(define (progress-eventually form world/action bindings)
progress.c:                        (progressed-form
progress.c:                                (progress-formula (first (get-args form)) world/action bindings)))
progress.c:                        ((not progressed-form)
progress.c:                        ((eq? progressed-form #t)
progress.c:                        ((or-formp progressed-form)
progress.c:                                (make-or-form (append (get-args progressed-form) (list form))))
progress.c:                                (make-or-form (list progressed-form form))))))
progress.c:  pcArg1=pcFormula->pfForm->pcArgs;
progress.c:  pcNewArg1=(*pcArg1->pfForm->paAction->pfProgress)(pcArg1,plpLinearPlan,pbBindings,&immutable);
progress.c:    pc=MakeOrForm(FALSE,AppendFormula(TRUE,pcNewArg1->pfForm->pcArgs,
progress.c:		pcFormula->pcNext?CopyCell(pcFormula):pcFormula));
progress.c:    pcNewArg1->pcNext=pcFormula->pcNext?CopyCell(pcFormula):pcFormula;
progress.c:(define (progress-next form world/action bindings)
progress.c:  (first (get-args form)))
progress.c:  pc=pcFormula->pfForm->pcArgs;
progress.c:(define (progress-until form world/action bindings)
progress.c:                        (progressed-achievement
progress.c:                                (progress-formula (second (get-args form)) world/action bindings)))
progress.c:                (if (eq? progressed-achievement #t)
progress.c:                                        (progressed-condition
progress.c:                                                (progress-formula (first (get-args form)) world/action bindings)))
progress.c:                                (set! progressed-condition
progress.c:                                                ((not progressed-condition)
progress.c:                                                ((eq? progressed-condition #t)
progress.c:                                                ((and-formp progressed-condition)
progress.c:                                                        (make-and-form
progress.c:                                                                (append (get-args progressed-condition) (list form))))
progress.c:                                                        (make-and-form (list progressed-condition form)))))
progress.c:                                        ((not progressed-achievement)
progress.c:                                                progressed-condition)
progress.c:                                        ((not progressed-condition)
progress.c:                                                progressed-achievement)
progress.c:                                        ((or-formp progressed-achievement)
progress.c:                                                (make-or-form (cons progressed-condition
progress.c:                                                                (get-args progressed-achievement))))
progress.c:                                                (make-or-form (list progressed-achievement
progress.c:                                                                progressed-condition))))))))
progress.c:  pcCondition=pcFormula->pfForm->pcArgs;
progress.c:  pcAchievement=pcCondition->pcNext;
progress.c:  pcNewAchievement=(*pcAchievement->pfForm->paAction->pfProgress)(pcAchievement,plpLinearPlan,pbBindings,&immutableA);
progress.c:  pcNewCondition=(*pcCondition->pfForm->paAction->pfProgress)(pcCondition,plpLinearPlan,pbBindings,&immutableC);
progress.c:    pcNewCondition=MakeAndForm(FALSE,AppendFormula(TRUE,pcNewCondition->pfForm->pcArgs,
progress.c:		pcFormula->pcNext?CopyCell(pcFormula):pcFormula));
progress.c:    pcNewCondition->pcNext=pcFormula->pcNext?CopyCell(pcFormula):pcFormula;
progress.c:    pcNewCondition->pcNext=pcNewAchievement->pfForm->pcArgs;
progress.c:    pcNewAchievement->pcNext=pcNewCondition;
progress.c:/* MTL Timed Temporal Formulas ------------------------------------------------- */
progress.c:(define (progress-t-always form world/action bindings)
progress.c:                        (ispec (get-bf-ispec form))
progress.c:                        (forms (get-bf-formulas form))
progress.c:                        (shifted-form (make-delta-form form)))
progress.c:                                                (progressed-form
progress.c:                                                        (progress-formula (first forms) world/action bindings)))
progress.c:                                                ((eq? progressed-form #t)
progress.c:                                                        shifted-form)
progress.c:                                                ((not progressed-form)
progress.c:                                                ((and-formp progressed-form)
progress.c:                                                        (make-and-form (append (get-args progressed-form)
progress.c:                                                                        (list shifted-form))))
progress.c:                                                        (make-and-form (list progressed-form shifted-form))))))
progress.c:                                shifted-form))))
progress.c:  pisISpec=GetBFISpec(pcFormula)->pfForm->uValue.piISpec;
progress.c:  pcShiftedForm=MakeDeltaForm(FALSE,pcFormula->pcNext?CopyCell(pcFormula):pcFormula);
progress.c:      pcNewForm=(*pcForm->pfForm->paAction->pfProgress)(pcForm,plpLinearPlan,pbBindings,&immutable);
progress.c:	pc=MakeAndForm(FALSE,AppendFormula(TRUE,pcNewForm->pfForm->pcArgs,pcShiftedForm));
progress.c:	  pcNewForm->pcNext=pcShiftedForm;
progress.c:(define (progress-delta form world/action bindings)
progress.c:                        (formula (get-delta-formula form))
progress.c:                        (ispec (get-bf-ispec formula))
progress.c:                        (shifted-form
progress.c:                                                (get-operator formula)
progress.c:                                                (ispec-lshift ispec (world/action-action-duration world/action)))
progress.c:                                        (get-bf-formulas formula))))
progress.c:                (progress-formula shifted-form world/action bindings)))
progress.c:  //pcShiftedForm=CopyCell(pcFormula->pfForm->pcArgs);
progress.c:  pcShiftedForm=pcFormula->pfForm->pcArgs;
progress.c:  pcShiftedForm->pfForm=CopyAlloc(pcShiftedForm->pfForm,sizeof(FORMULA));
progress.c:  pcISpec=pcShiftedForm->pfForm->pcArgs;
progress.c:  pcTail=pcISpec->pcNext;
progress.c:  pcISpec->pcNext=pcTail;
progress.c:  pcShiftedForm->pfForm->pcArgs=pcISpec;
progress.c:  pc=(*pcShiftedForm->pfForm->paAction->pfProgress)(pcShiftedForm,plpLinearPlan,pbBindings,&immutable);
progress.c:(define (progress-t-eventually form world/action bindings)
progress.c:                        (ispec (get-bf-ispec form))
progress.c:                        (forms (get-bf-formulas form))
progress.c:                        (shifted-form (make-delta-form form)))
progress.c:                                                (progressed-form
progress.c:                                                        (progress-formula (first forms) world/action bindings)))
progress.c:                                                ((not progressed-form)
progress.c:                                                        shifted-form)
progress.c:                                                ((eq? progressed-form #t)
progress.c:                                                ((or-formp progressed-form)
progress.c:                                                        (make-or-form (append (get-args progressed-form)
progress.c:                                                                        (list shifted-form))))
progress.c:                                                        (make-or-form (list progressed-form shifted-form))))))
progress.c:                                shifted-form))))
progress.c:  pisISpec=GetBFISpec(pcFormula)->pfForm->uValue.piISpec;
progress.c:	  pcNewForm=(*pcForm->pfForm->paAction->pfProgress)(pcForm,plpLinearPlan,pbBindings,&immutable);
progress.c:	      pcShiftedForm=MakeDeltaForm(FALSE,pcFormula->pcNext?CopyCell(pcFormula):pcFormula);
progress.c:		pc=MakeOrForm(FALSE,AppendFormula(TRUE,pcNewForm->pfForm->pcArgs,pcShiftedForm));
progress.c:		  pcNewForm->pcNext=pcShiftedForm;
progress.c:	pc=MakeDeltaForm(FALSE,pcFormula->pcNext?CopyCell(pcFormula):pcFormula);       /* same as pcShiftedForm */
progress.c:(define (progress-t-until form world/action bindings)
progress.c:                        (ispec (get-bf-ispec form))
progress.c:                        (forms (get-bf-formulas form))
progress.c:                        (shifted-form (make-delta-form form)))
progress.c:                                                (progressed-achievement
progress.c:                                                        (progress-formula (second forms) world/action bindings)))
progress.c:                                        (if (eq? progressed-achievement #t)
progress.c:                                                                (progressed-condition
progress.c:                                                                        (progress-formula (first forms) world/action bindings)))
progress.c:                                                        (set! progressed-condition
progress.c:                                                                        ((not progressed-condition)
progress.c:                                                                        ((eq? progressed-condition #t)
progress.c:                                                                                shifted-form)
progress.c:                                                                        ((and-formp progressed-condition)
progress.c:                                                                                (make-and-form
progress.c:                                                                                        (append (get-args progressed-condition)
progress.c:                                                                                                (list shifted-form))))
progress.c:                                                                                (make-and-form
progress.c:                                                                                        (list progressed-condition shifted-form)))))
progress.c:                                                                ((not progressed-achievement)
progress.c:                                                                        progressed-condition)
progress.c:                                                                ((not progressed-condition)
progress.c:                                                                        progressed-achievement)
progress.c:                                                                ((or-formp progressed-achievement)
progress.c:                                                                        (make-or-form
progress.c:                                                                                (cons progressed-condition
progress.c:                                                                                        (get-args progressed-achievement))))
progress.c:                                                                        (make-or-form (list progressed-achievement
progress.c:                                                                                        progressed-condition))))))))
progress.c:                                                (progressed-condition
progress.c:                                                        (progress-formula (first forms) world/action bindings)))
progress.c:                                        (set! progressed-condition
progress.c:                                                        ((not progressed-condition)
progress.c:                                                        ((eq? progressed-condition #t)
progress.c:                                                                shifted-form)
progress.c:                                                        ((and-formp progressed-condition)
progress.c:                                                                (make-and-form
progress.c:                                                                        (append (get-args progressed-condition)
progress.c:                                                                                (list shifted-form))))
progress.c:                                                                (make-and-form
progress.c:                                                                        (list progressed-condition shifted-form))))))))))
progress.c:  piISpec=GetBFISpec(pcFormula)->pfForm->uValue.piISpec;
progress.c:  pcShiftedForm=MakeDeltaForm(FALSE,pcFormula->pcNext?CopyCell(pcFormula):pcFormula);
progress.c:      pcNewAchievement=(*pcForm->pcNext->pfForm->paAction->pfProgress)(pcForm->pcNext,plpLinearPlan,pbBindings,&immutableA);
progress.c:      pcNewCondition=(*pcForm->pfForm->paAction->pfProgress)(pcForm,plpLinearPlan,pbBindings,&immutableC);
progress.c:	pcNewCondition=MakeAndForm(FALSE,AppendFormula(TRUE,pcNewCondition->pfForm->pcArgs,
progress.c:	  pcNewCondition->pcNext=pcShiftedForm;
progress.c:	  pcNewCondition->pcNext=pcNewAchievement->pfForm->pcArgs;
progress.c:	  pcNewAchievement->pcNext=pcNewCondition;
progress.c:  pcNewCondition=(*pcForm->pfForm->paAction->pfProgress)(pcForm,plpLinearPlan,pbBindings,&immutableC);
progress.c:    pc=MakeAndForm(FALSE,AppendFormula(TRUE,pcNewCondition->pfForm->pcArgs,pcShiftedForm));
progress.c:      pcNewCondition->pcNext=pcShiftedForm;
progress.c:/* Auxiliary Formulas ---------------------------------------------------------- */
progress.c:(define (progress-binding form world/action bindings)
progress.c:                        (progressed-form #f))
progress.c:                (set! progressed-form
progress.c:                        (progress-formula
progress.c:                                (get-binding-formula form) world/action
progress.c:                                (extend-bindings (get-binding-vars form)
progress.c:                                (get-binding-vals form) bindings)))
progress.c:                        ((or (eq? progressed-form #t) (not progressed-form))
progress.c:                                progressed-form)
progress.c:                        ((eq? progressed-form (get-binding-formula form))
progress.c:                                (make-binding-form (get-binding-vars form)
progress.c:                                        (get-binding-vals form) progressed-form)))))
progress.c:	pcProgressedForm=(*GetBindingFormula(pcFormula)->pfForm->paAction->pfProgress)
progress.c:			(pcProgressedForm->pcNext&&immutable)?CopyCell(pcProgressedForm):pcProgressedForm);
progress.c:/* Modalities ----------------------------------------------------------------- */
progress.c:(define (progress-goal form world/action bindings)
progress.c:  (eval-formula (first (get-args form)) (get-goal-world) bindings))
progress.c:  pc=pcFormula->pfForm->pcArgs;
progress.c:  if((*pc->pfForm->paAction->pfEval)(pc,GetGoalWorld(TRUE),pbBindings))
progress.c:(define (progress-goal form world/action bindings)
progress.c:  (eval-formula (first (get-args form)) (get-goal-world) bindings))
progress.c:  pc=pcFormula->pfForm->pcArgs;
progress.c:  if((*pc->pfForm->paAction->pfEval)(pc,plpCurrentPlan,pbBindings))
progress.c:    plp=plp->plpParent;
progress.c:  pc=pcFormula->pfForm->pcArgs;
progress.c:  if(plp&&(*pc->pfForm->paAction->pfEval)(pc,plp,pbBindings))
progress.c:  if((*pcFormula->pfForm->paAction->pfEval)(pcFormula,plpLinearPlan,pbBindings))
queue.c://static double dfQueueTime;			/* the time of the most recently dequeued delayed-action */
queue.c:/* ClearQueue ------------------------------------------------------------------
queue.c:	(global-delayed-action delta tag formula)
queue.c:		ErrorMessage("global-delayed-action:  Call (enable concurrent-planning) first.\n");
queue.c:	pcArg=pcFormula->pfForm->pcArgs;
queue.c:		TermError("global-delayed-action",pcFormula,pbBindings);
queue.c:		Message("global-delayed-action:  Warning, delta time is non-positive.\n");
queue.c:	pcArg=pcArg->pcNext;
queue.c:		TermError("global-delayed-action",pcFormula,pbBindings);
queue.c:	pcArg=pcArg->pcNext;
queue.c:		TermError("global-delayed-action",pcFormula,pbBindings);
queue.c:	ptq->dfTime=plpLinearPlan->dfTime+dfDelta;
queue.c:	ptq->pcTag=pcTag;
queue.c:	ptq->pcFormula=pcForm;
queue.c:	ptq->pbBindings=CopyBindings(pbBindings);
queue.c:	ptq->plpProgenitor=NULL;
queue.c://	CommandPrintf(pfTraceStream,"Delayed-action world %04d time %f\n",
queue.c://		ptq->plpProgenitor->nWorldNumber,ptq->dfTime);
queue.c:	for(ptq1=tqHead.ptqNext;ptq1!=&tqHead;ptq1=ptq1->ptqNext)
queue.c:		if(ptq1->dfTime>ptq->dfTime)
queue.c:	ptq->ptqNext=ptq1;
queue.c:	ptq->ptqPrev=ptq1->ptqPrev;
queue.c:	ptq1->ptqPrev=ptq;
queue.c:	ptq->ptqPrev->ptqNext=ptq;
queue.c:	(delayed-action delta tag formula)
queue.c:		ErrorMessage("delayed-action:  Call (enable concurrent-planning) first.\n");
queue.c://dfDelayedActionTime-=GetInternalRunTime();
queue.c:	pcArg=pcFormula->pfForm->pcArgs;
queue.c:		TermError("delayed-action",pcFormula,pbBindings);
queue.c:			Message("delayed-action:  Warning, delta time is negative.\n");
queue.c:			Message("delayed-action:  Warning, delta time is non-positive.\n");
queue.c:	pcArg=pcArg->pcNext;
queue.c:		TermError("delayed-action",pcFormula,pbBindings);
queue.c:	pcArg=pcArg->pcNext;
queue.c:		TermError("delayed-action",pcFormula,pbBindings);
queue.c:		ptq->dfTime=plpSuccessorWorld->dfTime+dfDelta+1.0e-3;
queue.c:		ptq->dfTime=plpSuccessorWorld->dfTime+dfDelta;
queue.c:	ptq->pcTag=pcTag;
queue.c:	ptq->pcFormula=pcForm;
queue.c:	ptq->pbBindings=CopyBindings(pbBindings);
queue.c:	ptq->plpProgenitor=plpSuccessorWorld;
queue.c:	plpSuccessorWorld->dfDuration=dfDelta;
queue.c:	for(ptq1=tqHead.ptqNext;ptq1!=&tqHead;ptq1=ptq1->ptqNext)
queue.c:		if(ptq1->dfTime>ptq->dfTime)
queue.c:	ptq->ptqNext=ptq1;
queue.c:	ptq->ptqPrev=ptq1->ptqPrev;
queue.c:	ptq1->ptqPrev=ptq;
queue.c:	ptq->ptqPrev->ptqNext=ptq;
queue.c:	(inhibit-delayed-action delta tag)
queue.c:	CELLP pcFormula,					// inhibit-delayed-action formula
queue.c:		ErrorMessage("delayed-action:  Call (enable concurrent-planning) first.\n");
queue.c:	pcArg=pcFormula->pfForm->pcArgs;
queue.c:		TermError("delayed-action",pcFormula,pbBindings);
queue.c:		Message("inhibit-delayed-action:  Warning, delta time is non-positive.\n");
queue.c:	pcArg=pcArg->pcNext;
queue.c:		TermError("inhibit-delayed-action",pcFormula,pbBindings);
queue.c://	ptq->dfTime=plpLinearPlan->dfDuration+dfDelta;
queue.c:	ptq->dfTime=plpSuccessorWorld->dfTime+dfDelta;
queue.c:	ptq->pcTag=pcTag;
queue.c:	ptq->pcFormula=pcForm;
queue.c:	ptq->pbBindings=CopyBindings(pbBindings);
queue.c://	ptq->plpProgenitor=plpLinearPlan;
queue.c:	ptq->plpProgenitor=plpSuccessorWorld;
queue.c://	if(plpSuccessorWorld->nWorldNumber==43)
queue.c://	CommandPrintf(pfTraceStream,"inibit-delayed-action world %04d time %f\n",
queue.c://		ptq->plpProgenitor->nWorldNumber,ptq->dfTime);
queue.c:	for(ptq1=tqHead.ptqNext;ptq1!=&tqHead;ptq1=ptq1->ptqNext)
queue.c:		if(ptq1->dfTime>ptq->dfTime)
queue.c:	ptq->ptqNext=ptq1;
queue.c:	ptq->ptqPrev=ptq1->ptqPrev;
queue.c:	ptq1->ptqPrev=ptq;
queue.c:	ptq->ptqPrev->ptqNext=ptq;
queue.c:	(wait-for-next-event)
queue.c://	for(ptq1=tqHead.ptqNext;ptq1!=&tqHead;ptq1=ptq1->ptqNext)
queue.c://		if(ptq1->dfTime>plpLinearPlan->dfTime)
queue.c://			for(plp=plpLinearPlan;plp;plp=plp->plpParent)
queue.c://				if(plp==ptq1->plpProgenitor||!ptq1->plpProgenitor)
queue.c://	dfQueueTime=ptq1->dfTime;
queue.c://	plpSuccessorWorld->dfTime=dfQueueTime;
queue.c://	pcTag=(CELLP)&plpSuccessorWorld->pcActionName->pfForm->pcArgs;
queue.c://	for(;ptq1!=&tqHead;ptq1=ptq1->ptqNext)
queue.c://		if(ptq1->dfTime!=dfQueueTime)
queue.c://		for(plp=plpLinearPlan;plp;plp=plp->plpParent)
queue.c://			if(plp==ptq1->plpProgenitor||!ptq1->plpProgenitor)
queue.c://				(*ptq1->pcFormula->pfForm->paAction->pfEval)
queue.c://					(ptq1->pcFormula,plpLinearPlan,ptq1->pbBindings);
queue.c://				// append this delayed-action to the action tag
queue.c://				pcTag=pcTag->pcNext=CopyFormula(ptq1->pcTag);	// this is rather inefficient!
queue.c://				if(pcTag->pfForm->pcArgs)
queue.c://					pcTag->pfForm->pcArgs=ComputeTerms(pcTag->pfForm->pcArgs,plpLinearPlan,ptq1->pbBindings);
queue.c://					if(!pcTag->pfForm->pcArgs)
queue.c://						TermError("eval-wait-for-next-event",pcFormula,pbBindings);
queue.c:		ErrorMessage("wait-for-next-event:  Call (enable concurrent-planning) first.\n");
queue.c://dfWaitEventTime-=GetInternalRunTime();
queue.c:	for(ptq1=tqHead.ptqNext;ptq1!=&tqHead;ptq1=ptq1->ptqNext)
queue.c:		for(;ptq1!=&tqHead;ptq1=ptq1->ptqNext)
queue.c:			if(ptq1->dfTime>plpLinearPlan->dfTime)
queue.c:				for(plp=plpLinearPlan;plp;plp=plp->plpParent)
queue.c:					if(plp==ptq1->plpProgenitor||!ptq1->plpProgenitor)
queue.c:		dfQueueTime=ptq1->dfTime;
queue.c:		for(;ptq1!=&tqHead;ptq1=ptq1->ptqNext)
queue.c:			if(ptq1->dfTime!=dfQueueTime)
queue.c:			for(plp=plpLinearPlan;plp;plp=plp->plpParent)
queue.c:				if(plp==ptq1->plpProgenitor||!ptq1->plpProgenitor)
queue.c:					ptqlEnd=ptqlEnd->ptqlNext=(TQLINKP)MemAlloc(sizeof(TQLINK));
queue.c:					ptqlEnd->pcTag=CopyFormula(ptq1->pcTag);	// this is rather inefficient!
queue.c:					if(ptqlEnd->pcTag->pfForm->pcArgs)
queue.c:						ptqlEnd->pcTag->pfForm->pcArgs=
queue.c:							ComputeTerms(ptqlEnd->pcTag->pfForm->pcArgs,plpLinearPlan,ptq1->pbBindings);
queue.c:						if(!ptqlEnd->pcTag->pfForm->pcArgs)
queue.c:							TermError("eval-wait-for-next-event",pcFormula,pbBindings);
queue.c:					ptqlEnd->ptqDelayedAction=ptq1;
queue.c:		ptqlEnd->ptqlNext=NULL;
queue.c:		// match any inhibits against their corresponding delayed-actions
queue.c:		for(ptql1=ptqlHead;ptql1;ptql1=ptql1->ptqlNext)
queue.c:			if(!ptql1->ptqDelayedAction->pcFormula)	// if this is an inhibit
queue.c:				ptql1->ptqDelayedAction=NULL;	// flag this entry
queue.c:				for(ptql2=ptqlHead;ptql2;ptql2=ptql2->ptqlNext)
queue.c:					if(FormulaEqQ(ptql1->pcTag,ptql2->pcTag))	// if we have a match
queue.c:						ptql2->ptqDelayedAction=NULL;	// flag this entry
queue.c:			ptql2=ptql1->ptqlNext;
queue.c:			if(!ptql1->ptqDelayedAction)	// if entry flagged
queue.c:				ptql0->ptqlNext=ptql2;	// delete entry
queue.c:		plpSuccessorWorld->dfTime=dfQueueTime;
queue.c:		pcTag=(CELLP)&plpSuccessorWorld->pcActionName->pfForm->pcArgs;
queue.c:		for(ptql1=ptqlHead;ptql1;ptql1=ptql1->ptqlNext)
queue.c:			(*ptql1->ptqDelayedAction->pcFormula->pfForm->paAction->pfEval)
queue.c:				(ptql1->ptqDelayedAction->pcFormula,plpLinearPlan,ptql1->ptqDelayedAction->pbBindings);
queue.c:			pcTag=pcTag->pcNext=ptql1->pcTag;
queue.c:	for(ptq=tqHead.ptqNext;ptq!=&tqHead;ptq=ptq->ptqNext)
queue.c:		if(ptq->plpProgenitor&&!ZoneMarkedQ(ptq->plpProgenitor))
queue.c:			ptq->ptqPrev->ptqNext=ptq->ptqNext;
queue.c:			ptq->ptqNext->ptqPrev=ptq->ptqPrev;
queue.c:	for(ptq=tqHead.ptqNext;ptq!=&tqHead;ptq=ptq->ptqNext)
queue.c:		MarkFormula(ptq->pcTag);
queue.c:		MarkFormula(ptq->pcFormula);
queue.c:		MarkBindings(ptq->pbBindings);
queue.c:	for(pb=pbBindings;pb;pb=pb->pbNext)
queue.c:		pb2=pb2->pbNext=(BINDINGP)MemAlloc(sizeof(BINDING));
queue.c:		pb2->pcVal=CopyFormula(pb->pcVal);
queue.c:		pb2->pcVar=CopyFormula(pb->pcVar);
queue.c:	pb2->pbNext=NULL;	
queue.c:	for(ptq=tqHead.ptqNext;ptq!=&tqHead;ptq=ptq->ptqNext)
queue.c:			ptq->dfTime,ptq->plpProgenitor?ptq->plpProgenitor->nWorldNumber:0);
queue.c:		for(pb=ptq->pbBindings;pb;pb=pb->pbNext)
queue.c:			PrintTerm(pfTraceStream,pb->pcVar,0,0);
queue.c:			PrintTerm(pfTraceStream,pb->pcVal,0,0);
queue.c:		if(!ptq->pcFormula)
queue.c:		PrintFormula(pfTraceStream,ptq->pcTag,0);
queue.c:		if(ptq->pcFormula)
queue.c:			PrintFormula(pfTraceStream,ptq->pcFormula,0);
queue.c:	for(ptq=tqHead.ptqNext;ptq!=&tqHead;ptq=ptq->ptqNext)
queue.c:		if(ptq->dfTime>plpLinearPlan->dfTime)
queue.c:			for(plp=plpLinearPlan;plp;plp=plp->plpParent)
queue.c:				if(plp==ptq->plpProgenitor||!ptq->plpProgenitor)
queue.c:						ptq->dfTime,ptq->plpProgenitor?ptq->plpProgenitor->nWorldNumber:0,
queue.c:						ptq->pcFormula?"Event":"Inhibit");
queue.c:					PrintFormula(pfTraceStream,Instantiate(ptq->pcTag,ptq->pbBindings),0);
queue.c:					if(ptq->pcFormula)
queue.c:						PrintFormula(pfTraceStream,Instantiate(ptq->pcFormula,ptq->pbBindings),0);
queue.c:	for(ptq=tqHead.ptqNext;ptq!=&tqHead;ptq=ptq->ptqNext)
queue.c:		if(ptq->dfTime>plpLinearPlan->dfTime)
queue.c:			for(plp=plpLinearPlan;plp;plp=plp->plpParent)
queue.c:				if(plp==ptq->plpProgenitor||!ptq->plpProgenitor)
queue.c:	for(ptq=tqHead.ptqNext;ptq!=&tqHead;ptq=ptq->ptqNext)
queue.c:		if(ptq->plpProgenitor==plp)
queue.c:			ptq->ptqPrev->ptqNext=ptq->ptqNext;
queue.c:			ptq->ptqNext->ptqPrev=ptq->ptqPrev;
queue.c:	Compute the current-time function.
queue.c:	Current-time is the time of the successor world.
queue.c:		ErrorMessage("Current-time cannot be used in this context\n");
queue.c:	pc=MakeFloatForm(plpSuccessorWorld->dfTime);
queue.c:	pf=pcFormula->pfForm;
queue.c:	if(pf->pcVars)
queue.c:		pbBindings=ExtendBindings(pf->pcVars,pf->pcVars,pbBindings);
queue.c:	if(pf->pcGenLit)
queue.c:		for(pc=pf->pcGenLit;pc;pc=pc->pcNext)
queue.c:				pc->pfForm=LookupVar(pc,pbBindings)->pfForm;
queue.c:	if(pf->pcArgs)
queue.c:		for(pc=pf->pcArgs;pc;pc=pc->pcNext)
queue.c:				pc->pfForm=LookupVar(pc,pbBindings)->pfForm;
save.c:Copyright C, 1996 - 2001  F. Bacchus
save.c:	1.	When the user calls reset-all we clear all dynamic memory and
save.c:		the domain list -- (list of defined domains)
save.c:		all defined symbols -- (lists and formulas in the hash table)
save.c:		all domain formulas -- asiWorldSymbols
save.c:		all domain operators -- poOperators
save.c:		the initial world -- plpInitialWorld
save.c:		the goal world -- plpGoalWorld
save.c:	for(po=poOperators;po;po=po->poNext)
save.c:	for(pmo=pmoMacroOperators;pmo;pmo=pmo->pmoNext)
save.c:	for(peo=peoElidedOperators;peo;peo=peo->peoNext)
save.c:	/* mark the cost, priority and print-world formulas */
save.c:	for(plp=plpList;plp;plp=plp->plpNext)
save.c:	for(plp=plpPlan;plp;plp=plp->plpParent)
save.c:	for(pb=pbBindings;pb;pb=pb->pbNext)
save.c:		if(pb->pgcContext)
save.c:			ZoneMark(pb->pgcContext);
save.c:			if(pb->pgcContext->pfMark)
save.c:				(pb->pgcContext->pfMark)(pb->pgcContext);
save.c:		MarkFormula(pb->pcVar);
save.c:		MarkFormula(pb->pcVal);
save.c:	ZoneMark(ps->psName);
save.c:	if(ps->nType==ATOM_LISTP)
save.c:		MarkList(ps->uValue.plList);
save.c:	else if(ps->nType==ATOM_FORMULAP)
save.c:		MarkFormula(ps->uValue.pcFormula);
save.c:		the domain list -- (list of defined domains)
save.c:		all defined symbols -- (lists and formulas in the hash table)
save.c:		all domain formulas -- asiWorldSymbols
save.c:		all domain operators -- poOperators
save.c:		the initial plan -- plpInitialPlan
save.c:		the goal plan -- plpGoalPlan
save.c://	for(po=poOperators;po;po=po->poNext)
save.c://	/* ZoneCopy the cost, priority and print-world formulas */
save.c:		the domain list -- (list of defined domains)
save.c:		all defined symbols -- (lists and formulas in the hash table)
save.c:		all domain formulas -- asiWorldSymbols
save.c:		all domain operators -- poOperators
save.c:		the initial plan -- plpInitialPlan
save.c:		the goal plan -- plpGoalPlan
save.c://	for(po=poOperators;po;po=po->poNext)
save.c://	/* ZoneReloc the cost, priority and print-world formulas */
save.c://	for(pb=pbBindings;pb;pb=pb->pbNext)
save.c://		ZoneCopyFormula(pb->pcVar);
save.c://		ZoneCopyFormula(pb->pcVal);
save.c://		pb1=pb->pbNext;
save.c://		ZoneReloc(&pb->pbNext);
save.c://		ZoneReloc(&pb->pcVar);
save.c://		ZoneRelocFormula(pb->pcVar);
save.c://		ZoneReloc(&pb->pcVal);
save.c://		ZoneRelocFormula(pb->pcVal);
search.c:Copyright C, 1996 - 2001	F. Bacchus
search.c:/* local function prototypes --------------------------------------------------- */
search.c:/* local data ------------------------------------------------------------------ */
search.c:/* global data ----------------------------------------------------------------- */
search.c:/* GraphSearch --------------------------------------------------------------
search.c:(define (graph-search start goal? successor-fn combiner-fn state= limit
search.c:	. optional-args)
search.c:			(new-states-filter
search.c:				(if (null? optional-args)
search.c:					filter-old-states
search.c:					(first optional-args)))
search.c:		   (current-state start)
search.c:		   (children-states '()))
search.c:		((or (null? current-state)
search.c:				(and (goal? current-state)
search.c:					(if (null? current-state)
search.c:						'NO-PLAN
search.c:						current-state))
search.c:		(set! limit (- limit 1))
search.c:		(set! children-states (successor-fn current-state))
search.c:		(set! CLOSED (cons current-state CLOSED))
search.c:		(if children-states
search.c:			(set! children-states
search.c:				(new-states-filter children-states OPEN CLOSED state=)))
search.c:		(if children-states
search.c:			(set! OPEN (combiner-fn children-states OPEN)))
search.c:		(set! current-state (if (null? OPEN) '() (first OPEN)))
search.c://		plpOpen=plpOpen->plpNext;
search.c://		pcProgressedTLForm=(*pcTLForm->pfForm->paAction->pfProgress)
search.c://		plpCurrentState->plpNext=plpClosed;
search.c://			pcProgressedTLForm=(*pcTLForm->pfForm->paAction->pfProgress)
search.c://			pcProgressedTLForm=plpCurrentState->pcTLForm;
search.c://					if((*pcGoalAddendum->pfForm->paAction->pfEval)
search.c://			if(plpCurrentState->dfHeuristic>srSearchResult.dfSearchMaxHeuristic)
search.c://				srSearchResult.dfSearchMaxHeuristic=plpCurrentState->dfHeuristic;
search.c://			if((!nSearchDepthLimit||plpCurrentState->nLength<=nSearchDepthLimit)&&
search.c://				(!dfSearchHeuristicLimit||plpCurrentState->dfHeuristic<=dfSearchHeuristicLimit))
search.c://				if(plpChildrenStates&&plpChildrenStates->nLength>srSearchResult.nSearchMaxDepth)
search.c://					srSearchResult.nSearchMaxDepth=plpChildrenStates->nLength;
search.c://		if(pzCurrent->nTotal>nZoneLimit)
search.c://		if(plpCurrentState->nLength>nLength)	// show search depth on screen
search.c://			nLength=plpCurrentState->nLength;
search.c://			plpOpen=plpOpen->plpNext;
search.c://				if((*pcGoalAddendum->pfForm->paAction->pfEval)
search.c://					i=nLimit-1;
search.c://				i=nLimit-1;
search.c:/* Search routines implemented as specializations of GraphSearch --------------- */
search.c:(define (BREADTH-FIRST start goal? successor-fn state= cost-fn priority-fn
search.c:  (graph-search start goal? successor-fn prepend state= limit))
search.c:		plpOpen=plpOpen->plpNext;
search.c:		pcProgressedTLForm=(*pcTLForm->pfForm->paAction->pfProgress)
search.c:		plpCurrentState->plpNext=plpClosed;
search.c:			pcProgressedTLForm=(*pcTLForm->pfForm->paAction->pfProgress)
search.c:			pcProgressedTLForm=plpCurrentState->pcTLForm;
search.c:					if((*pcGoalAddendum->pfForm->paAction->pfEval)
search.c:			if(plpCurrentState->dfHeuristic>srSearchResult.dfSearchMaxHeuristic)
search.c:				srSearchResult.dfSearchMaxHeuristic=plpCurrentState->dfHeuristic;
search.c:			if((!nSearchDepthLimit||plpCurrentState->nLength<=nSearchDepthLimit)&&
search.c:				(!dfSearchHeuristicLimit||plpCurrentState->dfHeuristic<=dfSearchHeuristicLimit))
search.c:				if(plpChildrenStates&&plpChildrenStates->nLength>srSearchResult.nSearchMaxDepth)
search.c:					srSearchResult.nSearchMaxDepth=plpChildrenStates->nLength;
search.c:					plpLast->plpNext=plpChildrenStates;
search.c:					while(plpLast->plpNext)
search.c:						plpLast=plpLast->plpNext;
search.c:		if(pzCurrent->nTotal>nZoneLimit)
search.c:		if(plpCurrentState->nLength>nLength)	// show search depth on screen
search.c:			nLength=plpCurrentState->nLength;
search.c:			plpOpen=plpOpen->plpNext;
search.c:				if((*pcGoalAddendum->pfForm->paAction->pfEval)
search.c:					i=nLimit-1;
search.c:				i=nLimit-1;
search.c:	affected functions to be NON-REENTRANT!
search.c:(define (BREADTH-FIRST-PRIORITY start goal? successor-fn state=
search.c:				cost-fn priority-fn limit)
search.c:  (breadth-first start goal? (sorted successor-fn priority-fn)
search.c:				 state= cost-fn priority-fn limit))
search.c:/* BestFirst -------------------------------------------------------------------
search.c:(define (BEST-FIRST start goal? successor-fn state= cost-fn priority-fn limit)
search.c: (graph-search start goal? successor-fn (merger cost-fn) state= limit
search.c:				(filter-worst-old-states cost-fn)))
search.c:		pcProgressedTLForm=(*pcTLForm->pfForm->paAction->pfProgress)
search.c:		plpCurrentState->plpNext=plpClosed;
search.c:			pcProgressedTLForm=(*pcTLForm->pfForm->paAction->pfProgress)
search.c:			pcProgressedTLForm=plpCurrentState->pcTLForm;
search.c:					if((*pcGoalAddendum->pfForm->paAction->pfEval)
search.c:			if(plpCurrentState->dfHeuristic>srSearchResult.dfSearchMaxHeuristic)
search.c:				srSearchResult.dfSearchMaxHeuristic=plpCurrentState->dfHeuristic;
search.c:			if((!nSearchDepthLimit||plpCurrentState->nLength<=nSearchDepthLimit)&&
search.c:				(!dfSearchHeuristicLimit||plpCurrentState->dfHeuristic<=dfSearchHeuristicLimit))
search.c:				if(plpChildrenStates&&plpChildrenStates->nLength>srSearchResult.nSearchMaxDepth)
search.c:					srSearchResult.nSearchMaxDepth=plpChildrenStates->nLength;
search.c:					for(plp=plpChildrenStates;plp;plp=plp->plpNext)
search.c:		if(pzCurrent->nTotal>nZoneLimit)
search.c:		if(plpCurrentState->nLength>nLength)	// show search depth on screen
search.c:			nLength=plpCurrentState->nLength;
search.c:				if((*pcGoalAddendum->pfForm->paAction->pfEval)
search.c:					i=nLimit-1;
search.c:				i=nLimit-1;
search.c:/* Space efficient Depth First Search ------------------------------------------ */
search.c:(define (DEPTH-FIRST start goal? successor-fn state= cost-fn priority-fn limit
search.c:		. optional-args)
search.c:	(do ((current-state start)
search.c:			(children-states '())
search.c:			(cycle-filter-fn (if (null? optional-args)
search.c:					cycle-filter
search.c:					(first optional-args)))
search.c:			(states-expanded 0))
search.c:		((or (null? current-state)
search.c:				(and (goal? current-state)
search.c:					(if (null? current-state) 'NO-PLAN
search.c:						current-state))
search.c:				(length OPEN) (+ 1 states-expanded)))
search.c:		(set! limit (- limit 1))
search.c:		(set! states-expanded (+ 1 states-expanded))
search.c:		(set! children-states (successor-fn current-state))
search.c:		(if children-states
search.c:			(set! children-states
search.c:				(cycle-filter-fn children-states)))
search.c:		(if children-states
search.c:			(set! OPEN (append! children-states OPEN)))
search.c:		(set! current-state (if (null? OPEN) '() (first OPEN)))
search.c:		plpOpen=plpOpen->plpNext;
search.c:		pcTLForm=plpInitialWorld->pcTLForm;
search.c:		// handle action-promises
search.c:		if(!plpCurrentState->apbtWorld)
search.c:			(*plpCurrentState->pcPromise->pfForm->paAction->pfEval)
search.c:				(plpCurrentState->pcPromise,plpCurrentState,pbBindings);
search.c:					bTLForm=(*pcTLForm->pfForm->paAction->pfEval)
search.c:							if((*pcGoalAddendum->pfForm->paAction->pfEval)
search.c:					if(plpCurrentState->dfHeuristic>srSearchResult.dfSearchMaxHeuristic)
search.c:						srSearchResult.dfSearchMaxHeuristic=plpCurrentState->dfHeuristic;
search.c:					if((!nSearchDepthLimit||plpCurrentState->nLength<=nSearchDepthLimit)&&
search.c:						(!dfSearchHeuristicLimit||plpCurrentState->dfHeuristic<=dfSearchHeuristicLimit))
search.c:						if(plpChildrenStates&&plpChildrenStates->nLength>srSearchResult.nSearchMaxDepth)
search.c:							srSearchResult.nSearchMaxDepth=plpChildrenStates->nLength;
search.c:					pcCCForm=plpCurrentState->pcCCForm;
search.c:						bCCForm=(*pcCCForm->pfForm->paAction->pfEval)(pcCCForm,plpCurrentState,pbBindings);
search.c:						pcProgressedTLForm=(*pcTLForm->pfForm->paAction->pfProgress)
search.c:								plpCurrentState->nWorldNumber);
search.c://						pcProgressedTLForm=(*pcTLForm->pfForm->paAction->pfProgress)
search.c://								plpCurrentState->nWorldNumber);
search.c:					pcProgressedTLForm=plpCurrentState->pcTLForm;		/* test!!! */
search.c:					pcCCForm=(*pcProgressedTLForm->pfForm->paAction->pfMakeCCForm)
search.c:							if((*pcGoalAddendum->pfForm->paAction->pfEval)
search.c:					if(plpCurrentState->dfHeuristic>srSearchResult.dfSearchMaxHeuristic)
search.c:						srSearchResult.dfSearchMaxHeuristic=plpCurrentState->dfHeuristic;
search.c:					if((!nSearchDepthLimit||plpCurrentState->nLength<=nSearchDepthLimit)&&
search.c:						(!dfSearchHeuristicLimit||plpCurrentState->dfHeuristic<=dfSearchHeuristicLimit))
search.c:						if(plpChildrenStates&&plpChildrenStates->nLength>srSearchResult.nSearchMaxDepth)
search.c:							srSearchResult.nSearchMaxDepth=plpChildrenStates->nLength;
search.c:		if(pzCurrent->nTotal>nZoneLimit)
search.c:			plpOpen=plpOpen->plpNext;
search.c:		// handle action-promises
search.c:		if(!plpCurrentState->apbtWorld)
search.c:			(*plpCurrentState->pcPromise->pfForm->paAction->pfEval)
search.c:				(plpCurrentState->pcPromise,plpCurrentState,pbBindings);
search.c:				if((*pcGoalAddendum->pfForm->paAction->pfEval)
search.c:					i=nLimit-1;
search.c:				i=nLimit-1;
search.c:(define (DEPTH-FIRST-PRIORITY start goal? successor-fn state= cost-fn
search.c:				  priority-fn limit)
search.c:  (depth-first start goal? (sorted successor-fn priority-fn)
search.c:		   state= cost-fn priority-fn limit))
search.c:/* DepthFirstNoBacktracking ----------------------------------------------------
search.c:	Cycle checking and pruning are handled by modify-world, so that we can
search.c:		pcProgressedTLForm=(*pcTLForm->pfForm->paAction->pfProgress)
search.c:				FunctionTracer(plpCurrentState,plpCurrentState->pcTLForm,pcTLForm,pcCCForm,NULL,pbBindings);
search.c:		plpCurrentState->pcTLForm=pcProgressedTLForm;
search.c:				if((*pcGoalAddendum->pfForm->paAction->pfEval)
search.c:			srSearchResult.nSearchMaxDepth=plpChildState->nLength;
search.c:			FunctionTracer(plpCurrentState,plpCurrentState->pcTLForm,pcTLForm,plpCurrentState->pcCCForm,plpChildState,pbBindings);
search.c:		if(pzCurrent->nTotal>nZoneLimit)
search.c:			plpOpen=plpOpen->plpNext;
search.c:				if((*pcGoalAddendum->pfForm->paAction->pfEval)
search.c:					i=nLimit-1;
search.c:				i=nLimit-1;
search.c:/* FollowPredefinedPlan --------------------------------------------------------
search.c:	Follow a predefined plan for load-plan.
search.c:		plpOpen=plpOpen->plpNext;
search.c:	for(pc=pcPredefinedPlan;pc;pc=pc->pcNext)
search.c:			pcProgressedTLForm=(*pcTLForm->pfForm->paAction->pfProgress)
search.c:						if((*pcGoalAddendum->pfForm->paAction->pfEval)
search.c:				if(plpCurrentState->dfHeuristic>srSearchResult.dfSearchMaxHeuristic)
search.c:					srSearchResult.dfSearchMaxHeuristic=plpCurrentState->dfHeuristic;
search.c:				if((!nSearchDepthLimit||plpCurrentState->nLength<=nSearchDepthLimit)&&
search.c:					(!dfSearchHeuristicLimit||plpCurrentState->dfHeuristic<=dfSearchHeuristicLimit))
search.c:					if(plpOpen&&plpOpen->nLength>srSearchResult.nSearchMaxDepth)
search.c:						srSearchResult.nSearchMaxDepth=plpOpen->nLength;
search.c:		if(pzCurrent->nTotal>nZoneLimit)
search.c:		for(plp=plpOpen;plp;plp=plp->plpNext)
search.c:			if(FormulaEqQ(plp->pcActionName,pc))
search.c:			CommandPrintf(pfTraceStream,"load-plan:  Invalid action, step %d.\n",nStatesExpanded+1);
search.c:/* Successor Functions --------------------------------------------------------- */
search.c:(define (plan-successor-fn plan)
search.c:	(let ((progressed-tlform
search.c:				(progress-formula
search.c:					(plan-tlform  plan)
search.c:					(plan-world/action plan)
search.c:			(new-plans '()))
search.c:		(if progressed-tlform
search.c:			(do ((successors (generate-successors (plan-world/action plan)))
search.c:				(set! new-plans (cons (plan-extend successor progressed-tlform plan)
search.c:						new-plans)))
search.c:			(set! *pruned-worlds* (+ *pruned-worlds* 1)))
search.c:		(tl-tracer 'plan-successors (list plan progressed-tlform new-plans))
search.c:		new-plans))
search.c:	for(plpSuccessor=plpSuccessors;plpSuccessor;plpSuccessor=plpSuccessor->plpNext)
search.c:		plpNewEnd=plpNewEnd->plpNext=PlanExtend(plpSuccessor,pcTLForm,pcCCForm,plpPlan,pbBindings);
search.c:	This is the successor function for depth-first-no-backtracking.
search.c:		plpNewPlan=PlanExtend(plpSuccessor,plpSuccessor->pcTLForm,plpSuccessor->pcCCForm,plpPlan,pbBindings);
search.c:(define (sorted successor-fn priority-fn)
search.c:	(sort (successor-fn state)
search.c:	  (lambda (x1 x2) (> (priority-fn x1) (priority-fn x2))))))
search.c:	if(plpPlan1->dfPriority>plpPlan2->dfPriority)	// backwards!
search.c:		return -1;
search.c:	if(plpPlan1->dfPriority<plpPlan2->dfPriority)	// backwards!
search.c:	if(plpPlan1->dfHeuristic<plpPlan2->dfHeuristic)
search.c:		return -1;
search.c:	if(plpPlan1->dfHeuristic>plpPlan2->dfHeuristic)
search.c:/* Combiner Functions ---------------------------------------------------------- */
search.c://		for(plp=plp2;plp->plpNext;plp=plp->plpNext);	/* find end of second list */
search.c://		plp->plpNext=plp1;
search.c:		for(plp=plp1;plp->plpNext;plp=plp->plpNext);	/* find end of first list */
search.c:		plp->plpNext=plp2;
search.c:(define (merger cost-fn)
search.c:	(merge-sorted-lists (sort new (lambda (x1 x2)
search.c:					(< (cost-fn x1) (cost-fn x2))))
search.c:			:key cost-fn)))
search.c:	This routine is used to compare worlds for best-first search.
search.c:	if(plpPlan1->dfHeuristic<plpPlan2->dfHeuristic)
search.c:		return -1;
search.c:	if(plpPlan1->dfHeuristic>plpPlan2->dfHeuristic)
search.c:	if(plpPlan1->nLength>plpPlan2->nLength)
search.c:		return -1;
search.c:	if(plpPlan1->nLength<plpPlan2->nLength)
search.c:	if(plpPlan1->nWorldNumber<plpPlan2->nWorldNumber)
search.c:		return -1;
search.c:	if(plpPlan1->nWorldNumber>plpPlan2->nWorldNumber)
search.c:/* Filter Functions ------------------------------------------------------------ */
search.c:(define (cycle-filter new-states)
search.c:  (remove-if plan-has-cycle new-states))
search.c:/* PlanHasCycleQ ---------------------------------------------------------------
search.c:(define (plan-has-cycle plan)
search.c:		((null? (plan-previous plan))
search.c:			(plan-has-cycle-recurse plan (plan-previous plan)))))
search.c:(define (plan-has-cycle-recurse plan previous)
search.c:		((null? (plan-previous previous))
search.c:			(plan-has-cycle-recurse plan (plan-previous previous)))))
search.c:				CommandPrintf(pfTraceStream,"\nWorld %d is equivalent to world %d\n",plpPlan->nWorldNumber,plpParent->nWorldNumber);
search.c:(define (filter-old-states new-states OPEN CLOSED state=)
search.c:  (remove-if
search.c:   new-states))
search.c:		plpNext=plpS->plpNext;
search.c:			plpEnd=plpEnd->plpNext=plpS;
search.c:	plpEnd->plpNext=NULL;				/* terminate open list */
search.c://		plpNext=plpS->plpNext;
search.c://		for(plpO=plpOpen;plpO;plpO=plpO->plpNext)	/* check open list */
search.c://			for(plpC=plpClosed;plpC;plpC=plpC->plpNext)
search.c://			plpEnd=plpEnd->plpNext=plpS;
search.c://	plpEnd->plpNext=NULL;				/* terminate open list */
search.c:(define (filter-worst-old-states cost-fn)
search.c:	(lambda (new-states OPEN CLOSED state=)
search.c:				(new-state '()))
search.c:			((null? new-states) result)
search.c:			(set! new-state (first new-states))
search.c:			(set! new-states (rest new-states))
search.c:			(let ((old-copies (append! (find-all new-state OPEN state=)
search.c:							(find-all new-state CLOSED state=)))
search.c:					(new-cost (cost-fn new-state)))
search.c:			(if (every (lambda (old-copy) (> (cost-fn old-copy) new-cost))
search.c:					old-copies)
search.c:				(set! result (cons new-state result)))))))
search.c:		plpNext=plpS->plpNext;
search.c:		dfNewCost=plpS->dfHeuristic;
search.c:		if(!plpOld||plpOld->dfHeuristic>dfNewCost)
search.c:			plpEnd=plpEnd->plpNext=plpS;
search.c:	plpEnd->plpNext=NULL;				/* terminate open list */
search.c://		plpNext=plpS->plpNext;
search.c://		dfNewCost=plpS->dfHeuristic;
search.c://		for(plpOld=plpOpen;plpOld;plpOld=plpOld->plpNext)
search.c://			if((*pfStateEqQ)(plpS,plpOld)&&plpOld->dfHeuristic<=dfNewCost)
search.c://			for(plpOld=plpClosed;plpOld;plpOld=plpOld->plpNext)
search.c://				if((*pfStateEqQ)(plpS,plpOld)&&plpOld->dfHeuristic<=dfNewCost)
search.c://				plpEnd=plpEnd->plpNext=plpS;	/* state is cheaper, keep it */
search.c://	plpEnd->plpNext=NULL;				/* terminate open list */
search.c:		df=plpPlan->dfCost;				/* default is optimal-cost */
search.c:		df=LinearPlanActionPriority(plpPlan);	/* default is best-action */
search.c:		CommandPrintf(pfTraceStream,"-----------------------------------------"
search.c:			"---------------------------------------\n");
search.c:			plp->nWorldNumber,LinearPlanLength(plp));
search.c:	list, so we can discard all non-viable worlds.
search.c://	for(plp=plpOpen;plp;plp=plp->plpNext)
search.c://			bTLForm=(*pcTLForm->pfForm->paAction->pfEval)
search.c://			pcTLForm=plp->pcTLForm;
search.c://			bTLForm=(*pcTLForm->pfForm->paAction->pfCurrent)
search.c://			plp1->plpNext=plp->plpNext;	/* discard this world */
search.c://				CommandPrintf(pfTraceStream,"-----------------------------------------"
search.c://					"---------------------------------------\n");
search.c://				CommandPrintf(pfTraceStream,"World %d at depth %d is non-viable:  World pruned.\n\n",
search.c://					plp->nWorldNumber,LinearPlanLength(plp));
search.c:		pcTLForm=plpInitialWorld->pcTLForm;
search.c:	for(plp=*pplpList;plp;plp=plp->plpNext)
search.c://			bTLForm=(*pcTLForm->pfForm->paAction->pfEval)
search.c://			pcTLForm=plp->pcTLForm;
search.c://			bTLForm=(*pcTLForm->pfForm->paAction->pfCurrent)
search.c:		pcProgressedTLForm=(*pcTLForm->pfForm->paAction->pfProgress)
search.c:			plp1->plpNext=plp->plpNext;	/* discard this world */
search.c:				CommandPrintf(pfTraceStream,"-----------------------------------------"
search.c:					"---------------------------------------\n");
search.c:				CommandPrintf(pfTraceStream,"World %d at depth %d is non-viable:  World pruned.\n\n",
search.c:					plp->nWorldNumber,LinearPlanLength(plp));
search.c:			plp->pcTLForm=pcProgressedTLForm;		/* test!!! */
search.c://		nWorldsPruned-nWorlds,nOpen);
search.c:/* ResetTimers -----------------------------------------------------------------
search.c:		tsTimers.adfProgress[1]-tsTimers.adfProgressAtomic[1]);
strips.c:Copyright C, 1996 - 99  F. Bacchus
strips.c:STRIPS Operators ---------------------------------------------------------------
strips.c:	pre			--- Preconditions, list of literals that may have variables.
strips.c:	add			--- Add list
strips.c:	del			--- del list
strips.c:(def-strips-operator (pickup ?x)
strips.c:/* -----------------------------------------------------------------------------
strips.c:(define (def-strips-operator . keyword-args)
strips.c:			(update-formula '())
strips.c:			((null? keyword-args))
strips.c:			(case (first keyword-args)
strips.c:				(:name (set! name (cadr keyword-args)))
strips.c:				(:pre (set! pre (cadr keyword-args)))
strips.c:				(:add (set! add (cadr keyword-args)))
strips.c:				(:del (set! del (cadr keyword-args)))
strips.c:				(:duration (set! duration (cadr keyword-args)))
strips.c:				(:cost (set! cost (cadr keyword-args)))
strips.c:				(:priority (set! priority (cadr keyword-args)))
strips.c:				(else (error "Illegal keyword: ~A" (first keyword-args))))
strips.c:			(set! keyword-args (cddr keyword-args)))
strips.c:		(set! op (make-operator :name name :pre pre :add add :del del
strips.c:		(set! preconds (operator-pre op))
strips.c:		(let ((vars-remaining (variables-in preconds))
strips.c:				(without-variables '())
strips.c:				(with-variables '())
strips.c:				(modify-world '()))
strips.c:				(if (variable-free? lit)
strips.c:					(set! without-variables (cons lit without-variables))
strips.c:					(set! with-variables (cons lit with-variables))))
strips.c:			(set! with-variables (reverse! with-variables))
strips.c:			(set! modify-world
strips.c:					(let ((new-world (copy-world (world/action-world world/action))))
strips.c:								(del-lit '()))
strips.c:							(set! del-lit (first literals))
strips.c:							;;(format #t "~%del-lit~S" del-lit)
strips.c:							(delete-world-lit (get-operator del-lit)
strips.c:								(eval-terms (get-args del-lit)
strips.c:								new-world))
strips.c:								(add-lit '()))
strips.c:							(set! add-lit (first literals))
strips.c:							;;(format #t "~%Add-lit~S" add-lit)
strips.c:							(add-world-lit (get-operator add-lit)
strips.c:								(eval-terms (get-args add-lit)
strips.c:								new-world))
strips.c:							(cons (make-world/action
strips.c:									new-world
strips.c:									(cons (get-operator name)
strips.c:										(eval-terms (get-args name)
strips.c:									(eval-term duration world/action bindings)
strips.c:									(eval-term cost world/action bindings)
strips.c:			(letrec ((make-forall
strips.c:								((null? vars-remaining)
strips.c:										`(CALL ,modify-world)
strips.c:											`(CALL ,modify-world))))
strips.c:									(let ((new-vars
strips.c:												(intersection vars-remaining
strips.c:													(variables-in (first lits)))))
strips.c:										(set! vars-remaining
strips.c:											(set-difference vars-remaining new-vars))
strips.c:										(if (not (null? new-vars))
strips.c:										`(FORALL ,new-vars ,(first lits) ,(make-forall (rest lits)))
strips.c:										`(AND ,(first lits) ,(make-forall (rest lits))))))))))
strips.c:				(set! update-formula
strips.c:					(if without-variables
strips.c:						`(AND ,@without-variables
strips.c:							,(make-forall with-variables))
strips.c:						(make-forall with-variables)))))
strips.c:				(format *trace-stream*
strips.c:				(format #t "~%~S~%~%" update-formula)))
strips.c:		(set-operator-eval-object! op
strips.c:				(eval-formula update-formula world/action '())
strips.c:		(add-op op)))
strips.c:	if(pcMod&&pcMod->pcNext)
strips.c:	pcSuccessor=CompileSuccessor(pcPre?pcPre->pfForm->pcArgs:NULL,pcModifyWorld);
strips.c:	/* create the operator and thread it back into modify-world */
strips.c:	pcModifyWorld->pfForm->pcArgs->pfForm->uValue.poOperator=po;
strips.c:			GetName(pcName->pfForm,ac));
strips.c:	pcName=pcFormula->pfForm->pcArgs;
strips.c:		ErrorMessage("def-strips-operator:  No name or argument list specified.\n");
strips.c:	for(pc=pcName->pcNext;pc;pc=pc1)
strips.c:		pc1=pc->pcNext;
strips.c:		pc->pcNext=NULL;
strips.c:		if(StringEqQ(IdentName(pc->pfForm),apsStringTab[STRING_DURATION]))
strips.c:				ErrorMessage("def-strips-operator:  %s has more than one duration clause\n",
strips.c:					GetName(pcName->pfForm,ac));
strips.c:			pcDuration=pc->pfForm->pcArgs;
strips.c:		else if(StringEqQ(IdentName(pc->pfForm),apsStringTab[STRING_COST]))
strips.c:				ErrorMessage("def-strips-operator:  %s has more than one cost clause\n",
strips.c:					GetName(pcName->pfForm,ac));
strips.c:			pcCost=pc->pfForm->pcArgs;
strips.c:		else if(StringEqQ(IdentName(pc->pfForm),apsStringTab[STRING_PRIORITY]))
strips.c:				ErrorMessage("def-strips-operator:  %s has more than one priority clause\n",
strips.c:					GetName(pcName->pfForm,ac));
strips.c:			pcPriority=pc->pfForm->pcArgs;
strips.c:		else if(StringEqQ(IdentName(pc->pfForm),apsStringTab[STRING_PRE]))
strips.c:				ErrorMessage("def-strips-operator:  %s has more than one preconditions clause\n",
strips.c:					GetName(pcName->pfForm,ac));
strips.c:		else if(StringEqQ(IdentName(pc->pfForm),apsStringTab[STRING_ADD]))
strips.c:				ErrorMessage("def-strips-operator:  %s has more than one add clause\n",
strips.c:					GetName(pcName->pfForm,ac));
strips.c:		else if(StringEqQ(IdentName(pc->pfForm),apsStringTab[STRING_DEL]))
strips.c:				ErrorMessage("def-strips-operator:  %s has more than one delete clause\n",
strips.c:					GetName(pcName->pfForm,ac));
strips.c:			ErrorMessage("def-strips-operator:  Unknown keyword \"%s\"\n",
strips.c:				GetName(pc->pfForm,ac));
strips.c:/* Formula compile routines ---------------------------------------------------- */
strips.c:	for(pc=pcPre;pc;pc=pc->pcNext)
strips.c:			pcWithoutEnd=pcWithoutEnd->pcNext=pc1;
strips.c:			pcWithEnd=pcWithEnd->pcNext=pc1;
strips.c:			pc=MakeImpliesForm(FALSE,pcLits->pcNext?MakeAndForm(FALSE,pc):pc,
strips.c:	pcRest=pcLits->pcNext;				/* split the list of literals */
strips.c:	pcLits->pcNext=NULL;
tllex.c:/* The "const" storage-class-modifier is valid. */
tllex.c: #pragma warn -rch
tllex.c: #pragma warn -use
tllex.c:/* Returned upon end-of-file. */
tllex.c: * we want to instead treat it as an 8-bit unsigned char, hence the
tllex.c: * but we do it the disgusting crufty way forced on us by the ()-less
tllex.c:#define YY_START ((yy_start - 1) / 2)
tllex.c:/* The funky do-while in the following #define is used to turn the definition
tllex.c: * int a single C statement (which needs a semi-colon terminator).  This
tllex.c: * Prior to using the do-while the compiler would get upset at the
tllex.c:		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
tllex.c: * flex-generated scanners to compile on their own).
tllex.c:	/* Whether we "own" the buffer - i.e., we know we created it,
tllex.c:	 * possible backing-up.
tllex.c:	yy_current_buffer->yy_is_interactive = is_interactive; \
tllex.c:	yy_current_buffer->yy_at_bol = at_bol; \
tllex.c:#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
tllex.c: * corresponding action - sets up yytext.
tllex.c:	yytext_ptr -= yy_more_len; \
tllex.c:	yyleng = (int) (yy_cp - yytext_ptr); \
tllex.c:/* tllex.c -- temporal logic "list" language lexical analyzer
tllex.c: * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
tllex.c:	if ( yy_current_buffer->yy_is_interactive ) \
tllex.c:/* No semi-colon after return; correct usage is to write "yyterminate();" -
tllex.c:/* Number of entries by which start-condition stack grows. */
tllex.c:/* Default declaration of generated scanner - a define so the user can
tllex.c:	while ( 1 )		/* loops until end-of-file is reached */
tllex.c:			yy_more_len = yy_c_buf_p - yytext_ptr;
tllex.c:/*						ErrorMessage("... found non-escape characters in string [%s]\n",yytext); */
tllex.c:/*						errmsg(current_line,yytext-yysol, */
tllex.c:yy_c_buf_p = yy_cp -= 1;
tllex.c:		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
tllex.c:		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
tllex.c:			 * back-up) that will match for the new input source.
tllex.c:			yy_n_chars = yy_current_buffer->yy_n_chars;
tllex.c:			yy_current_buffer->yy_input_file = yyin;
tllex.c:			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
tllex.c:		 * end-of-buffer state).  Contrast this with the test
tllex.c:		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
tllex.c:					 * YY_NULL, it'll still work - another
tllex.c:				&yy_current_buffer->yy_ch_buf[yy_n_chars];
tllex.c:			"fatal flex scanner internal error--no action found" );
tllex.c:/* yy_get_next_buffer - try to read in a new buffer
tllex.c: *	EOB_ACT_LAST_MATCH -
tllex.c: *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
tllex.c: *	EOB_ACT_END_OF_FILE - end of file
tllex.c:	register char *dest = yy_current_buffer->yy_ch_buf;
tllex.c:	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
tllex.c:		"fatal flex scanner internal error--end of buffer missed" );
tllex.c:	if ( yy_current_buffer->yy_fill_buffer == 0 )
tllex.c:		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
tllex.c:	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
tllex.c:	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
tllex.c:		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
tllex.c:			yy_current_buffer->yy_buf_size - number_to_move - 1;
tllex.c:			{ /* Not enough room in the buffer - grow it. */
tllex.c:				(int) (yy_c_buf_p - b->yy_ch_buf);
tllex.c:			if ( b->yy_is_our_buffer )
tllex.c:				int new_size = b->yy_buf_size * 2;
tllex.c:					b->yy_buf_size += b->yy_buf_size / 8;
tllex.c:					b->yy_buf_size *= 2;
tllex.c:				b->yy_ch_buf = (char *)
tllex.c:					yy_flex_realloc( (void *) b->yy_ch_buf,
tllex.c:							 b->yy_buf_size + 2 );
tllex.c:				b->yy_ch_buf = 0;
tllex.c:			if ( ! b->yy_ch_buf )
tllex.c:				"fatal error - scanner input buffer overflow" );
tllex.c:			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
tllex.c:			num_to_read = yy_current_buffer->yy_buf_size -
tllex.c:						number_to_move - 1;
tllex.c:		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
tllex.c:		yy_current_buffer->yy_n_chars = yy_n_chars;
tllex.c:			yy_current_buffer->yy_buffer_status =
tllex.c:	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
tllex.c:	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
tllex.c:	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
tllex.c:/* yy_get_previous_state - get the state just before the EOB char was reached */
tllex.c:/* yy_try_NUL_trans - try to make a transition on the NUL character
tllex.c:	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
tllex.c:		register char *dest = &yy_current_buffer->yy_ch_buf[
tllex.c:					yy_current_buffer->yy_buf_size + 2];
tllex.c:				&yy_current_buffer->yy_ch_buf[number_to_move];
tllex.c:		while ( source > yy_current_buffer->yy_ch_buf )
tllex.c:			*--dest = *--source;
tllex.c:		yy_cp += (int) (dest - source);
tllex.c:		yy_bp += (int) (dest - source);
tllex.c:		yy_current_buffer->yy_n_chars =
tllex.c:			yy_n_chars = yy_current_buffer->yy_buf_size;
tllex.c:		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
tllex.c:			YY_FATAL_ERROR( "flex scanner push-back overflow" );
tllex.c:	*--yy_cp = (char) c;
tllex.c:		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
tllex.c:			int offset = yy_c_buf_p - yytext_ptr;
tllex.c:	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
tllex.c:		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
tllex.c:		yy_current_buffer->yy_n_chars = yy_n_chars;
tllex.c:	yy_n_chars = yy_current_buffer->yy_n_chars;
tllex.c:	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
tllex.c:	yyin = yy_current_buffer->yy_input_file;
tllex.c:	b->yy_buf_size = size;
tllex.c:	 * we need to put in 2 end-of-buffer characters.
tllex.c:	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
tllex.c:	if ( ! b->yy_ch_buf )
tllex.c:	b->yy_is_our_buffer = 1;
tllex.c:	if ( b->yy_is_our_buffer )
tllex.c:		yy_flex_free( (void *) b->yy_ch_buf );
tllex.c:	b->yy_input_file = file;
tllex.c:	b->yy_fill_buffer = 1;
tllex.c:	b->yy_is_interactive = 1;
tllex.c:	b->yy_is_interactive = 0;
tllex.c:	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
tllex.c:	b->yy_n_chars = 0;
tllex.c:	/* We always need two end-of-buffer characters.  The first causes
tllex.c:	 * a transition to the end-of-buffer state.  The second causes
tllex.c:	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
tllex.c:	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
tllex.c:	b->yy_buf_pos = &b->yy_ch_buf[0];
tllex.c:	b->yy_at_bol = 1;
tllex.c:	b->yy_buffer_status = YY_BUFFER_NEW;
tllex.c:	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
tllex.c:	     base[size-1] != YY_END_OF_BUFFER_CHAR )
tllex.c:	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
tllex.c:	b->yy_buf_pos = b->yy_ch_buf = base;
tllex.c:	b->yy_is_our_buffer = 0;
tllex.c:	b->yy_input_file = 0;
tllex.c:	b->yy_n_chars = b->yy_buf_size;
tllex.c:	b->yy_is_interactive = 0;
tllex.c:	b->yy_at_bol = 1;
tllex.c:	b->yy_fill_buffer = 0;
tllex.c:	b->yy_buffer_status = YY_BUFFER_NEW;
tllex.c:	b->yy_is_our_buffer = 1;
tllex.c:			"out of memory expanding start-condition stack" );
tllex.c:	if ( --yy_start_stack_ptr < 0 )
tllex.c:		YY_FATAL_ERROR( "start-condition stack underflow" );
tllex.c:	return yy_start_stack[yy_start_stack_ptr - 1];
tllex.c:	if(psFile&&psFile!=(char *)-1)
tllib.c:/* tllib.c -- tlplanner user dynalink library
tllib.c:Copyright C, 1997 - 99  F. Bacchus
tllib.c:/* DLLEntryPoint --------------------------------------------------------------- */
tlparse.c:/* tlparse.c -- tlplan symbol table, parser and lexical analyzer support routines
tlparse.c:Copyright C, 1996 - 2001  F. Bacchus
tlparse.c:	{STRING_ACTION_PRIORITY,"action-priority"},
tlparse.c:	{STRING_BEST_ACTION,"best-action"},
tlparse.c:	{STRING_DOMAIN_GLOBAL,"domain-global"},
tlparse.c:	{STRING_IF_THEN_ELSE,"if-then-else"},
tlparse.c:	{STRING_NO_PLAN,"no-plan"},
tlparse.c:	{STRING_OPTIMAL_COST,"optimal-cost"},
tlparse.c:	{STRING_PLAN_COST,"plan-cost"},
tlparse.c:	{STRING_PLAN_LENGTH,"plan-length"},
tlparse.c:	{STRING_SET_PLAN_NAME,"set-plan-name"},
tlparse.c:	{STRING_DEPTH_BEST_FIRST,"depth-best-first"},
tlparse.c:	{STRING_PRINT_WORLD,"print-world"},
tlparse.c:	{STRING_SEARCH_GLOBAL,"search-global"},
tlparse.c:	{STRING_DEF_DEFINED_GENERATOR,"def-defined-generator"},
tlparse.c:	{STRING_GET_GOAL_ADDENDUM,"get-goal-addendum"},
tlparse.c:	{STRING_T_ALWAYS,"t-always"},
tlparse.c:	{STRING_T_EVENTUALLY,"t-eventually"},
tlparse.c:	{STRING_T_UNTIL,"t-until"},
tlparse.c:	{STRING_WORLD_GLOBAL,"world-global"},
tlparse.c:	{STRING_WORLD_HEURISTIC_RANK,"world-heuristic-rank"},
tlparse.c:	{STRING_WORLD_NUMBER,"world-number"},
tlparse.c:	{STRING_BREADTH_FIRST,"breadth-first"},
tlparse.c:	{STRING_BREADTH_FIRST_PRIORITY,"breadth-first-priority"},
tlparse.c:	{STRING_BEST_FIRST,"best-first"},
tlparse.c:	{STRING_DEPTH_FIRST,"depth-first"},
tlparse.c:	{STRING_DEPTH_FIRST_PRIORITY,"depth-first-priority"},
tlparse.c:	{STRING_DEPTH_FIRST_NO_BACKTRACKING,"depth-first-no-backtracking"},
tlparse.c:	{STRING_MINUS,"-"},
tlparse.c:	{STRING_POS_INT,"pos-int"},
tlparse.c:	{STRING_LT_POS_INT,"<-pos-int"},
tlparse.c:	{STRING_IS_BETWEEN,"is-between"},
tlparse.c:	{STRING_CLEAR_WORLD_SYMBOLS,"clear-world-symbols"},
tlparse.c:	{STRING_DECLARE_DEFINED_SYMBOLS,"declare-defined-symbols"},
tlparse.c:	{STRING_DECLARE_DESCRIBED_SYMBOLS,"declare-described-symbols"},
tlparse.c:	{STRING_DECLARE_EXTERNAL_SYMBOLS,"declare-external-symbols"},
tlparse.c:	{STRING_DECLARE_GLOBAL_VARIABLES,"declare-global-variables"},
tlparse.c:	{STRING_DEF_ADL_OPERATOR,"def-adl-operator"},
tlparse.c:	{STRING_DEF_DEFINED_FUNCTION,"def-defined-function"},
tlparse.c:	{STRING_DEF_DEFINED_PREDICATE,"def-defined-predicate"},
tlparse.c:	{STRING_DEF_DOMAIN,"def-domain"},
tlparse.c:	{STRING_DEF_STRIPS_OPERATOR,"def-strips-operator"},
tlparse.c:	{STRING_GET_HEURISTIC_FN,"get-heuristic-fn"},
tlparse.c:	{STRING_PRINT_WORLD_LIST,"print-world-list"},
tlparse.c:	{STRING_GET_PRIORITY_FN,"get-priority-fn"},
tlparse.c:	{STRING_GET_SEARCH_LIMIT,"get-search-limit"},
tlparse.c:	{STRING_GET_SEARCH_STRATEGY,"get-search-strategy"},
tlparse.c:	{STRING_GET_TL_CONTROL,"get-tl-control"},
tlparse.c:	{STRING_GET_TRACE_LEVEL,"get-trace-level"},
tlparse.c:	{STRING_LIST_DOMAINS,"list-domains"},
tlparse.c:	{STRING_LOAD_DOMAIN,"load-domain"},
tlparse.c:	{STRING_LOAD_FILE,"load-file"},
tlparse.c:	{STRING_PRINT_PLAN_LIST,"print-plan-list"},
tlparse.c:	{STRING_RESET_DOMAINS,"reset-domains"},
tlparse.c:	{STRING_RESET_HEURISTIC_FN,"reset-heuristic-fn"},
tlparse.c:	{STRING_RESET_PRINT_WORLD_FN,"reset-print-world-fn"},
tlparse.c:	{STRING_RESET_PRIORITY_FN,"reset-priority-fn"},
tlparse.c:	{STRING_RESET_SEARCH_LIMIT,"reset-search-limit"},
tlparse.c:	{STRING_RESET_SEARCH_STRATEGY,"reset-search-strategy"},
tlparse.c:	{STRING_RESET_TL_CONTROL,"reset-tl-control"},
tlparse.c:	{STRING_SET_CONTROL,"set-control"},
tlparse.c:	{STRING_SET_HEURISTIC_FN,"set-heuristic-fn"},
tlparse.c:	{STRING_SET_INITIAL_FACTS,"set-initial-facts"},
tlparse.c:	{STRING_SET_INITIAL_WORLD,"set-initial-world"},
tlparse.c:	{STRING_SET_INITIALIZATION_SEQUENCE,"set-initialization-sequence"},
tlparse.c:	{STRING_SET_GOAL,"set-goal"},
tlparse.c:	{STRING_SET_GOAL_TYPE,"set-goal-type"},
tlparse.c:	{STRING_SET_PRINT_WORLD_FN,"set-print-world-fn"},
tlparse.c:	{STRING_SET_PRIORITY_FN,"set-priority-fn"},
tlparse.c:	{STRING_SET_SEARCH_LIMIT,"set-search-limit"},
tlparse.c:	{STRING_SET_SEARCH_STRATEGY,"set-search-strategy"},
tlparse.c:	{STRING_SET_STATISTICS_FILE,"set-statistics-file"},
tlparse.c:	{STRING_SET_TL_CONTROL,"set-tl-control"},
tlparse.c:	{STRING_SET_TRACE_LEVEL,"set-trace-level"},
tlparse.c:	{STRING_VERBOSE_OFF,"verbose-off"},
tlparse.c:	{STRING_VERBOSE_ON,"verbose-on"},
tlparse.c:	{STRING_ACTION_NAME,"action-name"},
tlparse.c:	{STRING_ACTION_COST,"action-cost"},
tlparse.c:	{STRING_ACTION_DURATION,"action-duration"},
tlparse.c:	{STRING_LOCAL_VARS,"local-vars"},
tlparse.c:	{STRING_SELECT_INITIAL_WORLD,"select-initial-world"},
tlparse.c:	{STRING_SELECT_FINAL_WORLD,"select-final-world"},
tlparse.c:	{STRING_SELECT_NEXT_WORLD,"select-next-world"},
tlparse.c:	{STRING_SELECT_PREVIOUS_WORLD,"select-previous-world"},
tlparse.c:	{STRING_OPEN_FILE,"open-file"},
tlparse.c:	{STRING_CLOSE_FILE,"close-file"},
tlparse.c:	{STRING_SET_RNG,"set-rng"},
tlparse.c:	{STRING_RESET_RNG,"reset-rng"},
tlparse.c:	{STRING_GET_RNG,"get-rng"},
tlparse.c:	{STRING_DEF_DEFINED_MACRO,"def-defined-macro"},
tlparse.c:	{STRING_PLAN_DURATION,"plan-duration"},
tlparse.c:	{STRING_PLAN_STATUS,"plan-status"},
tlparse.c:	{STRING_WORLDS_GENERATED,"worlds-generated"},
tlparse.c:	{STRING_WORLDS_SEARCHED,"worlds-searched"},
tlparse.c:	{STRING_WORLDS_PRUNED,"worlds-pruned"},
tlparse.c:	{STRING_WORLDS_DISCARDED,"worlds-discarded"},
tlparse.c:	{STRING_WORLDS_UNEXAMINED,"worlds-unexamined"},
tlparse.c:	{STRING_PLAN_CPU_TIME,"plan-cpu-time"},
tlparse.c:	{STRING_SET_SEARCH_DEPTH_LIMIT,"set-search-depth-limit"},
tlparse.c:	{STRING_GET_SEARCH_DEPTH_LIMIT,"get-search-depth-limit"},
tlparse.c:	{STRING_SEARCH_MAX_DEPTH,"search-max-depth"},
tlparse.c:	{STRING_SET_SEARCH_HEURISTIC_LIMIT,"set-search-heuristic-limit"},
tlparse.c:	{STRING_GET_SEARCH_HEURISTIC_LIMIT,"get-search-heuristic-limit"},
tlparse.c:	{STRING_SEARCH_MAX_HEURISTIC,"search-max-heuristic"},
tlparse.c:	{STRING_RESET_SEARCH_DEPTH_LIMIT,"reset-search-depth-limit"},
tlparse.c:	{STRING_RESET_SEARCH_HEURISTIC_LIMIT,"reset-search-heuristic-limit"},
tlparse.c:	{STRING_GET_CPU_TIME,"get-cpu-time"},
tlparse.c:	{STRING_HEURISTIC_FN,"heuristic-fn"},
tlparse.c:	{STRING_SET_GOAL_ADDENDUM,"set-goal-addendum"},
tlparse.c:	{STRING_RESET_GOAL_ADDENDUM,"reset-goal-addendum"},
tlparse.c:	{STRING_GET_PLAN_NAME,"get-plan-name"},
tlparse.c:	{STRING_RESET_PLAN_NAME,"reset-plan-name"},
tlparse.c:	{STRING_MODIFY_WORLD,"modify-world"},
tlparse.c:	{STRING_USER_ABORT,"user-abort"},
tlparse.c:	{STRING_CYCLE_CHECKING,"cycle-checking"},
tlparse.c:	{STRING_TIMING_STATISTICS,"timing-statistics"},
tlparse.c:	{STRING_NO_CYCLE_CHECK,"no-cycle-check"},
tlparse.c:	{STRING_IN_THE_SET,"in-the-set"},
tlparse.c:	{STRING_PRUNING_ALL_SUCCESSORS,"pruning-all-successors"},
tlparse.c:	{STRING_CONCURRENT_PLANNING,"concurrent-planning"},
tlparse.c:	{STRING_WAIT_FOR_NEXT_EVENT,"wait-for-next-event"},
tlparse.c:	{STRING_DELAYED_ACTION,"delayed-action"},
tlparse.c:	{STRING_GLOBAL_DELAYED_ACTION,"global-delayed-action"},
tlparse.c:	{STRING_LOAD_PLAN,"load-plan"},
tlparse.c:	{STRING_MAKE_LITERAL,"make-literal"},
tlparse.c:	{STRING_SET_GOAL_SEQUENCE,"set-goal-sequence"},
tlparse.c:	{STRING_SET_GOAL_FORMULA,"set-goal-formula"},
tlparse.c:	{STRING_CURRENT_TIME,"current-time"},
tlparse.c:	{STRING_INHIBIT_DELAYED_ACTION,"inhibit-delayed-action"},
tlparse.c:	{STRING_MINUS_EQ,"-="},
tlparse.c:	{STRING_PRINT_DELTA_TIME,"print-delta-time"},
tlparse.c:	{STRING_PDDL_SUPPORT,"pddl-support"},
tlparse.c:	{STRING_DECLARE_MACRO_OPERATORS,"declare-macro-operators"},
tlparse.c:	{STRING_CLEAR_OPERATORS,"clear-operators"},
tlparse.c:	{STRING_NEAREST_FIRST,"nearest-first"},
tlparse.c:	{STRING_DECLARE_ELIDED_OPERATORS,"declare-elided-operators"},
tlparse.c:	{STRING_LOAD_PDDL_PROBLEM,"load-pddl-problem"},
tlparse.c:	{STRING_CLEAR_EVENT_QUEUE,"clear-event-queue"},
tlparse.c:	{STRING_CLOSEST_FIRST,"closest-first"},
tlparse.c:	{STRING_UPDATE_WORLD,"update-world"},
tlparse.c:	{STRING_LOWEST_FIRST,"lowest-first"},
tlparse.c:	{STRING_PRINT_PDDL_PLAN,"print-pddl-plan"},
tlparse.c:	{STRING_REACHABLE_EVENT,"reachable-event"},
tlparse.c:	{STRING_ALL_PAIRS_SHORTEST_PATH,"all-pairs-shortest-path"},
tlparse.c:	{STRING_NEAREST_FIRST_EX,"nearest-first-ex"},
tlparse.c:	{STRING_CLOSEST_FIRST_EX,"closest-first-ex"},
tlparse.c:	{STRING_CONDITIONAL_EXP,"conditional-exp"},
tlparse.c:	{STRING_GOAL_DISTANCE,"goal-distance"}
tlparse.c:/* global data ----------------------------------------------------------------- */
tlparse.c:/* InitPlanner -----------------------------------------------------------------
tlparse.c:	if(plCommand->nType!=ATOM_LISTP)
tlparse.c:	pl=plCommand->uValue.plList;
tlparse.c:			if(pcCurrentCommand->pfForm->paAction->pfEval!=NoEvaluator)
tlparse.c:				bStatus=(*pcCurrentCommand->pfForm->paAction->pfEval)
tlparse.c:			else if(pcCurrentCommand->pfForm->paAction->pfCompute!=NoComputor)
tlparse.c:				pc=(*pcCurrentCommand->pfForm->paAction->pfCompute)
tlparse.c:			else /* if(pcCurrentCommand->pfForm->paAction==&aDummyAction) */
tlparse.c:				ErrorMessage("ExecuteList: Unknown command %s\n",pl->psName);
tlparse.c:	if(plCommand->nType!=ATOM_LISTP)
tlparse.c:	psSymbol->psName=StrAlloc(psName);
tlparse.c:	psSymbol->nType=nType;
tlparse.c:			psSymbol->uValue.psString=psName;
tlparse.c:			psSymbol->uValue.nInteger=(int)pvValue;
tlparse.c:			psSymbol->uValue.plList=(LISTP)pvValue;
tlparse.c:			psSymbol->uValue.pbtTree=(BTREEP)pvValue;
tlparse.c:			psSymbol->uValue.pfFunction=(CELLP(*)(CELLP))pvValue;
tlparse.c:			psSymbol->uValue.psiSymbolInfo=(SYMBOLINFOP)pvValue;
tlparse.c:			psSymbol->uValue.pcFormula=(CELLP)pvValue;
tlparse.c:	for(i=0;i<nMaxSize-1;i++)
tlparse.c:	nLength=ps-psBuf;
tlparse.c://		ps=(char *)MemAlloc(nLength-1);
tlparse.c://	pc->pfForm=(FORMULAP)MemAlloc(sizeof(FORMULA));
tlparse.c://	pc->pfForm->nType=nType;
tlparse.c://	pc->pfForm->psName=ps;
tlparse.c://				pc->pfForm->uValue=psSymbol->uValue;
tlparse.c://				pc->pfForm->nType=psSymbol->nType;
tlparse.c://				pc->pfForm->nType=ATOM_IDENT;
tlparse.c://			pc->pfForm->uValue.nInteger=atoi(ps);
tlparse.c://			pc->pfForm->uValue.dfFloat=atof(ps);
tlparse.c://			pc->pfForm->uValue.psString=ps;
tlparse.c://			pc->pfForm->uValue.pcFormula=va_arg(pa,CELLP);
tlparse.c:///*	pf->nColumn=TabColumn(yysol,yytext-yysol)+(nType==ATOM_STRING?1:0); */
tlparse.c:/* Local Functions ------------------------------------------------------------- */
tlparse.c://			i+=TABSIZE-(i%TABSIZE);
tlparse.c:						*pd=*(ps-1);
tlparse.c:// Command Window Interface ----------------------------------------------------
tlparse.c:		LoadFile((char *)-1);			/* windows interpreter */
tlplan.c:Copyright C, 1997 - 2001, F. Bacchus
tl_tab.c:/* tl_tab.c -- tlplanner parser
tl_tab.c:#define	YYFLAG		-32768
tl_tab.c:static const short yypact[] = {-32768,
tl_tab.c:     9,-32768,-32768,-32768,    -1,-32768,-32768,-32768,-32768,-32768,
tl_tab.c:    11,    11,-32768,-32768,-32768,-32768,-32768,-32768,   -22,   -17,
tl_tab.c:     7,     7,-32768,-32768,-32768,     8,    12,-32768,-32768,-32768,
tl_tab.c:-32768,    13,    17,-32768
tl_tab.c:static const short yypgoto[] = {-32768,
tl_tab.c:-32768,    19,-32768,-32768,-32768,    14,     3
tl_tab.c:    21,     7,     8,     9,    10,    22,    11,    12,    -1,     2,
tl_tab.c:    22,    10,    11,     5,    22,    12,    -1,    -1,    -1,    21
tl_tab.c:/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
tl_tab.c:/* This file comes from bison-1.28.  */
tl_tab.c:   Foundation, Inc., 59 Temple Place - Suite 330,
tl_tab.c:   Boston, MA 02111-1307, USA.  */
tl_tab.c:#define YYEMPTY		-2
tl_tab.c:    (effective only if the built-in stack extension method is used).  */
tl_tab.c:   should be passed with type unsigned int, because that is what the non-GCC
tl_tab.c:   in available built-in functions on various systems.  */
tl_tab.c:  while (i-- > 0)
tl_tab.c://   in available built-in functions on various systems.  */
tl_tab.c://  while (i-- > 0)
tl_tab.c:/* Prevent warning if -Wstrict-prototypes.  */
tl_tab.c:#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
tl_tab.c:#define YYPOPSTACK   (yyvsp--, yyssp--)
tl_tab.c:  yyssp = yyss - 1;
tl_tab.c:  if (yyssp >= yyss + yystacksize - 1)
tl_tab.c:      int size = yyssp - yyss + 1;
tl_tab.c:      yyssp = yyss + size - 1;
tl_tab.c:      yyvsp = yyvs + size - 1;
tl_tab.c:      yylsp = yyls + size - 1;
tl_tab.c:      if (yyssp >= yyss + yystacksize - 1)
tl_tab.c:     Negative => reduce, -yyn is rule number.
tl_tab.c:      yyn = -yyn;
tl_tab.c:  if (yyerrstatus) yyerrstatus--;
tl_tab.c:    yyval = yyvsp[1-yylen]; /* implement default value of the action */
tl_tab.c:      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
tl_tab.c:		yyval=NewList(ATOM_LISTP,"",yyvsp[-1]);
tl_tab.c:		if(!yyvsp[-1])
tl_tab.c:			for(pl=yyvsp[-1];pl->plNext;pl=pl->plNext);	/* find last element */
tl_tab.c:			pl->plNext=yyvsp[0];				/* append next element to list */
tl_tab.c:			yyval=yyvsp[-1];
tl_tab.c:		ErrorMessage("Parsed list_elements, added %s\n",yyvsp[0]->psName);
tl_tab.c:		ErrorMessage("Parsed list_element %s\n",yyvsp[0]->psName);
tl_tab.c:		yyval=yyvsp[0];							/* non-empty list element */
tl_tab.c:		ErrorMessage("Parsed list_element %s\n",yyvsp[0]->psName);
tl_tab.c:		yyval=yyvsp[0];							/* non-empty list element */
tl_tab.c:		ErrorMessage("Parsed list_element %s\n",yyvsp[0]->psName);
tl_tab.c:		yyval=yyvsp[0];							/* non-empty list element */
tl_tab.c:		ErrorMessage("Parsed list_element %s\n",yyvsp[0]->psName);
tl_tab.c:		yyval=yyvsp[0];							/* non-empty list element */
tl_tab.c:		ErrorMessage("Parsed list_element %s\n",yyvsp[0]->psName);
tl_tab.c:		yyval=yyvsp[0];							/* non-empty list element */
tl_tab.c:		ErrorMessage("Parsed list_element %s\n",yyvsp[0]->psName);
tl_tab.c:		yyval=yyvsp[0];							/* non-empty list element */
tl_tab.c:		pl->plNext=yyvsp[-4];					/* link tokens */
tl_tab.c:		yyvsp[-4]->plNext=yyvsp[-3];
tl_tab.c:		yyvsp[-3]->plNext=yyvsp[-1];
tl_tab.c:		yyvsp[-1]->plNext=yyvsp[0];
tl_tab.c:		pl->plNext=yyvsp[-4];					/* link tokens */
tl_tab.c:		yyvsp[-4]->plNext=yyvsp[-3];
tl_tab.c:		yyvsp[-3]->plNext=yyvsp[-1];
tl_tab.c:		yyvsp[-1]->plNext=yyvsp[0];
tl_tab.c:		pl->plNext=yyvsp[-4];					/* link tokens */
tl_tab.c:		yyvsp[-4]->plNext=yyvsp[-3];
tl_tab.c:		yyvsp[-3]->plNext=yyvsp[-1];
tl_tab.c:		yyvsp[-1]->plNext=yyvsp[0];
tl_tab.c:		pl->plNext=yyvsp[-4];					/* link tokens */
tl_tab.c:		yyvsp[-4]->plNext=yyvsp[-3];
tl_tab.c:		yyvsp[-3]->plNext=yyvsp[-1];
tl_tab.c:		yyvsp[-1]->plNext=yyvsp[0];
tl_tab.c:  yyvsp -= yylen;
tl_tab.c:  yyssp -= yylen;
tl_tab.c:  yylsp -= yylen;
tl_tab.c:      short *ssp1 = yyss - 1;
tl_tab.c:      yylsp->first_line = yylloc.first_line;
tl_tab.c:      yylsp->first_column = yylloc.first_column;
tl_tab.c:      yylsp->last_line = (yylsp-1)->last_line;
tl_tab.c:      yylsp->last_column = (yylsp-1)->last_column;
tl_tab.c:      yylsp->text = 0;
tl_tab.c:      yylsp->last_line = (yylsp+yylen-1)->last_line;
tl_tab.c:      yylsp->last_column = (yylsp+yylen-1)->last_column;
tl_tab.c:  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
tl_tab.c:    yystate = yydefgoto[yyn - YYNTBASE];
tl_tab.c:	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
tl_tab.c:	  for (x = (yyn < 0 ? -yyn : 0);
tl_tab.c:		  for (x = (yyn < 0 ? -yyn : 0);
tl_tab.c:  yyvsp--;
tl_tab.c:  yystate = *--yyssp;
tl_tab.c:  yylsp--;
tl_tab.c:      short *ssp1 = yyss - 1;
tl_tab.c:      yyn = -yyn;
user.c:/* user.c -- support for user library routines
user.c:Copyright 1997 - 99, Fahiem Bacchus
user.c:	program exit or by a call to (clear-world-symbols).
user.c:		ErrorMessage("declare-external-symbols:  Failed to load library %s\n",acPath);
user.c:		ErrorMessage("declare-external-symbols:  Failed to load library %s\n",psPath);
user.c:	plLib->psPath=StrAlloc(psPath);
user.c:	plLib->nHandle=*nHandle;
user.c:	plLib->plNext=plLibList;			/* link to library list */
user.c:		pl2=pl1->plNext;
user.c:		 FreeLibrary((HINSTANCE)pl1->nHandle);
user.c:		if(dlclose((void *)pl1->nHandle))
user.c:			ErrorMessage("CloseLibrary:  Failed to close library %s\n",pl1->psPath);
user.c://		ZoneFree(pl1->psPath);
user.c:	for(pl=plLibList;pl;pl=pl->plNext)
util.c:/* util.c -- utility functions.
util.c:Copyright C, 1996 - 99  F. Bacchus
util.c:calculate the unbiased standard deviation (i.e. divide by n-1, not n)
util.c:multiply by the student's t value for n-1 degrees of freedom, at 1-2a
util.c:static int iFib=16;						/* fibonacci lag -1 */
util.c:static int jFib=4;						/* fibonacci lag -1 */
util.c:/* Autodin II CRC (CRC-32) */
util.c:	for(pb=pbBindings;pb;pb=pb->pbNext)
util.c:		Message("\t%s=%s\n",GetName(pb->pcVar->pfForm,ac),GetName(pb->pcVal->pfForm,ac));
util.c:	On non-Windows systems, the default time calculation assumes a Linux, Solaris
util.c:	return (*(unsigned char *)s1<*(unsigned char *)s2)?-1:1;
util.c:			*ps+='a'-'A';
util.c:	~A -- print string or symbol name (@,n optional)
util.c:	~D -- print decimal integer (no options)
util.c:	~F -- print float (d,w optional)
util.c:	~S -- print string or symbol name (@,n optional)
util.c:	~T -- tab stop (n,r optional)
util.c:	~% -- newline
util.c:	~~ -- tilde
util.c:						TermError("eval-print: ~A",pcArgs,pbBindings);
util.c:					pcArgs=pcArgs->pcNext;
util.c:							sprintf(ps1,"%*s",nOpt1,GetName(pc->pfForm,ac));
util.c:							sprintf(ps1,"%*s",-nOpt1,GetName(pc->pfForm,ac));
util.c:						strcpy(ps1,GetName(pc->pfForm,ac));
util.c:						ErrorMessage("print:  Non-numeric argument to %.*s format specifier.\n%s\n",
util.c:							ps2-ps4,ps4,psFormat);
util.c:					pcArgs=pcArgs->pcNext;
util.c:						ErrorMessage("print:  Non-numeric argument to %.*s format specifier.\n%s\n",
util.c:							ps2-ps4,ps4,psFormat);
util.c:					pcArgs=pcArgs->pcNext;
util.c:					n=ps1-psBuffer;
util.c:						ps4=psBuffer+nOpt1+(n-nOpt1+nOpt2)/nOpt2;
util.c:						ps2-ps4,ps4,psFormat);
util.c:/* Random Number Routines ------------------------------------------------------ */
util.c:	anFibCoef[iFib]-=anFibCoef[jFib];
util.c:	if(--iFib<0)
util.c:	if(--jFib<0)
util.c:	nValue-=nFibSeed;
var.c:Copyright C, 1996 - 2001	F. Bacchus
var.c:  (and (symbol? x) (char-ci=? (string-ref (symbol->string x) 0) #\?)))
var.c:	return !pcVar->pfForm->pcArgs&&*GetName(pcVar->pfForm,ac)=='?';
var.c:(define (variables-in exp)
var.c:	(else (union (variables-in (first exp))
var.c:			 (variables-in (rest exp))))))
var.c:	for(pc1=pcList;pc1;pc1=pc1->pcNext)
var.c:				pc2->pcNext=pcResult;
var.c:		else if(pc1->pfForm->pcArgs)
var.c:			pcResult=FormulaUnion(VariablesIn(pc1->pfForm->pcArgs),pcResult);
var.c:(define (not-occurs? var exp)
var.c:	 (and (not-occurs? var (first exp))
var.c:		  (not-occurs? var (rest exp))))
var.c:	for(pc=pcList;pc;pc=pc->pcNext)
var.c:		if(StringEqQ(IdentName(pcVar->pfForm),IdentName(pc->pfForm)))
var.c:(define (variable-free? exp)
var.c:	(else (and (variable-free? (first exp))
var.c:		   (variable-free? (rest exp))))))
var.c:	for(pc=pcFormula->pfForm->pcArgs;pc;pc=pc->pcNext)
var.c:		if(pc->pfForm->pcArgs)
world.c:Copyright C, 1996 - 2001  F. Bacchus
world.c:----------------------------------------------------------------------
world.c:(define (make-world )
world.c:  (do ((world (make-vector *number-of-described-symbols*))
world.c:	  ((=  i *number-of-described-symbols*) world)
world.c:	(vector-set! world i (cons '() 0))))
world.c:(define (copy-world world)
world.c:  (do ((new-world (make-world))
world.c:	  ((>= i *number-of-described-symbols*) new-world)
world.c:	(put-symbol-args new-world i (get-symbol-args world i))
world.c:	(put-symbol-args-# new-world i (get-symbol-args-# world i))))
world.c:/* -----------------------------------------------------------------------------
world.c:(define (create-world description)
world.c:	(do ((world (make-world))
world.c:		(if (fn-lit? lit)
world.c:			(set! index (get-symbol-index (get-fn-name lit)))
world.c:			(set! index (get-symbol-index (get-operator lit))))
world.c:					(not (search-arg-tree (get-args lit)
world.c:							(get-symbol-args world index))))
world.c:				(put-symbol-args
world.c:					(insert-arg-tree world
world.c:						(get-args lit)
world.c:						(get-symbol-args world index)
world.c:				(incr-symbol-args-# world index))
world.c:			((fn-lit? lit)
world.c:						(search-arg-tree (get-fn-args lit)
world.c:							(get-symbol-args world index)))
world.c:					(incr-symbol-args-# world index))
world.c:				(put-symbol-args
world.c:					(insert-arg-tree world
world.c:						(get-fn-args lit)
world.c:						(get-symbol-args world index)
world.c:						(get-fn-value lit)))))))
world.c://	for(pcLit=pcDescription;pcLit;pcLit=pcLit->pcNext)
world.c://			pc=pcLit->pfForm->pcArgs;
world.c://			psiSymbolInfo=GetSymbolInfoPtr(GetName(pc->pfForm,ac));
world.c://					GetName(pc->pfForm,ac));
world.c://				nIndex=psiSymbolInfo-asiWorldSymbols;
world.c://					pc->pfForm->pcArgs,GetSymbolArgs(apbtWorld,nIndex),pc->pcNext));
world.c://			psiSymbolInfo=GetSymbolInfoPtr(GetName(pcLit->pfForm,ac));
world.c://						GetName(pcLit->pfForm,ac));
world.c://					nIndex=psiSymbolInfo-asiWorldSymbols;
world.c://					if(!BTreeSearch(pcLit->pfForm->pcArgs,GetSymbolArgs(apbtWorld,nIndex)))
world.c://							pcLit->pfForm->pcArgs,GetSymbolArgs(apbtWorld,nIndex),NULL));
world.c://					GetName(pcLit->pfForm,ac));
world.c:/* MakeWorldAction -------------------------------------------------------------
world.c:(define (make-world/action world action-name action-duration action-cost
world.c:			   action-priority)
world.c:	  world action-name action-duration action-cost action-priority))
world.c:	plp->apbtWorld=apbtWorld;
world.c:	plp->pcActionName=pcActionName;
world.c:	plp->dfActionDuration=dfActionDuration;
world.c:	plp->dfActionCost=dfActionCost;
world.c:	plp->dfActionPriority=dfActionPriority;
world.c:	plp->nWorldNumber=nWorldNumber++;
world.c:		ErrorMessage("print-world:  Invalid file handle, %d\n",nFile);
world.c:	for(pcMod=pcDescription;pcMod;pcMod=pcMod->pcNext)
world.c:		if(!(*pcMod->pfForm->paAction->pfEval)(pcMod,plpLinearPlan,pbBindings))
world.c://	dfTime=GetInternalRunTime()-dfTime;
world.c:	for(pcMod=pcInitializationSequence;pcMod;pcMod=pcMod->pcNext)
world.c:			plpLinearPlan->apbtWorld[i]=BTreeBalance(plpLinearPlan->apbtWorld[i]);
world.c:		(*pcMod->pfForm->paAction->pfEval)(pcMod,plpLinearPlan,pbBindings);
world.c://		dfTime=GetInternalRunTime()-dfTime;
world.c://		dfTime=GetInternalRunTime()-dfTime;
world.c:	apbtNewWorld=CopyWorld(plpLinearPlan->apbtWorld);	/* copy initial world */
world.c:	plpLinearPlan->apbtWorld=apbtNewWorld;	/* discard old world database */
world.c:	for(pcMod=pcInitializationSequence;pcMod;pcMod=pcMod->pcNext)
world.c:		(*pcMod->pfForm->paAction->pfEval)(pcMod,plpLinearPlan,pbBindings);
world.c:	for(pcMod=pcDescription;pcMod;pcMod=pcMod->pcNext)
world.c:		if(!(*pcMod->pfForm->paAction->pfEval)(pcMod,plpLinearPlan,pbBindings))
world.c:	for(pcMod=pcGoalSequence;pcMod;pcMod=pcMod->pcNext)
world.c:		(*pcMod->pfForm->paAction->pfEval)(pcMod,plpLinearPlan,pbBindings);
world.c:(define (create-goal-world/action goal-list)
world.c:  (set! goal-world
world.c:	(make-world/action (create-world goal-list)
world.c://		plpGoalWorld->apbtWorld[i]=BTreeBalance(plpGoalWorld->apbtWorld[i]);
world.c:(define (get-goal-world )
world.c:  goal-world)
world.c:(define (default-print-world world/action . optional-args)
world.c:  (do ((world (world/action-world world/action))
world.c:	   (stream (if (null? optional-args)
world.c:		   *trace-stream*
world.c:		   (first optional-args))))
world.c:	  ((>= i *number-of-described-symbols*))
world.c:		(get-symbol-name i) (get-symbol-args-# world i)
world.c:		(arg-tree-to-list (get-symbol-name i)
world.c:				  (get-symbol-args world i)))))
world.c:		pcVar=pcPrintWorld->pfForm->pcArgs;
world.c:		if(!(*pcPrintWorld->pfForm->paAction->pfEval)(pcPrintWorld,plpLinearPlan,pb))
world.c:			ErrorMessage("print-world:  Print routine %s terminated abnormally\n",
world.c:				GetName(pcPrintWorld->pfForm,ac));
world.c:		ErrorMessage("print-world:  Invalid file handle, %d\n",nFile);
world.c:/* -----------------------------------------------------------------------------
world.c:(define (insert-arg-tree owner new-arg arg-tree value)
world.c:	  (tree-insert owner
world.c:		   (make-b-tree new-arg value '() '() owner)
world.c:		   arg-tree)
world.c:	  (tree-insert owner
world.c:		   (make-b-tree new-arg '() '() '() owner)
world.c:		   arg-tree)))
world.c:(define (delete-arg-tree owner arg arg-tree)
world.c:  (tree-delete owner arg arg-tree))
world.c:(define (search-arg-tree arg arg-tree)
world.c:  (if (tree-search arg arg-tree) #t #f))
world.c:(define (find-value-arg-tree arg arg-tree)
world.c:  (let ((node (tree-search arg arg-tree)))
world.c:	(if node (b-tree-value node) *no-value*)))
world.c:	pc=pbtNode?pbtNode->pcValue:NULL;
world.c:(define (arg-tree-to-list symbol-name arg-tree)
world.c:	(tree-to-list arg-tree
world.c:		(lambda (b-tree-node)
world.c:			(if (b-tree-value b-tree-node)
world.c:					(cons symbol-name (b-tree-key b-tree-node))
world.c:					(b-tree-value b-tree-node))
world.c:				(cons symbol-name (b-tree-key b-tree-node))))))
world.c:	pcKey=pbtNode->pcKey;
world.c:		for(pc=pcKey;pc;pc=pc->pcNext)
world.c:			plEnd=plEnd->plNext=NewList(ATOM_IDENT,GetName(pc->pfForm,ac));
world.c:	pcValue=pbtNode->pcValue;
world.c:		plEnd=NewList(ATOM_IDENT,GetName(pcSymbol->pfForm,ac));
world.c:		plEnd->plNext=plStart;
world.c:			NewList(pcValue->pfForm->nType,GetName(pcValue->pfForm,ac))));
world.c:		pl=Cons(NewList(ATOM_IDENT,GetName(pcSymbol->pfForm,ac)),plStart);
world.c:		pl=NewList(ATOM_LISTP,"",NewList(ATOM_IDENT,GetName(pcSymbol->pfForm,ac)));
world.c:	fSymbol.psName=psi->psName;			/* fill in symbol name */
world.c:	fSymbol.paAction=psi->paAction;
world.c:	pcKey->pfForm->pcArgs=pbtNode->pcKey;
world.c:	pcValue=pbtNode->pcValue;
world.c:/* -----------------------------------------------------------------------------
world.c:	((or (>= i *number-of-described-symbols*) found?)
world.c:	  (set! found? (not (= (get-symbol-args-# world1 i)
world.c:			   (get-symbol-args-# world2 i)))))
world.c:	((or (>= i *number-of-described-symbols*) found?)
world.c:	  (set! found? (not (tree= (get-symbol-args world1 i)
world.c:				   (get-symbol-args world2 i)))))
world.c:	if(plpPlan1->nSignature!=plpPlan2->nSignature)
world.c://				plpPlan1->nWorldNumber,plpPlan2->nWorldNumber);
world.c://		if(plpPlan1->nSignature!=plpPlan2->nSignature)
world.c://			if(plpPlan1->nSignature==plpPlan2->nSignature)
world.c://	if(plpPlan1->nSignature!=plpPlan2->nSignature)
world.c:/* Signature routines ------------------------------------------------------- */
world.c:	Calculate a signature longword for a world.  We calculate a CRC-32 value
world.c:	nCRC=-1;							/* initial seed is -1 */
world.c:	plpPlan->nSignature=~nCRC;			/* the result is complemented */
world.c:	The tree is traversed "in-order".
world.c://	for(pbt=pbtTree;pbt;pbt=pbt->pbtLeft)
world.c://		nCRC=FormulaListSignature(nCRC,pbtCurrent->pcKey);
world.c://		if(pbtCurrent->pcValue)
world.c://			nCRC=FormulaSignature(nCRC,pbtCurrent->pcValue);
world.c://		for(pbt=pbtCurrent->pbtRight;pbt;pbt=pbt->pbtLeft)
world.c:	The tree is traversed "in-order".
world.c:	if(pbtTree->pbtLeft)
world.c:		nCRC=BTreeSignatureR(nCRC,pbtTree->pbtLeft);
world.c:	nCRC=FormulaListSignature(nCRC,pbtTree->pcKey);
world.c:	if(pbtTree->pcValue)
world.c:		nCRC=FormulaSignature(nCRC,pbtTree->pcValue);
world.c:	if(pbtTree->pbtRight)
world.c:		nCRC=BTreeSignatureR(nCRC,pbtTree->pbtRight);
world.c:	The tree is traversed "in-order".
world.c:	It is non-reentrant, but quite fast.
world.c://	for(pbt=pbtTree;pbt;pbt=pbt->pbtLeft)
world.c://		pbt->pbtNext=pbtContext;
world.c://		pbtContext=pbtContext->pbtNext;		
world.c://		if(pbtCurrent->pbtRight)
world.c://			pbt=pbtCurrent->pbtRight;
world.c://			pbt->pbtNext=pbtContext;
world.c://			for(pbt=pbt->pbtLeft;pbt;pbt=pbt->pbtLeft)
world.c://				pbt->pbtNext=pbtContext;
world.c://		nCRC=FormulaListSignature(nCRC,pbtCurrent->pcKey);
world.c://		if(pbtCurrent->pcValue)
world.c://			nCRC=FormulaSignature(nCRC,pbtCurrent->pcValue);
world.c:	The tree is traversed "in-order".
world.c://	pbtcNode->pbtcNext=NULL;
world.c://	pbtcNode->pbtTree=pbtTree;
world.c://	for(pbt=pbtTree;pbt->pbtLeft;pbt=pbt->pbtLeft)
world.c://		pbtcNode->pbtcNext=pbtcStack;
world.c://		pbtcNode->pbtTree=pbt->pbtLeft;
world.c://		pbtCurrent=pbtc->pbtTree;			/* pop the next node from the stack */
world.c://		pbtcStack=pbtc->pbtcNext;
world.c://		if(pbtCurrent->pbtRight)
world.c://			pbtcNode->pbtcNext=pbtcStack;
world.c://			pbtcNode->pbtTree=pbtCurrent->pbtRight;
world.c://			for(pbt=pbtCurrent->pbtRight;pbt->pbtLeft;pbt=pbt->pbtLeft)
world.c://				pbtcNode->pbtcNext=pbtcStack;
world.c://				pbtcNode->pbtTree=pbt->pbtLeft;
world.c://		nCRC=FormulaListSignature(nCRC,pbtCurrent->pcKey);
world.c://		if(pbtCurrent->pcValue)
world.c://			nCRC=FormulaSignature(nCRC,pbtCurrent->pcValue);
world.c:	for(pc=pcFormula;pc;pc=pc->pcNext)
world.c:	if(pcFormula->pfForm->nType==ATOM_INTEGER)
world.c:		df=(double)pcFormula->pfForm->uValue.nInteger;
world.c:	if(pcFormula->pfForm->nType==ATOM_FLOAT)
world.c:		n=CRC32((unsigned char *)&pcFormula->pfForm->uValue.dfFloat,sizeof(double),n);
world.c:	ps=GetName(pcFormula->pfForm,ac);
world.c:	if(pcFormula->pfForm->pcVars)
world.c:		n=FormulaListSignature(n,pcFormula->pfForm->pcVars);
world.c:	if(pcFormula->pfForm->pcGenLit)
world.c:		n=FormulaListSignature(n,pcFormula->pfForm->pcGenLit);
world.c:	if(pcFormula->pfForm->pcArgs)
world.c:		n=FormulaListSignature(n,pcFormula->pfForm->pcArgs);
world.c:/* Actions interface ----------------------------------------------------------- */
world.c:(define (add-world-lit pred-sym args world)
world.c:	(let ((arg-tree '())
world.c:		(set! index (get-symbol-index pred-sym))
world.c:		(set! arg-tree (get-symbol-args world index))
world.c:		(if (not (search-arg-tree args arg-tree))
world.c:				(put-symbol-args
world.c:					world index (insert-arg-tree world args arg-tree '()))
world.c:				(incr-symbol-args-# world index)))
world.c:	for(pc1=pcFormula->pfForm->pcArgs;pc1;pc1=pc1->pcNext)
world.c:			pc=pc1->pfForm->pcArgs;
world.c:			pcValue=ComputeTerm(pc->pcNext,plpLinearPlan,pbBindings);
world.c:				TermError("eval-add",pc->pcNext,pbBindings);
world.c:			pc=pc1->pfForm->pcArgs;
world.c:				TermError("eval-add",pc,pbBindings);
world.c:			pcTerm2=ComputeTerm(pc->pcNext,plpLinearPlan,pbBindings);
world.c:				TermError("eval-add",pc->pcNext,pbBindings);
world.c:			pcTerm1->pcNext=pcTerm2;
world.c:			pc=pc1->pfForm->pcArgs;
world.c:				TermError("eval-add",pc,pbBindings);
world.c:			pcTerm2=ComputeTerm(pc->pcNext,plpLinearPlan,pbBindings);
world.c:				TermError("eval-add",pc->pcNext,pbBindings);
world.c:			pcTerm1->pcNext=pcTerm2;
world.c:		if(pc->pfForm->nType!=ATOM_SYMBOLINFOP)
world.c:			ErrorMessage("eval-add:  Not a symbol, \"%s\" ignored\n",
world.c:				GetName(pc->pfForm,ac));
world.c:		psiSymbolInfo=pc->pfForm->uValue.psiSymbolInfo;
world.c:		nIndex=psiSymbolInfo-asiWorldSymbols;
world.c:			ErrorMessage("eval-add:  Not a described symbol, \"%s\" ignored\n",
world.c:				GetName(pc->pfForm,ac));
world.c:		if(pc->pfForm->pcArgs)
world.c:			pcArgs=ComputeTerms(pc->pfForm->pcArgs,plpLinearPlan,pbBindings);
world.c:				TermError("eval-add",pcFormula,pbBindings);
world.c:		pc2->pfForm=(FORMULAP)CopyAlloc(pc1->pfForm,sizeof(FORMULA));
world.c:			pc3->pfForm=(FORMULAP)CopyAlloc(pc->pfForm,sizeof(FORMULA));
world.c:			pc3->pfForm->pcArgs=pcArgs;
world.c:			pc3->pcNext=pcValue;
world.c:			pc2->pfForm->pcArgs=pc3;
world.c:			pc2->pfForm->pcArgs=pcArgs;
world.c:		pcAddEnd=pcAddEnd->pcNext=pc2;
world.c:(define (delete-world-lit pred-sym args world)
world.c:  (let ((arg-tree '())
world.c:	(set! index (get-symbol-index pred-sym))
world.c:	(set! arg-tree (get-symbol-args world index))
world.c:	(if (search-arg-tree args arg-tree)
world.c:	(begin (put-symbol-args
world.c:		world index (delete-arg-tree world args arg-tree))
world.c:		   (decr-symbol-args-# world index)))
world.c:	for(pc1=pcFormula->pfForm->pcArgs;pc1;pc1=pc1->pcNext)
world.c:			pc=pc1->pfForm->pcArgs;
world.c:			Message("eval-del:  Cannot delete a function symbol, \"%s\" ignored.\n",
world.c:				GetName(pc->pfForm,ac));
world.c:		if(pc->pfForm->nType!=ATOM_SYMBOLINFOP)
world.c:			ErrorMessage("eval-del:  Not a symbol, \"%s\" ignored\n",
world.c:				GetName(pc->pfForm,ac));
world.c:		psiSymbolInfo=pc->pfForm->uValue.psiSymbolInfo;
world.c:		nIndex=psiSymbolInfo-asiWorldSymbols;
world.c:			ErrorMessage("eval-del:  Not a described symbol, \"%s\" ignored\n",
world.c:				GetName(pc->pfForm,ac));
world.c:		if(pc->pfForm->pcArgs)
world.c:			pcArgs=ComputeTerms(pc->pfForm->pcArgs,plpLinearPlan,pbBindings);
world.c:				TermError("eval-del",pcFormula,pbBindings);
world.c:		pc2->pfForm=(FORMULAP)CopyAlloc(pc1->pfForm,sizeof(FORMULA));
world.c:		pc2->pfForm->pcArgs=pcArgs;
world.c:		pcDelEnd=pcDelEnd->pcNext=pc2;
world.c://	for(pc=pcList;pc;pc=pc->pcNext)
world.c://	for(i=nLength;i>0;i--)
world.c://		nRand=(MSRandx()%i)-1;			/* generate random index */
world.c://			pc1=pc1->pcNext;
world.c://		pcEnd=pcEnd->pcNext=pc1->pcNext;	/* transfer to other list */
world.c://		if(pc1->pcNext)
world.c://			pc1->pcNext=pc1->pcNext->pcNext;
world.c://	pcEnd->pcNext=NULL;					/* terminate list */
world.c:	for(pc=pcList;pc;pc=pc->pcNext)
world.c:	for(pc=pcList;pc;pc=pc->pcNext)
world.c:	for(i=nLength;i>0;i--)
world.c:		ppcArray[nRand]=ppcArray[i-1];	/* more penultimate pointer to random location */
world.c:		pcEnd=pcEnd->pcNext=ppcArray[i];	/* transfer permuted cell to new list */
world.c:	pcEnd->pcNext=NULL;					/* terminate list */
world.c:	for(pc=pcDel;pc;pc=pc->pcNext)
world.c:		psiSymbolInfo=pc->pfForm->uValue.psiSymbolInfo;
world.c:		nIndex=psiSymbolInfo-asiWorldSymbols;
world.c:		pcArgs=pc->pfForm->pcArgs;
world.c:			Message("eval-del:  Deleting nonexistant symbol \"%s\" in world %d\n",
world.c:				GetName(pc->pfForm,ac),plpSuccessorWorld->nWorldNumber);
world.c:	for(pc1=pcAdd;pc1;pc1=pc1->pcNext)
world.c:			pc=pc1->pfForm->pcArgs;
world.c:			pcValue=pc->pcNext;			/* += and -= have already been taken care of */
world.c:		psiSymbolInfo=pc->pfForm->uValue.psiSymbolInfo;
world.c:			Message("eval-del:  Cannot add non-described symbol \"%s\", addition ignored.\n",
world.c:				GetName(pc->pfForm,ac));
world.c:		nIndex=psiSymbolInfo-asiWorldSymbols;
world.c:		pcArgs=pc->pfForm->pcArgs;
world.c://			if(PredicateQ(psiSymbolInfo)&&!psiSymbolInfo->bRewritable)
world.c://				Message("eval-add:  Rewriting predicate symbol \"%s\"\n",
world.c://					GetName(pc->pfForm,ac));
world.c:			if (PredicateQ(psiSymbolInfo)&&!psiSymbolInfo->bRewritable && aDelAction.pfEval!=EvalNODel )
world.c:				Message("eval-add:  Rewriting predicate symbol \"%s\" in world %d\n",
world.c:					GetName(pc->pfForm,ac),plpSuccessorWorld->nWorldNumber);
world.c:/* Evaluator interface ---------------------------------------------------------
world.c:(define (eval-desc-predicate index args world/action)
world.c:  (search-arg-tree
world.c:   args (get-symbol-args (world/action-world world/action) index)))
world.c:	nIndex=pcFormula->pfForm->uValue.psiSymbolInfo-asiWorldSymbols;
world.c:	if(pcFormula->pfForm->pcArgs)
world.c:		bTerms=ComputeTermsNoCopy(pcFormula->pfForm->pcArgs,pcTerms,plpLinearPlan,pbBindings);
world.c:			TermError("eval-desc-predicate",pcFormula,pbBindings);
world.c:	nIndex=pcFormula->pfForm->uValue.psiSymbolInfo-asiWorldSymbols;
world.c:	if(pcFormula->pfForm->pcArgs)
world.c:		pcTerms=ComputeTerms(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings);
world.c:			TermError("eval-desc-predicate",pcFormula);
world.c:(define (eval-desc-function index args world/action)
world.c:  (find-value-arg-tree
world.c:   (get-symbol-args (world/action-world world/action) index)))
world.c:	nIndex=pcFormula->pfForm->uValue.psiSymbolInfo-asiWorldSymbols;
world.c:	if(pcFormula->pfForm->pcArgs)
world.c:		bTerms=ComputeTermsNoCopy(pcFormula->pfForm->pcArgs,pcTerms,plpLinearPlan,pbBindings);
world.c:			TermError("compute-desc-function",pcFormula,pbBindings);
world.c:	if(!plpLinearPlan->apbtWorld[nIndex])	// if function isn't initialized
world.c:	pc=FindValueArgTree(pcTerms,plpLinearPlan->apbtWorld[nIndex]);
world.c:	nIndex=pcFormula->pfForm->uValue.psiSymbolInfo-asiWorldSymbols;
world.c:	if(pcFormula->pfForm->pcArgs)
world.c:		pcTerms=ComputeTerms(pcFormula->pfForm->pcArgs,plpLinearPlan,pbBindings);
world.c:			TermError("compute-desc-function",pcFormula);
world.c:	if(!plpLinearPlan->apbtWorld[nIndex])	// if function isn't initialized
world.c:	pc=FindValueArgTree(pcTerms,plpLinearPlan->apbtWorld[nIndex]);
world.c:	for(pc=pcFormula;pc;pc=pc->pcNext)
world.c:			TermError("compute-plus-eq",pcFormula,pbBindings);
world.c:			switch(pcValue->pfForm->nType)
world.c:					nSum+=pcValue->pfForm->uValue.nInteger;
world.c:					dfSum=nSum+pcValue->pfForm->uValue.dfFloat;
world.c:					ErrorMessage("ComputePlusEq:  Invalid or non-numeric argument\n");
world.c:			switch(pcValue->pfForm->nType)
world.c:					dfSum+=pcValue->pfForm->uValue.nInteger;
world.c:					dfSum+=pcValue->pfForm->uValue.dfFloat;
world.c:					ErrorMessage("ComputePlusEq:  Invalid or non-numeric argument\n");
world.c:		TermError("compute-minus-eq",pcFormula,pbBindings);
world.c:	switch(pcValue->pfForm->nType)
world.c:			nDifference=pcValue->pfForm->uValue.nInteger;
world.c:			dfDifference=pcValue->pfForm->uValue.dfFloat;
world.c:			ErrorMessage("ComputeMinusEq:  Invalid or non-numeric argument\n");
world.c:	if(!pc->pcNext)
world.c:			pc=MakeIntegerForm(-nDifference);
world.c:			pc=MakeFloatForm(-dfDifference);
world.c:	for(pc=pc->pcNext;pc;pc=pc->pcNext)
world.c:			TermError("compute-minus-eq",pcFormula,pbBindings);
world.c:			switch(pcValue->pfForm->nType)
world.c:					nDifference-=pcValue->pfForm->uValue.nInteger;
world.c:					dfDifference=nDifference-pcValue->pfForm->uValue.dfFloat;
world.c:					ErrorMessage("ComputeMinusEq:  Invalid or non-numeric argument\n");
world.c:			switch(pcValue->pfForm->nType)
world.c:					dfDifference-=pcValue->pfForm->uValue.nInteger;
world.c:					dfDifference-=pcValue->pfForm->uValue.dfFloat;
world.c:					ErrorMessage("ComputeMinusEq:  Invalid or non-numeric argument\n");
world.c://	apbt=plp->apbtWorld;
world.c://	nBTree=psi-asiWorldSymbols;
zone.c:/* zone.c -- zoned memory allocation routines.
zone.c:Copyright C, 1997 - 2001  F. Bacchus
zone.c:#define ROUNDUP(x,y) (((x)+(y)-1)/(y)*(y))
zone.c:	pzCurrent->nAllocations++;
zone.c:	pzCurrent->nTotal+=nLength;
zone.c:		for(pm=pzCurrent->pmRover;;pm=pm->pmNext)
zone.c:			if(pm==pzCurrent->pmRover)
zone.c:			if(pm->nTag!=FREE)
zone.c:						pm->nTag);
zone.c:			pm1=(MEMORYP)((char *)pm+pm->nLength);
zone.c:			if(pm1->nTag==FREE)
zone.c:				pm1->pmNext->pmPrev=pm1->pmPrev;	/* unlink second block */
zone.c:				pm1->pmPrev->pmNext=pm1->pmNext;
zone.c:				pm->nLength+=pm1->nLength;
zone.c:				if(pzCurrent->pmRover==pm1)
zone.c:					pzCurrent->pmRover=pm;
zone.c:			else if(pm1->nTag!=nReserved&&pm1->nTag!=RELOCATED)
zone.c:			k=pm->nLength-nLength;		/* calculate remainder */
zone.c:				pzCurrent->pmRover=pm;
zone.c:				pm->nLength=k;			/* shorten current block */
zone.c:				pm1->nTag=nReserved;
zone.c:				pm1->nLength=nLength;
zone.c:				return (void *)&pm1->pmNext;
zone.c:				pzCurrent->pmRover=pm->pmNext;
zone.c:				pm->pmPrev->pmNext=pm->pmNext;	/* unlink block */
zone.c:				pm->pmNext->pmPrev=pm->pmPrev;
zone.c:				pm->nTag=nReserved;
zone.c:				return (void *)&pm->pmNext;
zone.c:	pm=(MEMORYP)((char *)pvBlock-offsetof(MEMORY,pmNext));
zone.c:	if((pm->nTag!=nReserved&&pm->nTag!=RELOCATED)||pm->nLength&0x0000000F)
zone.c:		for(pa=pzCurrent->paMaster;pa;pa=pa->paNext)
zone.c:			if(pm>=pa->pmAddress&&(char *)pm<(char *)pa->pmAddress+pa->nLength-sizeof(MEMORY))
zone.c:	pzCurrent->nFrees++;
zone.c:	memset(pvBlock,0xFF,pm->nLength-offsetof(MEMORY,pmNext));
zone.c:	pm->nTag=FREE;
zone.c:	pm->pmNext=pzCurrent->pmNext;		/* link block to free list */
zone.c:	pm->pmPrev=(MEMORYP)pzCurrent;
zone.c:	pzCurrent->pmNext->pmPrev=pm;
zone.c:	pzCurrent->pmNext=pm;
zone.c:	nLength=((nLength+ALLOCATION-1)/ALLOCATION)*ALLOCATION;
zone.c:	pa->nLength=nLength;
zone.c:	pm=pa->pmAddress=(MEMORYP)VMALLOC(pa->nLength);
zone.c:	pm1=(MEMORYP)((char *)pa->pmAddress+nLength-sizeof(MEMORY));
zone.c:	pm1->nTag=nReserved;				/* don't coalesce beyond end of block */
zone.c:	pm1->nLength=sizeof(MEMORY);
zone.c:	pm1->pmNext=pm1->pmPrev=NULL;
zone.c:	pm->nTag=FREE;
zone.c:	pm->nLength=pa->nLength-sizeof(MEMORY);
zone.c:	pm->pmNext=pzCurrent->pmNext;		/* link block to free list */
zone.c:	pm->pmPrev=(MEMORYP)pzCurrent;
zone.c:	pzCurrent->pmNext->pmPrev=pm;
zone.c:	pzCurrent->pmNext=pm;
zone.c:	pzCurrent->pmRover=pm;
zone.c:	pa->paPrev=NULL;					/* update master list */
zone.c:	pa->paNext=pzZone->paMaster;
zone.c:	pa->paNext->paPrev=pa;
zone.c:	pzZone->paMaster=pa;
zone.c:	if(!pzZone->paMaster)
zone.c:		pa->paPrev=pa->paNext=NULL;
zone.c:		pa->nLength=ALLOCATION;
zone.c:		pm=pa->pmAddress=(MEMORYP)VMALLOC(pa->nLength);
zone.c:		pm1=(MEMORYP)((char *)pa->pmAddress+ALLOCATION-sizeof(MEMORY));
zone.c:		pm1->nTag=nReserved;			/* don't coalesce beyond end of block */
zone.c:		pm1->nLength=sizeof(MEMORY);
zone.c:		pm1->pmNext=pm1->pmPrev=NULL;
zone.c:		pm->nTag=FREE;					/* initialize free memory block */
zone.c:		pm->nLength=pa->nLength-sizeof(MEMORY);
zone.c:		pm->pmPrev=pm->pmNext=(MEMORYP)pzZone;
zone.c:		pzZone->paMaster=pa;			/* initialize zone */
zone.c:		pzZone->nTag=nReserved;
zone.c:		pzZone->nLength=0;
zone.c:		pzZone->pmNext=pzZone->pmPrev=pm;
zone.c:	pzZone->pmRover=pm;
zone.c:		pzZone->nAllocations=0;
zone.c:		pzZone->nFrees=0;
zone.c:		pzZone->nTotal=0;
zone.c:	for(pa=pzZone->paMaster;pa;pa=pa->paNext)
zone.c:		for(pm=pa->pmAddress;
zone.c:			(char *)pm<(char *)pa->pmAddress+pa->nLength-sizeof(MEMORY);
zone.c:			pm=(MEMORYP)((char *)pm+pm->nLength))
zone.c:			if(pm->nTag!=FREE&&pm->nTag!=nReserved&&pm->nTag!=RELOCATED)
zone.c:					pm,pm->nTag);
zone.c:		if((char *)pm!=(char *)pa->pmAddress+pa->nLength-sizeof(MEMORY)||
zone.c:			pm->nTag!=nReserved)
zone.c:				pm,pm->nTag);
zone.c:	if(pzZone->nTag!=nReserved||pzZone->nLength!=0)
zone.c:	pzZone->pmNext=pzZone->pmPrev=(MEMORYP)pzZone;
zone.c:	pzZone->nAllocations=0;
zone.c:	pzZone->nFrees=0;
zone.c:	pzZone->nTotal=0;
zone.c:	for(pa=pzZone->paMaster;pa;pa=pa->paNext)
zone.c:		pm=pa->pmAddress;
zone.c:		pm->nTag=FREE;					/* initialize free memory block */
zone.c:		pm->nLength=pa->nLength-sizeof(MEMORY);
zone.c:		pm->pmNext=pzZone->pmNext; 		/* link block to free list */
zone.c:		pm->pmPrev=(MEMORYP)pzZone;
zone.c:		pzZone->pmNext->pmPrev=pm;
zone.c:		pzZone->pmNext=pm;
zone.c:		memset((char *)pm+sizeof(MEMORY),0xFF,pm->nLength-sizeof(MEMORY));
zone.c:	pzZone->pmRover=pzZone->pmNext;
zone.c://	for(pa=pzCurrent->paMaster;pa;pa=pa->paNext)
zone.c://		for(pm=pa->pmAddress;
zone.c://			(char *)pm<(char *)pa->pmAddress+pa->nLength-sizeof(MEMORY);
zone.c://			pm=(MEMORYP)((char *)pm+pm->nLength))
zone.c://			if(pm->nTag!=FREE&&pm->nTag!=nReserved)
zone.c://					pm,pm->nTag);
zone.c://		if((char *)pm!=(char *)pa->pmAddress+pa->nLength-sizeof(MEMORY)||
zone.c://			pm->nTag!=nReserved)
zone.c://				pm,pm->nTag);
zone.c://	if(pzZone->nTag!=nReserved||pzZone->nLength!=0)
zone.c://	for(pa=pzZone->paMaster;pa;pa=pa1)
zone.c://		pa1=pa->paNext;
zone.c://	pzZone->pmNext=NULL;
zone.c://	pzZone->pmPrev=NULL;
zone.c://	pzZone->pmRover=NULL;
zone.c://	pzZone->paMaster=NULL;
zone.c://	pzZone->nAllocations=0;
zone.c://	pzZone->nFrees=0;
zone.c://	pzZone->nTotal=0;
zone.c:	for(pm=pzZone->pmNext;pm!=(MEMORYP)pzZone;pm=pm->pmNext)
zone.c:		nFreeSize+=pm->nLength;
zone.c:	for(pa=pzZone->paMaster;pa;pa=pa->paNext)
zone.c:		nMasterSize+=pa->nLength;
zone.c:		pzZone->nAllocations,pzZone->nFrees,pzZone->nTotal);
zone.c:		pzZone->nAllocations-pzZone->nFrees,
zone.c:		nMasterSize-nFreeSize-nMaster*sizeof(MEMORY));
zone.c:	pzCurrent->nTotal=0;
zone.c:	for(pa=pzZone->paMaster;pa;pa=pa1)
zone.c:		pa1=pa->paNext;
zone.c:		for(pm=pa->pmAddress;
zone.c:			(char *)pm<(char *)pa->pmAddress+pa->nLength-sizeof(MEMORY);
zone.c:			pm=(MEMORYP)((char *)pm+pm->nLength))
zone.c:			switch(pm->nTag)
zone.c://					Histogram(1,pm->nLength);
zone.c:					ZoneFree(&pm->pmNext);
zone.c://					Histogram(0,pm->nLength);
zone.c:					pm->nTag=nReserved;
zone.c:					pzCurrent->nTotal+=pm->nLength;
zone.c://					Histogram(1,pm->nLength);
zone.c:						pm,pm->nTag);
zone.c:		if((char *)pm!=(char *)pa->pmAddress+pa->nLength-sizeof(MEMORY))
zone.c:			if(pm->nTag!=nReserved||pm->nLength!=sizeof(MEMORY)||
zone.c:				pm->pmNext||pm->pmPrev)
zone.c:		if(!bUsed&&(pa->paNext||pa->paPrev))	/* don't deallocate all memory! */
zone.c:			for(pm=pa->pmAddress;
zone.c:				(char *)pm<(char *)pa->pmAddress+pa->nLength-sizeof(MEMORY);
zone.c:				pm=(MEMORYP)((char *)pm+pm->nLength))
zone.c:				if(pm->nTag==FREE)
zone.c:					if(pzCurrent->pmRover==pm)
zone.c:						pzCurrent->pmRover=pm->pmNext;
zone.c:					pm->pmNext->pmPrev=pm->pmPrev;
zone.c:					pm->pmPrev->pmNext=pm->pmNext;
zone.c:			if(pa->paPrev)
zone.c:				pa->paPrev->paNext=pa->paNext;
zone.c:				pzCurrent->paMaster=pa->paNext;
zone.c:			if(pa->paNext)
zone.c:				pa->paNext->paPrev=pa->paPrev;
zone.c:			VFREE(pa->pmAddress);
zone.c:	nDelta=pzCurrent->nTotal-*pnRunningTotal;
zone.c:	*pnRunningTotal=pzCurrent->nTotal;
zone.c:		CommandPrintf(stderr,"Copying memory to non-permanent zone.\n");
zone.c:	pm1=(MEMORYP)((char *)pv1-offsetof(MEMORY,pmNext));
zone.c:	if((pm1->nTag!=RESERVED_P&&pm1->nTag!=RESERVED_S&&pm1->nTag!=RELOCATED)||
zone.c:		pm1->nLength&0x0000000F)
zone.c:	if(pm1->nTag==RELOCATED)
zone.c:		return (void *)pm1->pmNext;
zone.c:	if(pm1->nTag!=RESERVED_S)			/* if not in scratch zone */
zone.c:	nSize=pm1->nLength-offsetof(MEMORY,pmNext);
zone.c:	pm2=(MEMORYP)((char *)pv2-offsetof(MEMORY,pmNext));
zone.c:	pm1->nTag=RELOCATED;
zone.c:	pm1->pmNext=(MEMORYP)pv2;
zone.c:	pm=(MEMORYP)((char *)*ppv-offsetof(MEMORY,pmNext));
zone.c:	if((pm->nTag!=nReserved&&pm->nTag!=RELOCATED)||pm->nLength&0x0000000F)
zone.c:	if(pm->nTag==RELOCATED)
zone.c:		*ppv=(void *)pm->pmNext;
zone.c:		for(pa=zPermanent.paMaster;pa;pa=pa->paNext)
zone.c:			if((MEMORYP)*ppv>=pa->pmAddress&&
zone.c:				(char *)*ppv<(char *)pa->pmAddress+pa->nLength-sizeof(MEMORY))
zone.c:			CommandPrintf(stderr,"Relocating to memory in non-permanent zone.\n");
zone.c:	if((dwSize&(GRANULARITY-1))!=0)
zone.c:		ErrorMessage("Allocating odd-ball memory block\n");
