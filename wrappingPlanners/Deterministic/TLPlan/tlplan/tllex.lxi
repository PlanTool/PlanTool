/* tllex.lxi

Copyright C, 1997, F. Bacchus

Log:

Name		Date	Description

M Ady		970103	First Version

*/

%{

/* tllex.c -- temporal logic "list" language lexical analyzer

Copyright C, 1997, F. Bacchus


This module was created automatically from the file tllex.lxi.

Do not edit this file, edit and rebuild tllex.lxi instead.

Notes:
	1.  List structures are not allocated for punctuation.
*/

#include <ctype.h>
#include <setjmp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WIN32 
#include <windows.h>
#endif /* WIN32 */

#include "tlplan.h"
#include "iface.h"
#include "list.h"
#include "tllex.h"
#include "tlparse.h"
#include "tl_tab.h"
#include "util.h"
#include "zone.h"

/* redefine input routine */

#undef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	result=(*pfYYInput)(buf,max_size)

/* handle unrecognized token */

#undef ECHO
#define ECHO \
	return(ATOM_BADTOK)

YY_DECL;								/* yylex prototype */


/* #define VERBOSE */							/* define for verbose output */

%}

/* auxiliary definitions */

SIGN		[\+\-]
DIGIT		[0-9]
ALPHA		[A-Za-z]
SPECIAL		[\!\$\%\&\*\/\:\<\=\>\?\~\_\^]
SUBSEQUENT	[\.\+\-]

/* options (keep ansi C happy) */

%option nounput
%option noyywrap

/* state definitions */

%x STRINGSTATE
%x COMMENTSTATE

%%

[Ii][Nn][Ff]\+		{					/* infinity */
#ifdef VERBOSE
						ErrorMessage("Infinity\n");
#endif
						*plValue=NewList(ATOM_INFINITY,yytext);
						return(ATOM_INFINITY);
					}
({ALPHA}|{SPECIAL})({ALPHA}|{SPECIAL}|{DIGIT}|{SUBSEQUENT})*	|
\+\=				|
\-\=				|
\+					|
\-					|
\.\.\.				{					/* identifier */
#ifdef VERBOSE
						ErrorMessage("Identifier %s\n",yytext);
#endif
						*plValue=NewList(ATOM_IDENT,yytext);
						return(ATOM_IDENT);
					}
{SIGN}?{DIGIT}+		{					/* integer */
#ifdef VERBOSE
						ErrorMessage("Integer %s [%d]\n",yytext,atol(yytext));
#endif
						*plValue=NewList(ATOM_INTEGER,yytext);
						return(ATOM_INTEGER);
					}
{SIGN}?{DIGIT}+\.{DIGIT}*	{			/* floating point number */
#ifdef VERBOSE
						ErrorMessage("Floating point %s [%f]\n",yytext,atof(yytext));
#endif
						*plValue=NewList(ATOM_FLOAT,yytext);
						return(ATOM_FLOAT);
					}
{SIGN}?{DIGIT}*\.{DIGIT}+	{			/* floating point number */
#ifdef VERBOSE
						ErrorMessage("Floating point %s [%f]\n",yytext,atof(yytext));
#endif
						*plValue=NewList(ATOM_FLOAT,yytext);
						return(ATOM_FLOAT);
					}
\"					{					/* start of string */
#ifdef VERBOSE
/*						ErrorMessage("Start of string [%s]\n",yytext); */
#endif
						BEGIN(STRINGSTATE);
						yymore();
					}
<STRINGSTATE>\\.	{					/* escaped character in string */
#ifdef VERBOSE
						ErrorMessage("...found escape in string [%s]\n",yytext);
#endif
						yymore();
					}
<STRINGSTATE>[^"\n\\]*	{				/* anything but quote, newline and back slash */
#ifdef VERBOSE
/*						ErrorMessage("... found non-escape characters in string [%s]\n",yytext); */
#endif
						yymore();
					}
<STRINGSTATE>\"		{					/* end of string (includes trailing quote) */
#ifdef VERBOSE
/*						ErrorMessage("End of string [%s]\n",yytext); */
						ErrorMessage("String [%s]\n",yytext);
#endif
						BEGIN(INITIAL);
						*plValue=NewList(ATOM_STRING,yytext);
						return(ATOM_STRING);
					}
<STRINGSTATE>\n		{					/* end of line before end of string */
#ifdef VERBOSE
						ErrorMessage("End of line in string [%s]\n",yytext);
#endif
						BEGIN(INITIAL);
/*						errmsg(current_line,yytext-yysol, */
/*							"String missing end quote\n"); */
						ErrorMessage("String missing end quote\n");
						*plValue=NewList(ATOM_STRING,yytext);
						return(ATOM_STRING);
					}
;					{					/* start of comment */
#ifdef VERBOSE
						ErrorMessage("Start of comment %s\n",yytext);
#endif
						BEGIN(COMMENTSTATE);
						yymore();
					}
<COMMENTSTATE>.*$	{					/* ignore comments */
#ifdef VERBOSE
						ErrorMessage("Comment text %s\n",yytext);
#endif
						BEGIN(INITIAL);
					}
<COMMENTSTATE>.*	{					/* ignore comments */
#ifdef VERBOSE
						ErrorMessage("Comment text with no newline %s\n",yytext);
#endif
						BEGIN(INITIAL);
					}
:\(					{					/* start interval */
#ifdef VERBOSE
						ErrorMessage("Start interval\n");
#endif
						*plValue=NewList(ATOM_IDENT,"(");
						return(ATOM_LOWER_OPEN);
					}
:\[					{					/* start interval */
#ifdef VERBOSE
						ErrorMessage("Start interval\n");
#endif
						*plValue=NewList(ATOM_IDENT,"[");
						return(ATOM_LOWER_CLOSED);
					}
\]:					{					/* end interval */
#ifdef VERBOSE
						ErrorMessage("End interval\n");
#endif
						*plValue=NewList(ATOM_IDENT,"]");
						return(ATOM_UPPER_CLOSED);
					}
\):					{					/* end interval */
#ifdef VERBOSE
						ErrorMessage("End interval\n");
#endif
						*plValue=NewList(ATOM_IDENT,")");
						return(ATOM_UPPER_OPEN);
					}
\(					{					/* start parenthesis */
#ifdef VERBOSE
						ErrorMessage("Start parenthesis\n");
#endif
						*plValue=0;
						return('(');
					}
\)					{					/* end parenthesis */
#ifdef VERBOSE
						ErrorMessage("End parenthesis\n");
#endif
						*plValue=0;
						return(')');
					}
,					{					/* comma */
#ifdef VERBOSE
						ErrorMessage("Comma\n");
#endif
						*plValue=0;
						return(',');
					}
\n					{					/* end of line */
#ifdef VERBOSE
/*						ErrorMessage("End of line\n\n"); */
#endif
						nLineNumber++;
					}
[ \t]+				{					/* discard whitespace */
					}
%%

/* LoadFile

Description:
	Load in a .tlp file.
Notes:
	1.  We need to save our previous input buffer if LoadFile is called recursively.
	We must do this here, since flex doesn't expose all of its buffering
	machinery to the outside world.
*/

DECLSPEC void LoadFile
(
	char *psFile						/* file name */
)
{
	FILE *pfSaved;						/* saved input file stream */
	YY_BUFFER_STATE ybfSaved;			/* saved buffer state */
	int nLineNumberSaved;				/* saved line number */
	char *psCurrentFileSaved;			/* saved file name */
	BOOL bInteractiveModeSaved;			/* saved interactive mode */
	
	/* open the plan file */

	pfSaved=pfInput;
	nLineNumberSaved=nLineNumber;
	nLineNumber=1;
	bInteractiveModeSaved=bInteractiveMode;

	if(psFile&&psFile!=(char *)-1)
	{
		bInteractiveMode=FALSE;
		if(bVerbose)
			Message("Loading file: %s\n",psFile);
		pfInput=fopen(psFile,"r");
		if(!pfInput)
		{	
			ErrorMessage("Failed to open file %s\n",psFile);
			perror("File open failure");
			goto cleanup;
		}
	}
	else if(!psFile)
	{
		bInteractiveMode=TRUE;
		if(bVerbose)
			Message("Opening interactive session...\n");
		pfInput=stdin;
	}
	else
	{
		bInteractiveMode=TRUE;
		pfInput=0;
	}

	psCurrentFileSaved=psCurrentFile;
	if(pfInput==stdin)
	{
		psCurrentFile=(char *)malloc(strlen("interactive session")+1);
		strcpy(psCurrentFile,"interactive session");
	}
	else if(!pfInput)
	{
		psCurrentFile=(char *)malloc(strlen("window session")+1);
		strcpy(psCurrentFile,"window session");
	}
	else
	{
		psCurrentFile=(char *)malloc(strlen(psFile)+1);
		strcpy(psCurrentFile,psFile);
	}

	ybfSaved=YY_CURRENT_BUFFER;
	if(ybfSaved)
		yy_switch_to_buffer(yy_create_buffer(pfInput,YY_BUF_SIZE));

	/* parse the input file */

	if(bInteractiveMode)
		CommandPrintf(stdout,"OK> ");
	yyparse();
	if(pfInput&&pfInput!=stdin)
		fclose(pfInput);

	/* clean up */

	free(psCurrentFile);
	psCurrentFile=psCurrentFileSaved;
	if(ybfSaved)
		yy_switch_to_buffer(ybfSaved);	/* restore saved buffer */
cleanup:
	pfInput=pfSaved;					/* restore saved file handle */
	nLineNumber=nLineNumberSaved;
	bInteractiveMode=bInteractiveModeSaved;
}

/* StringToFormula

Description:
	Parse a string and convert it to a formula.
Notes:
	1.  We need to save our previous input buffer, in case load is active.
	We must do this here, since flex doesn't expose all of its buffering
	machinery to the outside world.
*/

DECLSPEC CELLP StringToFormula
(
	char *psString						/* string to convert */
)
{
	YY_BUFFER_STATE ybfSaved;			/* saved buffer state */
	int nLineNumberSaved;				/* saved line number */
	char *psCurrentFileSaved;			/* saved file name */

	/* set up for string input */

	ybfSaved=YY_CURRENT_BUFFER;
	nLineNumberSaved=nLineNumber;
	nLineNumber=1;

	psCurrentFileSaved=psCurrentFile;
	psCurrentFile=(char *)malloc(strlen("StringToFormula")+1);
	strcpy(psCurrentFile,"StringToFormula");

	psInput=psString;

	if(ybfSaved)
		yy_switch_to_buffer(yy_create_buffer(NULL,YY_BUF_SIZE));

	/* parse the string */

	pfYYOutput=TranslateList;
	pfYYInput=string_input;
	yyparse();
	pfYYInput=yy_input;
	pfYYOutput=ExecuteList;
	if(ybfSaved)
		yy_switch_to_buffer(ybfSaved);	/* restore saved buffer */

	nLineNumber=nLineNumberSaved;
	free(psCurrentFile);
	psCurrentFile=psCurrentFileSaved;

	return pcParsedFormula;
}

