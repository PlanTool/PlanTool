%start mystartsymbol

%{
/* 
* $Revision: 3.6 $
* $Date: 1999/07/09 22:17:57 $
*
*/

extern int printf(const char *,...);
extern void * malloc();
extern void free(void *);

#include <ctype.h>
#include "alldefs.h"

int yyerror(char *);
extern int yylex();


/* These globals store the main collections of data produced by the parser. */

domptr topdom;
predlist allpreds;


/* Variables used in PDDL to check that domain and problem names match. */

char * dname;
char * pname;


/* Value used because PDDL STRIPS has no types. */
 
char * notype = "";



/* Track whether we are reading operators or problem spec. - constants have to
handled slightly differently in each case. */

int pstate = 0;


/* Store variables declared in an operator, and the extras generated by abstracting
constants appearing in operators. */

tpptr ml = 0;
tpptr alex = 0;


/* Store constants as they are read in. */

tpptr cur_obs = 0;
tpptr cur_obs1;


/* Variables used to track the (not (= ...)) preconditions and the propositions 
created when abstracting constants from operators. */

plptr uneqpairs = 0;
plptr extraprops = 0;
plptr allextraprops = 0;

/* Variables list */

tpptr vl = 0;

extern int lineno;

void printrels(plptr);

void printpropn(propptr);

void initialiseParser()
{
	lineno = 0;
	uneqpairs = 0;
	allextraprops = 0;
	extraprops = 0;
	vl = 0;
	cur_obs = 0;
	pstate = 0;
	ml = 0;
	alex = 0;
};



void finishOps()
{
	pstate = 1;
};


/* Many of the following functions are simply used to construct the parsed
structures as they are read in. Very little of great interest is happening here. */

effptr
setelist(effptr lots,effptr one)
{
	if(one->adds)
	{	one->adds->rest = lots->adds;
		lots->adds = one->adds;
	}
	else
	{
		one->dels->rest = lots->dels;
		lots->dels = one->dels;
	};

	free(one);
	return lots;
};

effptr
setadd(propptr p)
{
	effptr x = (effptr) malloc(sizeof(struct efflist));
	x->adds = (plptr) malloc(sizeof(struct proplist));
	x->dels = 0;

	x->adds->rest = 0;
	x->adds->prop = p;
	return x;
};

effptr
setdel(propptr p)
{
	effptr x = (effptr) malloc(sizeof(struct efflist));
	x->dels = (plptr) malloc(sizeof(struct proplist));
	x->adds = 0;

	x->dels->rest = 0;
	x->dels->prop = p;
	return x;
};


oplistptr
setset(opptr o,oplistptr os)
{	oplistptr newseq = (oplistptr) malloc(sizeof(struct operator_set));
	newseq->op = o;
	newseq->ops = os;
	return newseq;
};



pptr
setpair(char * n,char * m)
{	pptr newpair = (pptr) malloc(sizeof(struct pair));
	newpair->varname = n;
	newpair->type_name = m;
	newpair->type[0] = 0;
	newpair->type[1] = 0;
	newpair->used = 0;
	newpair->isInPre = 0;

	return newpair;
};

predlist
setpred(char * n,int x)
{	predlist newcell = (predlist) malloc(sizeof(struct predcell));
	newcell->name = n;
	newcell->numargs = x;
	newcell->fr = 0;
	newcell->ar = 0;
	newcell->next = 0;
	newcell->initially = 0;
	return newcell;
};


tpptr
findfst(tpptr ts,char * nm1,char * nm2)
{
	for(;ts;ts=ts->tps)
	{	if(strcmp(ts->type->varname,nm1)==0)
			return ts;
		if(strcmp(ts->type->varname,nm2)==0)
			return ts;
	};

	printf("Error: variable unknown\n");
	return 0;
};

void
adduneq(tpptr ts,tpptr thefst,char * nm1,char * nm2)
{
	tpptr the_snd = 0;
	uneqlist newuneq;

	if(strcmp(thefst->type->varname,nm1)==0)
	{
		the_snd = findfst(ts,nm2,nm2);
	}
	else
	{
		the_snd = findfst(ts,nm1,nm1);
	};


	newuneq = (uneqlist) malloc(sizeof(struct uneqlistnode));
	newuneq->uneq = thefst;
	newuneq->next = the_snd->uneqs;
	the_snd->uneqs = newuneq;
};

tpptr
setdecls(pptr p,tpptr ts)
{	tpptr newdecls = (tpptr) malloc(sizeof(struct type_decls));
	newdecls->tps = ts;
	newdecls->type = p;
	newdecls->uneqs = 0;
	return newdecls;
};


tpptr 
appendvars(tpptr a,tpptr b)
{
	tpptr tmp=b;

	if(b==0) return a;

	for(;b->tps;b=b->tps);

	b->tps = a;

	return tmp;
};

opptr
setop(tpptr ts,opptr o)
{	
	tpptr the_first_var = 0;

	o->vars = ts;
	for(;uneqpairs>0;uneqpairs = uneqpairs->rest)
	{
		the_first_var = findfst(ts,uneqpairs->prop->nm->varname,uneqpairs->prop->as->nm->varname);
		adduneq(ts,the_first_var,uneqpairs->prop->nm->varname,uneqpairs->prop->as->nm->varname);
	};


	o->vars_shadow = o->vars;

	return o;
};


opptr
setoprels(plptr ps,plptr as,plptr ds)
{	opptr newop = (opptr) malloc(sizeof(struct operator_));
	newop->precs = ps;
	newop->adds = as;
	newop->dels = ds;
	newop->statics = extraprops; 

	if(ps && extraprops)
	{
		for(extraprops = ps;extraprops->rest;extraprops=extraprops->rest);

		extraprops->rest = newop->statics;
	}
	else
	{
		if(extraprops) newop->precs = extraprops;
	};

	extraprops = 0;
#ifdef MOBFILTER
	newop -> optype = 0;
	newop -> mobvars = 0;
	newop -> data = 0;
#endif
	return newop;
};

opptr
setopname(char * n,tpptr a,opptr o)
{

	tpptr xs = vl;
	propptr x;

	o->vars = a;
	o->thename = (propptr) malloc(sizeof(struct propn));
	o->thename->nm = (pptr) malloc(sizeof(struct pair));
	o->thename->nm->varname = n;
	o->thename->as = 0;
	for(;xs;xs=xs->tps)
	{
		x = (propptr) malloc(sizeof(struct propn));
		x->nm = xs->type;
		x->as = o->thename->as;
		o->thename->as = x;
	};
	return o;
};


plptr
setplist(plptr n,propptr p)
{	plptr newpl = (plptr) malloc(sizeof(struct proplist));
	newpl->rest = n;
	newpl->prop = p;
	return newpl;
};

propptr
setpropn(pptr n,propptr alist)
{	propptr newprop = (propptr) malloc(sizeof(struct propn));
	newprop->as = alist;
	newprop->nm = n;
	return newprop;
};

pptr 
findquery(char * v)
{	tpptr ptr = ml;
	while (ptr != 0)
	{	if (strcmp(ptr->type->varname,v)==0)
		{return ptr->type;};
		ptr=ptr->tps;
	};
	return 0;
};

int 
findalex(char * v)
{	tpptr ptr = alex;
	while (ptr != 0)
	{	if (strcmp(ptr->type->varname,v)==0)
		{return 1;};
		ptr=ptr->tps;
	};
	return 0;
};

predlist
insertpred(predlist, propptr,predlist);

pptr addextraprop(pptr c)
{
	propptr newp,newp1;
	plptr newp2;
	pptr newc;

	if(pstate) return c;

	newc = findquery(c->varname);

	if(newc) return newc;

	newc = setpair(c->varname,"101");
	newp = setpropn(newc,0);
	ml = setdecls(newc,ml);

	newp1 = setpropn(newc,newp);
	newp2 = (plptr) malloc(sizeof(struct proplist));
	newp2->rest = extraprops;
	newp2->prop = newp1;
	extraprops = newp2;

	if(!findalex(c->varname))
	{
		newp2 = (plptr) malloc(sizeof(struct proplist));
		newp2->rest = allextraprops;
		newp2->prop = newp1;
		allextraprops = newp2;
		alex = setdecls(newc,alex);

		allpreds = insertpred(setpred(c->varname,1),newp1,allpreds);
	};

	return newc;
};

void markUsedInOp(pptr c)
{
	if(!pstate) 
		c->used = 1;
};

	

propptr
setpropnargs(pptr n,propptr alist)
{	propptr alist2 = alist;
	propptr newprop = (propptr) malloc(sizeof(struct propn));
	newprop->as = 0;
	if(alist != 0)
	{	while (alist2->as != 0)
		{	alist2 = alist2->as;
		};
		alist2->as = newprop;
	}
	else
	{	alist = newprop;
	};
	newprop->nm = n;
	return alist;
};
	
domptr
make_domain(oplistptr os,plptr init,plptr gl)
{	domptr newdom = (domptr) malloc(sizeof(struct domain));
	newdom->ops = os;
	newdom->initial_state = init;
	newdom->goal_state = gl;
	newdom->statics = 0;

	return newdom;
};
	
domptr
add_to_domain(plptr init,plptr gl)
{
	topdom->initial_state = init;
	topdom->goal_state = gl;

	if(allextraprops) 	
	{
	  topdom->initial_state = allextraprops;
	  for(;allextraprops->rest;allextraprops=allextraprops->rest);

	  allextraprops->rest = init;

	};

  	allextraprops = init;

	return topdom;
};


/* The next group of functions are used in carrying out the fixed resource
analysis. This code preceded the code in TIM itself, so there is now some
overlap in the analysis - particularly the identification of deleted preconditions
and matching add effects. However, this analysis is concerned with predicates
rather than properties. */


int
checkMatch(propptr pre,propptr del)
{
	for(;pre;pre = pre->as)
	{
		if(strcmp(pre->nm->varname,del->nm->varname)) return 0;

		del=del->as;
	};

	return del==0;
};


plptr
exactMatch(propptr prp,plptr precs,plptr adds)
{
	/* Look for EXACT match between prp and something in precs.
	If it's there and also there is a match with the predicate
	in adds then return the adds pointing at next thing after
	the match. If no match, then kill it by returning 1. */

	for(;adds;adds=adds->rest)
		if(strcmp(prp->nm->varname,adds->prop->nm->varname)==0)
			break;

	if(adds)
	{	
		for(;precs;precs=precs->rest)
			if(checkMatch(precs->prop,prp)) break;

		if(precs)
		{	
			adds = adds->rest;
			return adds;
		}
		else
		{
			return (plptr) 1;
		};
	}
	else
	{
		return (plptr) 1;
	};
};


int
variableResource(char * nm,opptr op)
{
	plptr dels = op->dels;
	plptr adds = op->adds;

	/* Must check whether the predicate appears on the pre and del
	in the same form (an exact match) and on add list. For fixed
	resource each delete list instance must appear as a precondition
	and be matched by one separate instance on the add list */

	for(;dels;dels=dels->rest)
	{
		if(strcmp(dels->prop->nm->varname,nm)==0)
			adds = exactMatch(dels->prop,op->precs,adds);

		if((int)adds==1) break;
	};

	if((int) adds == 1) return 1;

	if(adds==0) return 0;

	for(;adds;adds=adds->rest)
		if(strcmp(adds->prop->nm->varname,nm)==0)
			break;

	return adds!=0;
};				

int
achiever(char * nm,plptr adds)
{
	for(;adds;adds=adds->rest)
		if(strcmp(nm,adds->prop->nm->varname)==0)
			return 1;
	return 0;
};

void
analyse()
{
	predlist tba = allpreds;
	oplistptr ops;

	for(;tba;tba=tba->next)
	{
		for(ops = topdom->ops;ops;ops=ops->ops)
			if(variableResource(tba->name,ops->op)) break;
		
		if(!ops) 
		{
			tba->fr = 1;
		};

		for(ops = topdom->ops;ops;ops=ops->ops)
			if(achiever(tba->name,ops->op->adds))
			{ 
				tba->ar++;
				tba->op = ops->op;
			};
	};
};

/* Procedure to track the objects in the domain. This code preceded use of
PDDL, which provides an explicit list of domain objects in the problem
specification. We continue to extract objects from the rest of the problem
specification and to ignore the objects list. A minor consequence of this
is that objects which have no initial state properties will be lost to the
TIM/STAN system - this means that certain odd domains could prove to have
no plan in STAN (and missing objects in TIM), but this can only occur when
operators have add effects which refer to objects which are not mentioned
in preconditions. These are only sensible in trivial unstructured domains
and don't seem to arise in practice. */

tpptr
insertob(pptr p, tpptr ts)
{	tpptr newp = (tpptr) malloc(sizeof(struct type_decls));
	tpptr ptr = ts;
	tpptr trail = ts;
	int i;
	newp->type = p;
	if (ts == 0)
	{
	 newp->tps = 0;
	 return newp;
	};
	i=strcmp(ts->type->type_name,p->type_name);
	i = i?i:strcmp(ts->type->varname,p->varname);
	if (i==0) {return ts;};
	if (i>0)
	{
		newp->tps = ts;
		return newp;
	}
	else 
	{	ptr = ptr->tps;
		while (ptr != 0)
		{	i=strcmp(ptr->type->type_name,p->type_name);
			i = i?i:strcmp(ptr->type->varname,p->varname);
			if (i==0) {ptr->type->used = p->used; return ts;};
			if (i > 0)
			{	newp->tps = ptr;
				trail->tps = newp;
				return ts;
			};
			trail = ptr;
			ptr=ptr->tps;
		};
		trail->tps = newp;
		newp->tps = 0;
		return ts;
	};
	
};

/* A procedure to track the predicates in the domain: again, this predates
PDDL in which the predicates are explicitly listed. That field of the PDDL
domain spec. is ignored. */

predlist
insertpred(predlist p, propptr theprop, predlist ps)
{
	predlist ptr = ps;
	predlist trail = ps;
	int i;
	plptr newp2;


	if (ps == 0)
	{
	 return p;
	};
	i=strcmp(ps->name,p->name);
	if (i==0)
	{
		if(pstate)
		{
			newp2 = (plptr) malloc(sizeof(struct proplist));
			newp2->rest = ptr->initially;
			newp2->prop = theprop;
			ptr->initially = newp2;

		};
		return ps;
	};
	if (i>0)
	{
		p->next = ps;
		return p;
	}
	else 
	{	ptr = ptr->next;
		while (ptr != 0)
		{	i=strcmp(ptr->name,p->name);
			if (i==0) 
			{
				if(pstate)
				{
					newp2 = (plptr) malloc(sizeof(struct proplist));
					newp2->rest = ptr->initially;
					newp2->prop = theprop;
					ptr->initially = newp2;

				};
				return ps;
			};
			if (i > 0)
			{	p->next = ptr;
				trail->next = p;
				return ps;
			};
			trail = ptr;
			ptr=ptr->next;
		};
		trail->next = p;
		p->next = 0;
		return ps;
	};
	
};


int 
countargs(propptr alist)
{
	int x = 0;
	for(;alist;alist=alist->as) x++;
	return x;
};

pptr 
find(char * v)
{	tpptr ptr = ml;
	while (ptr != 0)
	{	if (strcmp(ptr->type->varname,v)==0)
		{return ptr->type;};
		ptr=ptr->tps;
	};
	printf("missing variable declaration %s\n",v);
	exit(1);
}; 


void
setcurobs(domptr dm,tpptr cos)
{
	dm->obs = cos;
};


/* Procedure used in recording (not (= ..)) preconditions. Note this only
works on variable pairs - no constants. However, the constant abstraction
process will have converted constants into variables inside operators so
there is no problem with this. */

void
adduneqpair(propptr as)
{
	plptr newuneq = (plptr) malloc(sizeof(struct proplist));
	newuneq->prop = as;
	newuneq->rest = uneqpairs;
	uneqpairs = newuneq;
};


/* A range of output procedures - useful for debugging. */
	

void printtype(pptr p)
{	printf("%s",p->varname);
	printf("::");
	printf("%s",p->type_name);
	printf("(%i:%i)",p->type[0],p->type[1]);
};

void printuneqs(uneqlist ueqs)
{
	if(ueqs != 0)
	{
		printf("[");
		while(ueqs)
		{
			printf("%s-",ueqs->uneq->type->varname);
			ueqs=ueqs->next;
		};
		printf("]");
	};
};

void printtypes(tpptr ts)
{	if(ts != 0)
	{	
		while(ts->tps != 0)
		{
			printtype(ts->type);

			printuneqs(ts->uneqs);

			printf(",");
			ts = ts->tps;
		};

		printtype(ts->type);
		printuneqs(ts->uneqs);
	};
};

void printop(opptr o)
{	printtypes(o->vars);	
	printrels(o->precs);
	if(o->statics) 
	{	printf(".."); printrels(o->statics); printf("..");};
	printrels(o->adds);
	printrels(o->dels);
	printpropn(o->thename);
	printf("\n\n");
};


void print(oplistptr os)
{	while(os != 0)
	{	printop(os->op);
		os=os->ops;
	};
};

void printprops(propptr);

void printpropn(propptr p)
{	if(p != 0)
	{	printf("%s",p->nm->varname);
		printprops(p->as);
	};
};

void printprops(propptr p)
{	
	if(p)
	{
		propptr ptr1 = p;
		printf("(");
		while(ptr1->as!=0)
		{	printf("%s",ptr1->nm->varname);
			printf(",");
			ptr1 = ptr1->as;
		};
		printf("%s",ptr1->nm->varname);
		printf(")");
	}
	else
	{
		printf("()");
	};
};

void printrels(plptr rs)
{	plptr ptr = rs;

	printf("[");
	if(ptr == 0){printf("]");}
	else {
		while (ptr->rest != 0)
		{	printpropn(ptr->prop);
			printf(",");
			ptr = ptr->rest;
		};
		printpropn(ptr->prop);
		printf("]");
	};
};

void printdomain(domptr dm)
{	print(dm->ops);
	printrels(dm->initial_state);
	printrels(dm->goal_state);
	printtypes(cur_obs);
};



void 
printresults()
{
	predlist tba = allpreds;

	printf("Fixed resources:\n");

	for(;tba;tba=tba->next)
		printf("%s - %i:%i\n",tba->name,tba->fr,tba->ar);
};

/* In the specification of the grammar that follows, there is a certain amount 
of redundancy and slightly odd structuring. Much of this arises from the fact 
that the parser is a mutation of one intended for a very different language
from PDDL and it was converted in a short time (just before the AIPS'98 planning
competition!). There are probably some much tidier solutions to some of the
minor parsing issues that arise in PDDL, too. */				

%}

%union	{
	opptr op;
	plptr pl;
	propptr prp;
	oplistptr olp;
	domptr dom;
	pptr pp;
	tpptr tp;
	char * cp;
	effptr effs;
	int punct;
	};

%type <dom> domain_desc mystartsymbol the_rest
%type <olp> opreps the_domain
%type <op> oprep conditions
%type <pl> goals prerels relations lots_of_relations init
%type <prp> relation args arglist prelation single_relation
%type <tp> fullvarlist varlist morevars
%type <pp> variable_decl constant variable
%type <effs> erelation effectrels mixed_relations single_erelation
%type <punct> the_constants constants predicates predicate optreqs pvarlist fullpvarlist pvariable_decl opt_length opt_serial opt_parallel

%token <cp> NAME
%token <punct> OPEN_BRAC CLOSE_BRAC PRE DEFINE REQS DOMAIN STRIPS CONSTANTS PREDS PROBLEM INITIALLY GOALS ACTION ARGS EFFECTS NOT Q STATICS AND DEL SITUATION FORDOMAIN VARS EQ LENGTH PARALLEL SERIAL
%%

mystartsymbol : domain_desc  {$$=$1;topdom=$1;}
		| the_rest {$$=$1;setcurobs($1,cur_obs);analyse();}

domain_desc : the_domain  {$$ = make_domain($1,0,0);}	

the_rest : OPEN_BRAC the_problem OPEN_BRAC the_constants init goals opt_length CLOSE_BRAC {$$ = add_to_domain($5,$6);}

the_domain : OPEN_BRAC DEFINE OPEN_BRAC DOMAIN NAME CLOSE_BRAC 
		OPEN_BRAC optreqs
		 the_constants
	 	PREDS predicates CLOSE_BRAC
		opreps CLOSE_BRAC {$$ = $13; dname = $5;}

optreqs :  REQS STRIPS CLOSE_BRAC OPEN_BRAC {$$=0;} 
	| REQS STRIPS EQ CLOSE_BRAC OPEN_BRAC {;$$=0;} 
	| REQS EQ STRIPS CLOSE_BRAC OPEN_BRAC {$$=0;} | {$$=0;}

opt_length : {$$=0;}
	| OPEN_BRAC LENGTH opt_serial CLOSE_BRAC {$$=0;}

opt_serial : {$$=0;}
	| OPEN_BRAC SERIAL NAME CLOSE_BRAC opt_parallel {$$=0;}
	| OPEN_BRAC PARALLEL NAME CLOSE_BRAC {$$=0;}

opt_parallel : {$$=0;}
	| OPEN_BRAC PARALLEL NAME CLOSE_BRAC {$$=0;}

the_constants : CONSTANTS constants CLOSE_BRAC OPEN_BRAC {$$ = 0;} | {$$=0;}

constants : {$$ = 0;} | NAME constants {$$ = 0;}

predicates : predicate {$$ = 0;} | predicates predicate {$$ = 0;}

predicate : OPEN_BRAC NAME pvarlist CLOSE_BRAC {$$ = 0;}

the_problem : DEFINE OPEN_BRAC PROBLEM NAME CLOSE_BRAC OPEN_BRAC FORDOMAIN NAME CLOSE_BRAC {if(strcmp($8,dname)) {perror("Problem not for this domain!\n"); exit(1);};pname = $4;finishOps();}

init : INITIALLY lots_of_relations CLOSE_BRAC {$$ = $2;}

goals : OPEN_BRAC GOALS relations CLOSE_BRAC {$$ = $3;}

opreps : oprep {$$ = setset($1,0);}
	| opreps oprep {$$ = setset($2,$1);}

oprep 	: OPEN_BRAC ACTION NAME ARGS OPEN_BRAC varlist conditions CLOSE_BRAC
		{$$ = setop(ml,setopname($3,$6,$7));}

conditions : prerels effectrels {$$ = setoprels($1,$2->adds,$2->dels);free($2);}

prerels : PRE relations {$$ = $2;}

effectrels : EFFECTS OPEN_BRAC mixed_relations {$$ = $3;}

mixed_relations : single_erelation {$$ = $1;}
		| erelation CLOSE_BRAC {$$ = $1;}
		| erelation mixed_relations {$$ = setelist($2,$1);}
		| AND erelation mixed_relations {$$ = setelist($3,$2);}

prelation : OPEN_BRAC DEL OPEN_BRAC EQ args CLOSE_BRAC CLOSE_BRAC {adduneqpair($5);}

relations : OPEN_BRAC CLOSE_BRAC {$$=0;} | relation {$$ = setplist(0,$1);} | prelation {$$ = 0;}
	| OPEN_BRAC AND lots_of_relations CLOSE_BRAC {$$=$3;}

lots_of_relations : relation {$$ = setplist(0,$1);} | prelation {$$ = 0;}
	| relation lots_of_relations {$$ = setplist($2,$1);}
	| prelation lots_of_relations {$$ = $2;}

erelation : OPEN_BRAC DEL OPEN_BRAC NAME args CLOSE_BRAC CLOSE_BRAC 
				{$$ = setdel(setpropn(setpair($4,0),$5));}
	| relation {$$ = setadd($1);}

single_erelation : DEL OPEN_BRAC NAME args CLOSE_BRAC CLOSE_BRAC 
				{$$ = setdel(setpropn(setpair($3,0),$4));}
	| single_relation {$$ = setadd($1);}

args 	:  {$$ = 0;}
	| arglist {$$ = $1;};
	 
arglist : variable {$$ = setpropnargs($1,0);}
	| constant {$$ = setpropnargs($1,0);}
	| arglist variable {$$ = setpropnargs($2,$1);}
	| arglist constant {$$ = setpropnargs($2,$1);}

varlist : CLOSE_BRAC morevars {uneqpairs = 0;$$ = $2;ml = $2;vl=0;}
	| variable_decl CLOSE_BRAC morevars {uneqpairs = 0;$$ = setdecls($1,$3);ml = $$;vl = setdecls($1,0);}
	| fullvarlist variable_decl CLOSE_BRAC morevars {uneqpairs = 0;vl = setdecls($2,$1);$$ = appendvars(vl,$4);ml = $$;}

morevars : VARS OPEN_BRAC fullvarlist CLOSE_BRAC {$$ = $3;}
	| {$$ = 0;}

fullvarlist : variable_decl {uneqpairs = 0;$$ = setdecls($1,0);ml = $$;}
	| fullvarlist variable_decl {uneqpairs = 0;$$ = setdecls($2,$1);ml = $$;}

pvarlist : {$$ = 0;}
	| pvariable_decl {$$ = 0;}
	| fullpvarlist pvariable_decl {$$ = 0;}

fullpvarlist : pvariable_decl {$$ = 0;}
	| fullpvarlist pvariable_decl {$$ = 0;}

variable_decl :  Q NAME  {$$ = setpair($2,notype);} 

pvariable_decl : Q NAME {$$ = 0;}

variable : Q NAME {$$ = find($2);}

constant : NAME {$$ = setpair($1,notype); 
			   markUsedInOp($$);
			   cur_obs = insertob($$,cur_obs); 	
			$$=addextraprop($$);}

relation : OPEN_BRAC NAME args CLOSE_BRAC {$$ = setpropn(setpair($2,0),$3);
			   allpreds = insertpred(setpred($2,countargs($3)),$$,allpreds);};

single_relation :  NAME args CLOSE_BRAC {$$ = setpropn(setpair($1,0),$2);
			   allpreds = insertpred(setpred($1,countargs($2)),$$,allpreds);};



%%
#include <stdio.h>
int lineno = 0;
extern int fileno();
#include "lex.yy.c"

int yyerror(char * s)
{
 fprintf(stderr,"%s\n",s);
 fprintf(stderr,"Error occurred at or near line %i\n",lineno);

/* This is a very primitive error reporting "service"! */

 exit(1);

 return 0;
}
