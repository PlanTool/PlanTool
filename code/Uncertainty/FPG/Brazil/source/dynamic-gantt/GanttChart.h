/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Brazil.
 *
 * The Initial Developer of the Original Code is
 * National ICT Australia.
 * Portions created by the Initial Developer are Copyright (C) 2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *	Douglas Aberdeen	(doug.aberdeen@gmail.com)
 *	Owen Thomas		(owen.thomas@nicta.com.au)
 *	Olivier Buffet		(olivier.buffet@loria.fr)
 *
 * ***** END LICENSE BLOCK ***** */
/*
 *  GanttChart.h
 *  
 *
 *  Created by Owen Thomas on 12/05/06.
 *  
 *
 */

/*

The gantt chart must listen on new median plan signals. 
When it receives a new median plan signal it must call
drawFromState.

So that we know the correct time to draw from when new median
plan finishes it needs to set the currentGanttComponent pointer
to null. When the median plan signal is processed we will need
to retrieve the time from currentGanttComponent.

Planning and Simulating
When in planning mode the wrapper will periodically emit median
plan signals. These can be handled as described above.

When in simulating the planning wrapper will generate a single
median plan signal. This can be handled as above.

If planning has been performed and is restarted it will either 
overwrite the current plan represented in the gantt chart or
the user can save the current plan. Basically the user should
be asked whether they want to save the current plan as a bookmark.

This means that the gantt chart must maintain a reference to the
current plan which is updated by calls to median plan.

Undo, Redo can be supported by a linked list of brazil states that is updated
whenever a new median plan is generated AND the current gantt component is
not pointing to null - i.e. not just a median plan being generated by the
planner.

Parameters. 
We will need to save parameters.
How does this impact on the undo / redo...If we go back to a BrazilState, do we 
want to rewind the params? No. We only ever want the most up to date.


Visualisation overview.
- New Top-level menu item 'Gantt Chart' or something similar
- Split Pane view with the Gantt Bar container on the left and 
  the gantt chart on the right.
  
Actions:

Save as Bookmark
Undo
Redo
Stop Planning / Continue Planning

I need to create a state list that keeps a copy of the states generated
by the planner. This could be created inside the planning wrapper. WHY do
I need to do this? Because multiple views are necessary over the same set
of states (i.e. statistics and GANTT view). It also separates out of the 
gantt chart from having to worry about managing the memory associated with
a bunch of states.




*/
#ifndef gantt_chart
#define gantt_chart

#include <QWidget>
#include <QString>

#include <QLayout>
#include <QHBoxLayout>

class GanttBarArea;
class GanttNameArea;
class GanttBarContainer;

#include "GanttBar.h"
#include "../gui/BrazilStateList.h"

#include "../gui/BrazilPlanningWrapper.h"

#include "../planner/BrazilEventVisitor.h"

/** 
 * 
 * The GanttChart class renders a BrazilState instance as 
 * a gantt chart representing tasks and outcomes as bars
 * within the chart.
 *
 * A GanttChart is associated with a BrazilStateList and responds
 * to newState events on the list. If the most recent state in
 * the list will produce a graphically different GanttChart from
 * what is currently displayed, then the new state will be rendered
 * as a gantt chart.
 *
 * The GanttChart is dynamic and when the editable property is set
 * the duration of gantt bars can be altered and different outcomes
 * chosen for actions. Each atomic edit (e.g. one outcome change
 * or one duration change) constructs a new initial BrazilState, containing
 * events that were queued before the modification. A signal is emitted
 * containing this state allowing a planning system to produce a new
 * state from this initial state.
 *
 */
class GanttChart : public QWidget, protected BrazilEventVisitor 
{
	Q_OBJECT
	
		
	private:
		//The current state rendered in the gantt chart.
		BrazilState* currentState;
		
		//A widget that vertical displays the names of actions in each
		//bar row.
		GanttNameArea* ganttNameArea;
		
		//This displays gantt bars vertically.
		GanttBarArea* ganttBarArea;
		
		//The domain the current state is genereated under.
		DOMDomain* domain;
		
		//This widget contains the ganttnamearea and the bar area
		//displayed horizontally.
		QWidget* childContainer;
		QHBoxLayout* chlayout; //layout for childContainer
		
		//Map from actions to their gantt bar containers.
		
		//The same action can appear multiple times in the plan.
		//Each occurance has a unique (incrementative) actionCopy
		//field in the state.
		map<int, GanttBarContainer*> containers;
		
		
		//list of median states.
		//The Gantt chart and the statistic view need the same list
		//of median states. 
		
		//However, that's in the future. Currently I just want to maintain
		//this within GanttChart.
		BrazilStateList* medianStates;
		
		
		//list of drawn states. 
		//Not all median states are drawn.
		BrazilStateList* drawnStates;
		
		
		//Number of duration units per pixel.
		//If we add vertical bars down the gantt chart
		//then adjust this to be identical to ActionWidget.
		int scaling;
		
		//Are we currently drawing a state.
		//Set in handleNewMedianState.
		bool isDrawingState;
	
		//Can the user modify the gantt chart to request
		//generation of a median plan.
		bool editable;
		
	signals:
	
		void requestSimulationFrom (BrazilState*);

	protected slots:
		
		/**
		 * Handle the production of a new median state, this can include
		 * rendering a gantt chart and storing in a list of states.
		 *
		 * @param state, the state to render
		 * @param forceRender - whether to override the stopped
		 * value.
		 */
		void handleNewMedianState (BrazilState* state);
		
	protected:
	
		//Once this becomes user editable we will need to 
		//include a fromTimeCreated param.
		
		bool isVisuallyEquivalent (BrazilState* a, BrazilState* b) {
		
			//Let's fail quickly if we can.
			//Not strictly correct - will generate more false's than
			//necessary because of events that don't contribute to 
			//visualityness like NOTES or whatever.
			if(a->getPast ().size () != b->getPast ().size()
				|| a->getFuture ().size () != b->getFuture ().size ()) {
				
				return false;
			}
			
			//compare each event.
			//Relies upon is visuallyEquivalent for BrazilEvent,
			//defined below.
			//Fail if any identically positioned events aren't visually
			//equivalenet.
			
			//iterators for comparing...
			// Using type shortcut since types can change.
			BrazilState::EventsCIt ita;
			BrazilState::EventsCIt itb;
			
			//Past
			for(ita = a->getPast ().begin (), itb = b->getPast ().begin();
				
				//just test ita for being at the end as a&b are of
				//same length
				ita != a->getPast ().end ();
				
				ita ++, itb++) {
				
					if(!isVisuallyEquivalent ( ita->second, itb->second)) 
						return false;
			}
			
			//Future
			for(ita = a->getFuture ().begin (), itb = b->getFuture ().begin();
				
				//just test ita for being at the end as a&b are of
				//same length
				ita != a->getFuture ().end ();
				
				ita ++, itb++) {
				
					if(!isVisuallyEquivalent ( ita->second, itb->second)) 
						return false;
			}
			
			//All the events are visually equivalenet sooo....
			return true;
			
		}
		
		/**
		 * Returns true if two BrazilEvents will be represented identically
		 * in a gantt chart.
		 * 
		 */
		bool isVisuallyEquivalent (BrazilEvent* a, BrazilEvent* b) {
			return 
				a->type == b->type &&
				a->element == b->element &&
				a->queuedAt == b->queuedAt &&
				a->timeToOccur == b->timeToOccur;
		}
		
		/**
		 * Returns true if the next median state returned by
		 * the planner was the result of user interaction.
		 * To-Do: Implement!
		 */
		bool nextStateUserGenerated () {
			return true;
		}
		
		/**
		 * Completely rebuilds the GanttChart based on the
		 * specified state. This method uses drawFromState 
		 * defined below.
		 *
		 * @param state, the new BrazilState to represent.
		 */
		void buildGanttChart (BrazilState* state);
		
		/**
		 * Iterates through the events in state that occur after
		 * time and calls visit with each event.
		 *
		 * In effect this will draw the Gantt Chart from
		 * a particular point in time.
		 *
		 */
		void drawFromState (BrazilState* state, int time);
		
		/**
		 * Convienience method, calls drawFromState (state, 0);
		 */
		void drawFromState (BrazilState& state)
		{
			drawFromState (&state, 0);
		}
		
		//
		//BrazilEventVisitor interface.
		//GanttChart uses the BrazilEventVisitor methods to draw
		//individual gantt bars within calls to drawFromState.
		//
		//Currently these methods don't attempt to find existing
		//representations for their events. This is because it's
		//okay (performance wise) just to delete the whole gantt
		//chart and render it again every time a new state occurs.
		//For larger gantt charts, however, we might have to be
		//a bit smarter with our rerendering - the implementations
		//of these methods will need to be changed. 
		
		virtual void visitStartAction 
			(BrazilEvent* event, DOMAction* action);
		
		virtual void visitEndAction 
			(BrazilEvent* event, DOMAction* action);
		
		virtual void visitStartOutcome 
			(BrazilEvent* event, DOMOutcome* outcome);
		
		virtual void visitEndOutcome 
			(BrazilEvent* event, DOMOutcome* outcome);

		virtual void visitEffect 
			(BrazilEvent* event, DOMEffectSet* effect);

	public slots:
		
		/**
		 * Equivalent to calling setEditable (true);
		 */
		virtual void enableEditing () {
			setEditable (true);
		}
		
		/**
		 * Equivalent to calling setEditable (false);
		 */
		virtual void disableEditing () {
			setEditable (false);
		}
	
	public:
		
		/**
		 * Constructs a GanttChart that will render states
		 * added to medianStates.
		 */
		GanttChart (BrazilStateList& medianStates, 
			DOMDomain& domain,
			QWidget* parent = NULL,
			int scaling = 300); 
					
		virtual ~GanttChart ()
		{
			delete drawnStates;
			//TO-DO: what else should I delete?
		}
		
		void setDomain (DOMDomain& domain);
		
		const bool isEditable () {
			return editable;
		}
		
	   /**
		 * Makes this GanttChart editable by instructing each
		 * GanttBarContainer contained within it that it is 
		 * editable.
		 */
		void setEditable (bool editable);
		
		
		//Delete everything in the State that was created after the minimum
		//of new position and old position (for the position(s) changed).		
		//Use Event Queue information to get starting times for
		//the gantt bar.
		//Then resimulate, producing a new stae.
		//Once the State has been generated, calls drawfromstate
		//Note this should sanity check, to ensure that the position of bar
		//has _actually_ changed.
		void positionChanged (GanttBarContainer& container, int leftInvalidTime, BrazilEvent*);


		void moveEvents(const BrazilState::Events& src, BrazilState* newState, time_t invalidTime);
		
		void undo ();
		
		void redo ();
		
		bool canUndo ();
		
		bool canRedo ();
};
#endif


